1566777606
Tetralux
Why untyped?

1566777617
companion_cube
because the code isn't typed yet, right?

1566777625
Tetralux
Just have your interpreter be an intermediate stage to compilation.

1566777627
companion_cube
branches of the `if` are untypable

1566777636
Tetralux
Suddenly you can run your entire program at comptime.

1566777646
companion_cube
s/run/reduce/

1566777653
companion_cube
you can't run the part that are runtime

1566777663
Tetralux
You can require that you win a round of invaders before you're allowed to compile invaders ;)

1566777670
Tetralux
And yes, you can.

1566777675
Tetralux
Just more slowly.

1566777685
Tetralux
You can use pointers, create threads.

1566777687
companion_cube
how do you run a runtime part at compile time?

1566777705
Tetralux
Because compile time, IS, runtime.

1566777719
Tetralux
You can compute fib(25) at comptime.

1566777728
Tetralux
.. is an example.

1566777733
companion_cube
can you compute fib(n) where n is a runtime argument?

1566777758
Tetralux
Maybe we have cross-purposes here.

1566777760
Tetralux
My point is just

1566777766
Tetralux
That you have two "runtime" times.

1566777770
Tetralux
One is at compile time.

1566777771
companion_cube
one is called compile time

1566777779
companion_cube
and it's not evaluation but reduction

1566777783
Tetralux
My point is, the same code can work in both cases.

1566777806
Tetralux
You can run your game, win a round, and have your score become a constant in the final executable.

1566777826
Tetralux
Which you then have to beat by playing the game using the exectuable.

1566777844
Tetralux
That's a silly example, of course.

1566777897
Tetralux
But being able to open a window, use OpenGL, shaders, threads, and godknows what else at comptime, LIKE ITS JUST A PROGRAM, is a powerful tool to have in your toolbox.

1566777908
Tetralux
There's a certain beautiful simplicity in how transparent it is.

1566777947
companion_cube
you just give up on compilation being terminating ðŸ˜

1566777958
Tetralux
Who says it needs to be?

1566777960
Tetralux
I don't.

1566777996
Tetralux
And of course, since you're running at comptime, you

1566778000
Tetralux
etc, etc, etc.

1566778006
fengb
Then we could remove zig run entirely!

1566778024
companion_cube
insert joke about haskell here

1566778035
companion_cube


1566778039
Tetralux
zig first.zig -run "build_debug()"

1566778040
andrewrk
this is incompatible with cross compiling

1566778054
Tetralux
I'm not sure how.

1566778070
Tetralux
Though I could hazard a guess.

1566778094
Tetralux
The way you load OpenGl might be different across systems for example...

1566778118
shachaf
Solve compiletime nontermination the same way you solve runtime nontermination. It's not a big issue.

1566778131
shachaf
(There are some issues with this model, I think, but it's probably worth it.)

1566778137
mikdusan
`fn md5(anytime io: std.io.IO) u128 {...}` but something marked like this would preclude a pointer to md5()

1566778144
andrewrk
zig handles termination already with

1566778156
Tetralux
shachaf: By jove, I think they have it.

1566778177
shachaf
?

1566778187
Tetralux
> It's not a big issue.

1566778191
Tetralux
Also RE OpenGl, it would be fine because you'd be calling the same code you'd use at runtime to use it.

1566778216
companion_cube
not for cross compilation?

1566778258
Tetralux
If the things you are doing produce different answers based on OS, then you wouldn't use them for stuff that depended on the target.

1566778268
Tetralux
As in

1566778273
Tetralux
If you used it to produce a constant

1566778288
Tetralux
That you relied on at runtime being correct for the OS you are running on at runtime

1566778299
andrewrk
inline assembly won't work on a different architecture or if the cpu features don't match

1566778302
companion_cube
yeah, just don't make mistakes, like in C ;)

1566778304
andrewrk
endianness might mismatch

1566778322
Tetralux
But you produced it at comptime on a machine that produced a different answer because reasons...

1566778325
andrewrk
other stuff that zig's comptime is purposefully not capable is just asking for build issues when someone else goes to build

1566778340
Tetralux
Then you'd obviously expect it not to work.

1566778346
andrewrk
zig's comptime always works

1566778368
andrewrk
(bugs aside)

1566778426
Tetralux
I should note that obviously, you'd be running in the build env and not the target env, but.

1566778436
Tetralux
You could do some simple things to mitigate that quite easily.

1566778459
Tetralux
Like if you produce a constant and the target has a different endianness, you store it into the static segment with the target endianness.

1566778484
Tetralux
The point is, the power is for computation or setup.

1566778497
Tetralux
For build steps, etc.

1566778504
Tetralux
For code analysis.

1566778509
Tetralux
For house rules.

1566778523
Tetralux
Like "Please don't store a pointer to an game entity on a struct."

1566778538
Tetralux
".. because it becomes invalid quite often. Use the entity system instead."

1566778542
Tetralux
AND

1566778547
Tetralux
Emit a nice custom error for it.

1566778564
Tetralux
Or, enforce MISRA.

1566778579
companion_cube
sounds like you'd want to examine the whole AST for that

1566778584
companion_cube
not do comptime evaluation

1566778589
Tetralux
For that, yeah sure.

1566778619
companion_cube
funnily for that Go would be pretty ok, I heard they have good libs for parsing the language

1566778638
Tetralux
compiler_begin_intercept(); while (true) { var maybe_msg = compiler_wait_for_message(); if (maybe_msg) |msg| { // inspect it } }

1566778655
Tetralux
(I forgot to break if it returns null)

1566778655
fengb
Can I build an executable zig ast?

1566778664
Tetralux
and then.... compiler_end_intercept();

1566778680
Tetralux
fengb: That sounds like an interpreter.

1566778748
Tetralux
You could actually, god forbid, use that system to make a comptime GC xD

1566778758
Tetralux
And if you could mark things with notes...

1566778773
Tetralux
var resource = get_resource() @gc;

1566778787
Tetralux
Bad example for Zig, for several reasons.

1566778791
Tetralux
But you get my point.

1566778807
fengb
Jimmi built a GC allocator

1566778842
Tetralux
The concept basically comes down to, "Give programmer powerful tools that enable more than limit."

1566778856
Tetralux
...... but give good error messages xD

1566778865
Tetralux
Very Important.

1566781856
andrewrk
behavior tests passing in lazy values branch

1566781864
andrewrk
this is going to fix a lot of bugs

1566782636
Tetralux
Sounds promising.

1566783440
mikdusan
lazy values branch - is that expected to slightly improve memory usage of stage1 compiler because less dupe of ConstExprValue ?

1566783549
andrewrk
nope, it will slightly increase memory usage because not evaluating stuff right away requires more storage

1566783606
fengb


1566783619
fengb
Should there be an std function that converts an item into a single item slice?

1566784124
Tetralux
Which branch is the lazy values branch?

1566784220
andrewrk


1566784476
fengb
I got an error on build: /Users/benjamin.feng/projects/zig/std/build.zig:2278:18: error: struct 'std.build.Step' depends on itself

1566784501
fengb
I'll try doing fresh

1566784539
andrewrk
fengb, just the behavior tests are passing. `zig build` doesn't work yet

1566784548
andrewrk
./zig0 test ../test/stage1/behavior.zig

1566784553
fengb
Oh

1566784570
andrewrk
behavior tests are something like 90% of the way there

1566784590
andrewrk
anything not covered should ideally be added as additional behavior tests

1566798418
bgiannan
Any idea why this is seg faulting  zig?

1566801068
mikdusan
something to do with `packed struct`. try removing packed.

1566801147
mikdusan
also changing u8 array size from 20 to something like 32 seems to avoid the stage1 segfault

1566801224
bgiannan
i need the packed struct i my actual use case

1566801229
bgiannan
in*

1566801425
mikdusan
i think that is an open bug:

1566801644
bgiannan
seems to be it tanks mikdusan

1566802527
bgiannan
daurnimator, Tetralux, I think unions are a cleaner way of dooing OOP but it's really verbose. Here's an example of muli-level inheritance:

1566802758
bgiannan
but it may be slower than the @ptrCast solution ?

1566802926
mikdusan
that example is shifting dynamic dispatch from function pointers to manual switch statements

1566802963
ntgg
How would I pass a string from js to a zig fn?

1566803033
ntgg
I am currently trying to do fn([*]const u8, length: usize), but the text seems to be invalid

1566803062
mikdusan
ntgg: what is internal format of js string?

1566803082
ntgg
mikdusan: I converted the string to a utf8 array in js

1566803104
ntgg
I think the native is utf16

1566803287
bgiannan
mikdusan, here's the pointers solution but it relies on a shaky trick to find out what types an instance inherits from

1566803294
bgiannan
and requires packed structs

1566804762
gonz_
I think doing OOP should be very verbose, because you probably should not be doing OOP.

1566804795
gonz_
In any case it's probably better for you to pass comp time interfaces to functions that need to be working with different things.

1566804897
gonz_
Which also does not preclude you from making these distinctions with unions if you want to.

1566804980
bgiannan
gonz_, maybe but i would need at the very least rust-like traits (or swift-like protocols)

1566804996
gonz_
For what?

1566805108
bgiannan
Be able to hold an heterogeneous list of struct instances who exposes the same functions/behavior

1566805320
gonz_
If they are all part of the same union, the function returning the interface is the one that actually matters. They could all also just have a method that returns the interface for that type and that would be checked at compile time.

1566805417
mikdusan
what if you choose at runtime

1566805525
mikdusan
i'd like to give runtime params such as: a stream (stdout), a file, a memory buffer, a socket, a pipe, a hub

1566805526
gonz_
Then you just change the interface argument to not be `comptime` and the function returning it examines the values at runtime.

1566805528
bgiannan
gonz_, not sure i follow you

1566805549
mikdusan
and i don't want 6 times the code size

1566805555
gonz_
bgiannan: Likewise. I think the definition of "OOP" matters here.

1566805570
gonz_
mikdusan: Generated or written?

1566805612
mikdusan
generated

1566805641
gonz_
AFAICT zig doesn't need to generate tons of code for examining a value at runtime

1566805677
gonz_
Or whatever version we would have right now

1566805734
mikdusan
never said it did. i'm talking about code generation for comptime in lieu of runtime decision

1566805802
gonz_
Comptime passed interfaces that compile down to fast calls is likely to be a better default in terms of programmer choices

1566805837
gonz_
And those are already possible now, with very understandable semantics

1566805913
gonz_
Even if you were to decide late on the interface, I don't see how that's not possible atm

1566805943
gonz_
In any case I don't know that there's anything that needs adding at all with regards to any of this

1566805955
gonz_
I think there are already languages that are (allegedly) made for OOP

1566805978
bgiannan
OOP doesn't need to be a language feature

1566806036
gonz_
My point is that something like OOP or equivalent doesn't need

1566806104
gonz_
And I would argue they only think that because they are more interested in putting their fingerprint on zig with language features than they are with it being a usefully small language.

1566806131
bgiannan
i agree

1566806151
bgiannan
i'm just trying to find the most effective way of doing it in zig

1566806162
gonz_
I may have misrepresented/misunderstood your original point

1566806164
gonz_
sorry about that

1566806182
gonz_
I had been reading the backlog as usual and as usual there's a lot of high-flying talk about new features

1566806264
gonz_
But yes, simple things like unions, passed interfaces to functions, etc., make for almost everything you could actually need

1566806282
gonz_
I haven't found the boundaries yet but I would never suggest adding anything new until I had

1566806315
bgiannan
gonz_, did you see the @ptrCast solution i linked?

1566806330
gonz_
I did not, sorry

1566806570
gonz_
bgiannan: When did you paste it? I can't seem to find it in the logs.

1566806609
bgiannan
huh talked about it but forgot to paste the link, one sec

1566806644
bgiannan


1566807002
gonz_
Yeah, like you said it doesn't feel as reasonable as the union variant

1566807050
gonz_
And personally I wouldn't go for anything with less lines just for that

1566807059
bgiannan
right

1566807064
bgiannan
is it faster though?

1566807075
bgiannan
because of less indirections?

1566807078
gonz_
I dunno, I guess you would have to benchmark?

1566807215
mikdusan
z4-7.zig doesn't call base sayYourName()

1566807221
gonz_


1566807408
bgiannan
mikdusan, yes but sub-structs could just do `self.unit.unitSayYourName()` inside their `sayYourName` function

1566809501
mikdusan
bgiannan: slight variation.

1566809527
mikdusan
didn't add the ID tho

1566809678
bgiannan
yes but in the for loop at the end you have no way of knowing if any of those units are Agents or Terrains

1566826701
fengb
tgschultz had a branch with an Interface struct that used OpaqueType pointer:

1566826727
fengb
Not quite inheritance, but I'm not sure I really care about inheritance

1566826751
andrewrk
I believe that either he or Jimmi tested it and it was friendlier to LLVM's optimizations as well

1566826786
andrewrk
that being said, @fieldParentPtr should in theory be equivalent to the optimizer. it might be short-sighted to cater to something so volatile

1566826945
bgiannan
andrewrk, the volatile thing being OpaqueType ?

1566826995
andrewrk
the volatile thing being arbitrary optimizations which will not go into the zig language specification

1566827066
andrewrk
llvm is optimized for c and c++. @fieldParentPtr happens to be a bit uncommon in those domains. I'm predicting that if zig were more popular, this pattern would be recognized by the optimizer in the future

1566827156
andrewrk
rust had to implement a bunch of custom llvm optimization passes for their advanced stuff. in zig we barely need any of that because it's so similar to C, but there could be a couple benefits from doing some of that work

1566827521
fengb
Should IO errors be unified?

1566827893
andrewrk
I think that question is going to need more context

1566827933
fengb
Oh I've been misusing all these methods. nvm

1566829385
Tetralux_
There's not a special machine instructions for switch statements is there?

1566829508
mq32
Tetralux_, not really. I'd say: add+jmp or a lot of cmp+jmp

1566829515
mq32
depends on the complexity of the switch

1566829864
fengb
When should I use var vs comptime T?

1566829951
fengb
Tetralux_: most non-trivial switches optimize into jump tables

1566829981
fengb
so offset + jump

1566830013
andrewrk
fengb, generally, prefer comptime T, use var when it solves a problem

1566830071
Tetralux_
.. The reason being that it reduces code size to use comptime T.

1566831080
kristoff_it
So, I'm working on my Redis client, I've wired the parser to a stream and everything works. That said, I don't fully understand how Zig Streams work. Why do they close around an error type?

1566831122
andrewrk
kristoff_it, it's one of the open design flaws:

1566831162
fengb
Ah yeah, I'm currently using "var" to work around that >_>

1566831205
kristoff_it
Uhmm I see, thanks I'm gonna read that now. Btw andrewrk I think I wrote the first Redis client that doesn't need dynamic allocations for simple replies, judging from what's avaliable for C/C++

1566831207
andrewrk
I'm still considering how to solve this. not closing around an error type would be an improvement in several ways, but then the error set of the stream functions would lose information

1566831226
kristoff_it
I

1566831247
andrewrk
kristoff_it, that's great!

1566831269
andrewrk
I think that's a good example of how exposing allocations to be visible, encourages higher quality code

1566831279
kristoff_it
I'm looking forward for a stream about how to make async I/O work for people that are new tho this stuff :)

1566831316
andrewrk
I'm looking forward to that as well. I'm still doing some more proof-of-concept work in the std lib, and I will keep you posted

1566831332
kristoff_it
Yes, I also think that it's weird that nobody tried to do this stuff before, a lot of embedded stuff is using Redis.

1566831476
fengb
kristoff_it: are you doing zig for your day job?

1566831496
kristoff_it
I'm a developer advocate at Redis Labs

1566831503
kristoff_it
so... kinda

1566831672
kristoff_it
I write/talk about Redis, and Zig is in many ways a great fit, both for writing modules (dynamic libraries that Redis can load and expose as new commands) and, I think clients too.

1566831674
fengb
So... this generic error problem is exactly why checked exceptions are terrible in Java

1566831746
fengb
kristoff_it: that's pretty cool

1566831795
andrewrk
fengb, with regards to InStream, alternatives are: 1. use anyerror and the user of the stream will have to deal with that. or 2. fold errors into error{ReadFailed}

1566831834
andrewrk
this is, once again, a problem with function pointers

1566831843
fengb
Yeah, I'm just commenting that it's a hard problem to solve and I don't think anyone has done it well

1566831953
Tetralux_
Stupid question, but is there not a way to infer the errors?

1566831971
andrewrk
runtime-known function pointer prevents error inference

1566832015
andrewrk
there's a lot of significant beneficial things the compiler can do if there are no runtime-known function pointers

1566832154
Tetralux_
In what scenario do you

1566832166
Tetralux_
More to the point, why even have it be runtime known in the first place?

1566832170
Tetralux_
Case in point:

1566832176
andrewrk
interfaces

1566832197
Tetralux_


1566832250
Tetralux_
Notice how, read cannot fail if you passed an ArrayList, but you still must annotate the fn with anyerror in case it's not.

1566836145
gonz_
fengb: To be fair, is the alternative in Java really much better?

1566836168
gonz_
AFAICT Java has no reliable way to actually be sure about your error domain(s).

1566836232
gonz_
I'm not going to pretend to know the details, but when people bring up how the Java community doesn't like checked exceptions I can't help but think that other communities might/would prefer them to the chosen alternative for the most part.

1566836266
fengb
I don't think any other community uses checked exceptions

1566836311
gonz_
I didn't say they do, but that they might.

1566836322
fengb
It's hard in Java because there's no way to upcast exceptions. So either the generic definition is super limited or it's super vast

1566836341
gonz_
From what I understand of the value prop it seems a much better default attitude to have than the "anything goes" that comes with the alternative.

1566836359
fengb
And both are crappy for capturing actual meaning

1566836479
fengb
I've admittedly never worked in a language with better semantics. Maybe Haskell does it better?

1566836503
fengb
Elm just attaches result or maybe to everything, which also doesn't give a lot of useful information

1566836565
gonz_
Haskell is nice in terms of simple error use-cases but it has asynchronous exceptions (and you have to, it's not practically speaking a choice) and those are not really nice at all.

1566836602
gonz_
The community does the best it can and has a lot of machinery that can make it feel reasonable to a large extent, but no, it's not fundamentally nice.

1566836606
Tetralux
You'd think that returning a value marked as an error and checking if you'd handled them all would be enough.

1566836635
gonz_
Error unions are better than most things I've seen

1566836687
Tetralux
The only thing with error unions is that you could get almost all the way there just by having multiple returns value and the ability to mark one as an error.

1566836707
fengb
Yeah I really like Zig error handling

1566836714
gonz_
What's the purpose of that, though, Tetralux?

1566836727
Tetralux
More general, mainly.

1566836741
Tetralux
I do like being able to return an error I didn't define though.

1566836747
Tetralux
That's pro-exploration.

1566836748
fengb
I prefer errors being special. It solves so many problems that Go encounters

1566836760
fengb
You can just return `error.AnyArbitraryValue`

1566836807
Tetralux
return zero(T), 12 -> signature: fn() (T, int #error)

1566836812
gonz_
Special and mergable with each other, yes.

1566836818
gonz_
Is what makes them good to me

1566836831
donpdonp
usize(msgleft) ->  expected type 'usize', found 'isize'

1566836843
Tetralux
usize is not a cast.

1566836844
gonz_
The problem in most nominally typed languages that can return error variants is that there is no good way to merge them.

1566836845
fengb
@intCast(usize, msgleft)

1566836848
donpdonp
usize(x) appears to have some powers to cast one int type to another

1566836848
Tetralux
I get tripped up by that too.

1566836858
donpdonp
yet in some cases it wont do it

1566836867
fengb
type(foo) does a compile time cast. @intCast() is what you want

1566836871
Tetralux
It only casts comptime_int to an int type.

1566836878
Tetralux
It's more a type assertion.

1566836881
Tetralux
Like in:

1566836891
Tetralux
var x = if(cond) usize(1) else usize(42);

1566836910
donpdonp
ok comptime_int makes sense. thx.

1566836915
Tetralux
o7

1566836944
Tetralux
I do like how you can just make one up to return.

1566836950
Tetralux
That's pretty useful for me.

1566836969
donpdonp
is warn("{}", 12) -> compiler bug: integer and float literals in var args function must be casted. Fixed in HEAD yet? o^O

1566837006
Tetralux
I don't think so.

1566837941
andrewrk
none of the var args issues are scheduled to be fixed in 0.5.0

1566838049
kristoff_it
is there an easy way to know when a type is recursive?

1566838110
andrewrk
can you elaborate on your use case?

1566838191
Tetralux
Oh - also, you wanna be able to compose interfaces; things like `const Stream = Writer + Reader;` ... `fn f(rw: Stream) ...`

1566838214
Tetralux
Otherwise you end up with things like Peekable(Rewinder(Writer(T)))

1566838258
kristoff_it
`const reply = try client.send(i64, "GET", "key");`, If the first argument (which is the return type of .send) instead of being an i64 is a type that contains itself, then it's impossible to allocate statically. I was wondering if there was a simple way of rejecting those types immediately with a @compileError

1566838270
kristoff_it
andrewrk: forgot to tag you

1566838502
kristoff_it
maybe I'm thinking something stupid, now that I think more about it. You can't do it without pointers, otherwise the type would never end

1566838529
donpdonp
is there a case insensitive []u8 compare?

1566838544
andrewrk
kristoff_it, I suggest to not try to hide it from the API user

1566838552
donpdonp
i realize that crosses the sematic line of std.mem.compare into string-handling o^O

1566838594
kristoff_it
andrewrk: users can use .sendAlloc to decode responses with pointers

1566838611
alexander92
btw

1566838619
andrewrk
donpdonp, case sensitivity is more complicated than you might think at first. if you're comparing user provided strings, you'll need full unicode support. for your project you are using GTK I believe and they should expose a function for case insensitive string compare, because they already depend on full unicode support

1566838679
andrewrk
alexander92, I just landed a big branch into master, and yes those docs are up to date, but there is more that I'm still working on before I have a meaningful demo

1566838922
donpdonp
andrewrk: thx there is g_utf8_casefold () which looks like byte-compare can be used with the return value.

1566838968
andrewrk
donpdonp, that looks right

1566839057
fengb
Would Unicode be a userland thing?

1566839177
fengb
I mean implemented in std instead of the compiler

1566839220
andrewrk
yes

1566839229
andrewrk
but probably not even in the std lib

1566839237
Tetralux
Really?

1566839271
andrewrk
yeah because it's a large dependency that changes constantly and rarely needed

1566839289
andrewrk
"rarely" is debatable, but it's true that many important use cases don't need it

1566839324
Tetralux
I mean, printing to stdout needs it.

1566839329
andrewrk
why?

1566839340
Tetralux
Because you might want to print unicode characters xD

1566839356
Tetralux
Like, any time you want to interact with strings...

1566839359
andrewrk
stdout is a byte stream, not a unicode character stream

1566839365
earnestly
Tetralux: language doesn't need to do anything for that

1566839382
Tetralux
The language, maybe not. But std.strings?

1566839402
andrewrk
I'm still stuck on stdout. why does stdout need unicode?

1566839409
earnestly
Are strings not just byte arrays?

1566839422
fengb
Go has a concept of extra packages that are maintained by core but not in stdlib. Would that concept exist in Zig?

1566839444
Tetralux
andrewrk: Because terminals generally assume utf8.

1566839445
fengb
Unicode are a special subset of byte arrays with its own quirks

1566839466
Tetralux
earnestly: .. namely that some characters take up multiple bytes.

1566839468
fengb
Like codepoints != runes

1566839491
earnestly
Tetralux: That doesn't matter to the language though, it matters to the terminal interpreting it

1566839514
andrewrk
Tetralux, consider that you can manipulate UTF-8 in plenty of meaningful ways without the ability to decode or encode unicode, or have any knowledge of unicode whatsoever

1566839526
andrewrk
for example, you can print utf-8 encoded bytes to stdout

1566839567
andrewrk
you can test if a utf-8 encoded string contains '/'

1566839618
fengb
Print already works with UTF8. The terminal is interpreting the bytes

1566839634
Tetralux
I mean, you should be able to produce utf8 and consume it.

1566839662
andrewrk
I think a lot of people don't understand this, and I find it a bit difficult to communicate. It would be worth figuring out how to explain it in a helpful way and put it in the docs or FAQ

1566839663
earnestly
Tetralux: Like

1566839666
fengb
You can type Unicode into strings and they work too

1566839731
Tetralux
I think that it would be useful to have some basic utf8 stuff in the stdlib. Like encoding/decoding to and from []u8.

1566839780
Tetralux
Or be able to install a pkg for it and then have that globally available - that could work too I suppose.

1566839789
andrewrk
decoding/encoding into codepoints will be there. (it is there already, just incomplete)

1566839817
andrewrk
what won't be there is the ~10MiB unicode data about codepoints, for the reasons noted above

1566839837
Tetralux
That should definitely be an optional extra xD

1566839862
andrewrk
but yeah fengb I could see there being a "blessed" package for it. I don't think that's a decision that needs to be made now

1566839889
Tetralux
I just think that if you ever have to think twice about seemlessly allowing utf8 text in your program, then it could be better.

1566839907
Tetralux
And for that, you want it to be nigh-transparent.

1566839913
Akuli
utf8 in, utf8 out :D

1566839916
earnestly
Tetralux: But the language needs to be agnostic for that to work at all

1566839933
Cloudef
streams are bytes, not objects, not text

1566839934
earnestly
Iow, "just bytes"

1566839941
donpdonp
[arduino temperature sensor code 345bytes][UNICODE LIB 12MB] thats not gonna fit in my 2k atmel chip :)

1566839946
andrewrk
Tetralux, the phrase "allowing utf8 text" makes me think that you're not thinking about it in this way that I'm trying to communicate

1566839973
Tetralux
andrewrk: That's possible. I'm no expert in unicode fiddlings xD

1566839979
andrewrk
basically, don't decode ever

1566839983
andrewrk
there's rarely a reason to

1566840005
andrewrk
and then you fully support unicode, without any dependency on a unicode package

1566840022
Tetralux
This is true.

1566840031
Akuli
andrewrk, in a program like that, how do you lowercase a string?

1566840050
Tetralux
Or search for a substring.

1566840067
fengb
Shouldnâ€™t there be a validation step for Unicode?

1566840072
Cloudef
Tetralux: you have severe misunderstanding how text generally works

1566840073
Akuli
or implement a windows path equality function?

1566840083
andrewrk
you can't do either of those things in such a program. Unless the "string" is not user input and it's some thing from a spec which is guaranteed to be ascii

1566840086
Tetralux
Cloudef: Maybe xD

1566840122
Akuli
andrewrk, or some other subset of unicode, so that whenever someone needs to do this, they'll end up creating their own thing that works well until some character they didn't think of appears

1566840130
earnestly
Akuli: Is that not the domain of platform API?

1566840136
Akuli
as a finn, i might write it to handle Ã¤ and Ã¶, but not Ã¸, for example

1566840160
fengb
I know HFS+ has insane rules for case matching. I forgot if they fixed it for APFA

1566840163
fengb
APFS

1566840169
andrewrk
I mean like maybe the BMP file spec allows "BMP" or "bmp" for the magic bytes (it doesn't), but that would be a time you don't need real case folding

1566840178
Akuli
i was about to do this once but then i realized how horrible that idea was, and just went with python's case-insensitiveness which worked great

1566840211
Cloudef
Tetralux: most cli programs for example aren't unicode aware at all, but utf8 just happens to work since it's compatible with strcmp and friends

1566840217
andrewrk
and I stand by my claim that it's rare that a program needs to lower case a string

1566840228
andrewrk
if it really does, ok great, use real unicode

1566840239
Akuli
yeah that makes sense, if using real unicode is easy as adding a lib

1566840248
Tetralux
What about command line options that are case insensitive?

1566840258
Tetralux
Just only accept lowercase?

1566840260
Tetralux
xD

1566840274
Akuli
do some programs have case-insensitive switches?

1566840277
Cloudef
Tetralux: terminals, might be utf8 aware, some / old ones probably check your system locale. But generally output from program doesn't have to be "text"

1566840281
andrewrk
I feel like I mentioned this case already Tetralux

1566840309
Tetralux
Forgive me if I missed it. It's like 35C over here rn xD

1566840362
Cloudef
transforming / editing unicode is can of worms :P

1566840363
Tetralux
Suffice it to say, I'd want to make it robust, by not caring - but I'm not sure how I'd do that trivially.

1566840370
Tetralux
That's all I'm really saying.

1566840372
Cloudef
even simple toupper/tolower

1566840386
fengb
andrewrk: the protobuf spec has a separate string data from bytes. Should I just ignore the Unicode validation?

1566840401
andrewrk
fengb, I see what you're talking about now

1566840410
andrewrk
ok so your use case is to match the protobuf spec

1566840428
Tetralux
fengb: CBOR does too. Currently I'm checking it with unicode.utf8ValidateSlice on both encode and decode.

1566840445
andrewrk
I think validation does not carry the big dependency

1566840448
Cloudef
fengb: protobuf actual treasts string/bytes the same

1566840453
Cloudef
treats*

1566840466
andrewrk
that's just making sure it will decode successfully

1566840479
Cloudef
the string in spec is just hint for human

1566840483
fengb
Over the wire yes, but it embeds some semantic meaning implying proper Unicode

1566840499
Cloudef
I don't think the spec says it's supposed to be unicode

1566840500
fengb
Iâ€™m happier to ignore it if thatâ€™s the de facto standard :P

1566840509
Cloudef
it's just hint for human

1566840509
fengb
Oh? I should double check then

1566840520
andrewrk
fengb, I'm not suggesting to ignore standards

1566840523
fengb
Damn dirty humans

1566840531
earnestly
They make computers complicated

1566840564
Cloudef
nanopb is good protobuf reimplementation

1566840582
fengb
Iâ€™ve just been coding to spec atm

1566840593
Akuli
oh one thing where i would like to have some unicode awareness: gnu expand and unexpand don't handle Ã¤ and Ã¶ correctly

1566840611
Akuli
it's annoying when i have a file containing Ã¤'s and Ã¶'s on some lines and ascii on others, and when i expand it they just don't line up

1566840613
fengb
Or the human version rn. I need to dig into it further

1566840623
Akuli
because Ã¤ is two bytes but a is one byte, on my utf-8 system

1566840655
Akuli
but i guess that a function to count the number of characters in an utf-8 string is enough to fix that?

1566840669
fengb
Thatâ€™s runes vs codepoints. A program often doesnâ€™t need to care

1566840686
fengb
The terminal should handle it pretty well.

1566840690
Cloudef
Akuli: gnu expand?

1566840701
Akuli
i think it comes from coreutils

1566840731
Cloudef
ah

1566840732
Akuli
$ (echo $'a\tb' && echo $'Ã¤\tb') | expand -8

1566840732
Akuli
a       b

1566840732
Akuli
Ã¤      b

1566840735
Cloudef
I see what you mean now

1566840742
Akuli
this really sucks

1566840765
Cloudef
yeah, when you are lining up text like that, you want to be unicode aware

1566840770
alexander92
andrewrk, thanks, ill check out the new async code then when i can

1566840770
Cloudef
expand probably isn't

1566840802
earnestly
Cloudef: The terminal itself might also be missing it up, especially if it has to pull glyphs from other families

1566840823
andrewrk
alexander92, for now the most interesting code would probably be in test/stage1/behavior/async_fn.zig. Or look for social media in 2-3 weeks when I should hopefully have an impressive demo in the tech news :)

1566840829
Cloudef
earnestly: nah that's issue with expand

1566840836
Akuli
this one isn't the terminal's fault, it's expand's fault for counting bytes rather than code points or character widths

1566840849
Akuli
either one would be acceptable for my Ã¤ and Ã¶ needs

1566840874
earnestly
Cloudef: Ah so it is, tried with higher plane stuff and it fails all the more

1566840919
earnestly
wc -m is unicode aware for counting characters, as opposed to -c

1566840941
Cloudef
it would be trivial to support utf8 at least though

1566840944
Cloudef
counting runes isn't hard

1566840946
earnestly
And is 2 orders of magnitude slower

1566840966
Cloudef
I think some coreutils have switch for "utf8 aware" mode

1566840983
earnestly
Usually dictated by locale though

1566840996
Cloudef
that too

1566841140
fengb
andrewrk: would it be possible to generate an executable ast at comptime?

1566841199
andrewrk
ugh, c++ lets you implicit cast an enum to a bool

1566841226
andrewrk
fengb, not sure what you're asking. it sounds like you're trying to generate .zig code during the build?

1566841236
fengb
Yeah

1566841239
mq32
andrewrk, c++ bools are 150% broken

1566841319
andrewrk
fengb, can you elaborate on why you don't want to generate a .zig file?

1566841365
fengb
It'd be neat to be able for the code to consume a .proto file without needing to spit out the intermediate

1566841408
fengb
Not a dealbreaker by any means, but it'd be something special that Go couldn't do

1566841466
Tetralux
Who the hell uses protobufs?

1566841474
Cloudef
sadly a lot

1566841480
andrewrk
fengb, I've put some thought into this, and I think it's better to have the intermediate file on disk

1566841484
Tetralux
Cloudef: You're telling me.

1566841505
andrewrk
for one, debug info. stack traces will be improved, and in the debugger it wants to know where something is defined for structs

1566841521
fengb
Sure okay

1566841528
andrewrk
it's also a nice place for caching to happen

1566841546
andrewrk
empirically, @cImport improved once we had an intermediate file

1566841588
andrewrk
it's one reason we don't have @reify

1566841595
andrewrk
although that's still an open proposal

1566841676
mq32
@reify with structs could probably make inheritance/interface stuff a 100% userland thing

1566841723
mq32
also interface combining (what tetralux wrote in #2938) would be doable in userland

1566841761
andrewrk
it's undeniably powerful

1566841787
Tetralux
That would also be something Go cannot do.

1566841805
Tetralux
AFAIK, at any rate.

1566841960
companion_cube
beware of fragmentation when sublanguages can be built from userland

1566841989
mq32
yeah that's a drawback

1566841997
companion_cube
the lisp curse ;)

1566842003
mq32
ha, yeah

1566842006
mq32
Lua can do similar things

1566842022
mq32
it's crazy how much of a different language you can make with table syntax sugar

1566842035
fengb
Or Ruby, if you want to see an example of poor fragmentation :P

1566842040
companion_cube
like the meta thingy?

1566842312
mq32
companion_cube: you can define a function that determines the value of non-declared variables (okay, Lua can do this too)

1566842327
mq32
so you can do stuff like "a = hello world";

1566842368
companion_cube
:(

1566842373
companion_cube
plz, binders

1566842404
Akuli


1566842533
halosghost
method_missing isâ€¦ interesting

1566842664
andrewrk
I think the field alignment branch can get merged today

1566842697
fengb
The Ruby ecosystem loves to invent its own DSLs that are wholly incompatible with other libraries

1566842717
fengb
And the DSL system isn't even that robust, unlike Lisp

1566843081
Akuli
good luck getting autocompletion for a ruby dsl, lol

1566843779
alexander92
method_missing is not that strange

1566843784
alexander92
its based on smalltalk

1566843862
alexander92
i think autocompletion is a tooling problem: maybe autocompleters integrated in the compiler should be able to suggest better stuff for dsl-s/operator-based code etc

1566844109
companion_cube
autocompletion is hard because tooling, by nature, knows little about the code since it's all dynamic

1566844165
alexander92
that's true: but dsl-s in static languages don't have such a problem

1566844279
alexander92
e.g. depends on the type of metaproramming, but e.g. if you can define your dsl with some quasiquoting/or with some helpers, the language might be able to generate suggestions

1566844355
alexander92
or if you pattern match AST input for a macro (or you have compile time function "expression" types)

1566844621
earnestly
Will there ever be standard search paths for @import?  E.g. /usr/include/zig or -L like flags

1566844771
andrewrk
no, there will be package dependency declarations. but there could be flags to help the build system find alternative locations for the packages

1566844835
mq32
would be sane to store a single copy of each package at a centralized place

1566844862
mq32
rust/cargo doesn't do this and even small projects have 2.5 GB folder size because each project contains all packages in built/cached for

1566844864
mq32
*form

1566844940
THFKA4
hey yeah, we could also hash the "derivation" script for each package and prepend it to the name in this "store"

1566844981
andrewrk
nice try THFKA4

1566845010
andrewrk
not going to depend on a third party project for this

1566845011
earnestly
andrewrk: I would like to avoid language package managers if possible

1566845018
THFKA4
noooooo, he didn't bite

1566845041
earnestly
Having standard-ish locations for libraries, imports, etc. would help alleviate that need

1566845045
donpdonp
there is a standard, i forget the name, that is especially helpful for languages as dynamic as ruby, where the compiler runs as a daemon and the ide can submit queries like if these 5 modules are loaded, what are my autocomplete options

1566845071
mq32
donpdonp, did you mean "language server protocol"

1566845077
donpdonp
mq32 that sounds right :)

1566845103
earnestly
donpdonp: It's a microsoft invention

1566845120
Tetralux
mq32: I'd honestly just not have build artifacts.

1566845135
mq32
Tetralux, zig already has build artifacts ;)

1566845141
Tetralux
Yeah, and I dislike it xD

1566845142
mq32
just do "find zig-cache"

1566845146
mq32
but it's sane ;)

1566845181
Tetralux
I mean - you can't have caching related bugs without a cache

1566845185
earnestly
mq32: Is that what creates the ~/.local/share/zig (ignores XDG_DATA_HOME) directory?

1566845192
Tetralux
Besides which, how you do know that a bug isn't because of the cache.

1566845210
Tetralux
And of course, it's just as sane to just be fast enough that you don't need to do it.

1566845217
Tetralux
I'd argue, more sop.

1566845219
Tetralux
so*

1566845238
fengb
afaik, zig doesn't have cache errors

1566845266
Tetralux
I've run into several weirdnesses that were fixed by `--cache off`

1566845285
Tetralux
A piece of general advice

1566845303
Tetralux
What you just said is quite like saying that a piece of software "has no bugs."

1566845307
Tetralux
I instantly don't believe you. xD

1566845337
Tetralux
But even if it didn't, I'd rather not rely on something that

1566845343
Tetralux
I want things to be stupidly simple.

1566845346
Tetralux
.. but powerful.

1566845380
Tetralux
Besides which, object files are code duplication, no?

1566845404
Tetralux
If so, that's the same problem C++ has with builds taking two years.

1566845422
Tetralux
Though I'd imagine that Zig is a tad smarter about it than C++.

1566845440
Tetralux
Still though, I'd rather have sub-half-second complete compile times.

1566845463
Tetralux
Looking at you, stage2.

1566845615
mikdusan
andrewrk: just to confirm zig-ir does not have any actual instructions for runtime safety checks and that's all done at codegen?

1566846940
gonz_
Tetralux: You say these things as if it's just a choice you have to make and then suddenly it's done.

1566847132
Tetralux
Perhaps less of the "suddenly", but otherwise.. sure let's go with that.

1566847168
mikdusan
Tetralux: why is it you are unwilling to accept possibility of bugs from complexity of caching but are willing from incremental compiles (sub-half-second) ?

1566847192
mikdusan
both make things go fast

1566847202
Tetralux
mikdusan: Sub-half-second COMPLETE compilation.

1566847213
Tetralux
i.e: not incremental.

1566847235
Tetralux
Incremental doesn't have weird caching bugs.

1566847237
Tetralux
xD

1566847413
Tetralux
xD

1566847425
Tetralux
Oops. Wrong window xD

1566847558
gonz_
Tetralux: Since you feel very strongly about this I guess a forked version of the compiler that does ~100kloc/s compilations and no caching is something you should aim for.

1566847575
gonz_
Though maybe the real aim is ~1Mloc/s, IIRC.

1566847666
gonz_
Or maybe Thekla is hiring instead. :D

1566847843
Tetralux
Hey man - if I had a language that was fast to write good code in... ;)

1566847861
Tetralux
But yes - I'd consider it.

1566847952
andrewrk
Tetralux, no rumors spreading about cache system bugs unless you have a documented example please

1566847973
Tetralux
I thought you might say that.

1566847993
andrewrk
mikdusan, correct

1566848019
andrewrk
regarding runtime safety checks. although I do think it would be beneficial to move those checks (maybe all of them?) to zig ir

1566848035
andrewrk
mikdusan,

1566848152
mikdusan
yeah i'm looking into bounds checking and splitting logic between analysis and codegen is a little icky

1566848242
mikdusan
we can take a slice of a pointer to array `*[10]u32`, but is there reason why we can't take slice of pointer to slice `*[]u32` ?

1566848358
andrewrk
wow, fundude builds fast

1566848423
fengb
Well it's not too complex

1566848457
fengb
Doing some userland checking for the merge?

1566848462
andrewrk
yes

1566848497
fengb
I'll do a sweep later tonight to see which of the bugs I've encountered are fixed

1566848500
andrewrk
it fixes a bunch of bugs but it is still a breaking change

1566848535
fengb
I do abuse packed alignments quite a bit with fundude

1566848554
fengb
... I need to pick that back up

1566848574
andrewrk
you're probably also bound to run into "struct 'foo' depends on itself" followed by an error note trace. In most of these cases, the lazy value system can be improved to resolve the dependency loop. however some cases will need some code modifications

1566848608
fengb
Actually most of the issues Iâ€™ve encountered had to do with missed packing

1566848614
andrewrk
one limitation is comptime function evaluation. all parameters must be fully evaluated before evaluating the function

1566848627
fengb
Accidentally declaring a 7 bit struct and stuff

1566848648
andrewrk
ah yes. there's a lot of room for improvement around packed structs

1566848674
andrewrk
7 bit struct will work fine eventually. that's equivalent to u7

1566848682
andrewrk
but I didn't handle that case yet

1566848697
fengb
Well I didnâ€™t mean it. And the compiler just crashes on me

1566848704
andrewrk
yeah

1566848985
andrewrk
wow the new sound effects in oxid sound great

1566849018
andrewrk
I believe it's using

1566850830
alexander92
is it planned to have functions with delayed evaluation

1566850856
alexander92
maybe this might be enough to support some more macro-like usages

1566851125
Tetralux
What does "delayed evaluation" mean exactly?

1566851351
gonz_
Lazy evaluation, evaluated when needed, I assume.

1566851361
gonz_
A'la Haskell

1566851585
halosghost
aka call-by-need

1566851610
halosghost
which is fancy

1566851617
gonz_
I like it in Haskell but I don't think it has a place in a language desiring simplicity.

1566851618
halosghost
but rare

1566851633
halosghost
I'm not sure what the use-case would be in Zig

1566852473
halosghost
in Haskell, it allows for some really incredible things like simple operation on infinite lists (aka streams)

1566852487
halosghost
but, that's not exactly a common thing to do in a systems language

1566852518
halosghost
there are also some performance benefits, but Zig is already likely to out-perform most other modern languages anyway

1566857606
shritesh
I'm compiling Zig on Arch and it's failing at "Building CXX object CMakeFiles/zig_cpp.dir/src/zig_llvm.cpp.o" with an "initializing llvm::ArrayRef<..> from 'std::initializer_list<..>::begin'  does not extend the lifetime of the underlying array [-Werror=init-list-lifetime]" warning that's treatead as an error. I couldn't find an existing issue for it.

1566857625
andrewrk
shritesh, what c++ compiler/version?

1566857661
shritesh
g++ (GCC) 9.1.0

1566857674
andrewrk
let me see if I have that easily available

1566857706
mikdusan
shritesh: temp workaround: for 9.1.0:

1566857743
shritesh
mikdusan: Ah, thanks.

1566857759
andrewrk
thank you nixos, every major version of gcc is available including 9

1566857878
shritesh
It's just this one warning and might be trivial to fix.

1566858298
andrewrk
true, if you have llvm 9 rc2 built, you can try zig's llvm9 branch

1566858450
andrewrk
the actual flag I want c++ compilers to have is one that turns all warnings into errors that are present in XYZ version number and below

1566858460
andrewrk
then once a developer verifies there are no warnings on a given compiler version, they bump it

1566858751
shritesh
Tangent: does Zig have compiler warnings? I don't think I have seen one.

1566858757
andrewrk
no

