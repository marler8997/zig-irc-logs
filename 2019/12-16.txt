1576454570
merlyndmg
oh I figured it out. if I make it a comptime variable and do a manual `if` on it then it works

1576454582
merlyndmg
*parameter not variable

1576455002
merlyndmg
that said, would it be silly for something like transCreateNodeBoolInfixOp to do an assert that you only passed it a booland or boolor operator? The original CPP code made such an assert. Does the function get auto-duplicated if you use compile time values, as long as they're not type variables and thus actually have to have different

1576455003
merlyndmg
implementations?

1576455090
pixelherodev
"if I make it a comptime variable and do a manual `if` on it then it works" ... definitely not going to steal that idea :)

1576455112
pixelherodev
Also, regarding that LLVM backend thingy: I slowed down the VM and now it looks even cooler

1576455132
pixelherodev


1576455212
data-man
merlyndmg, try 'comptime assert(...)'

1576459311
andrewrk
frmdstryr, I'm definitely interested in working on the perf of stream server with regards to async and stuff, but there's a bunch of work to get to that point. I wonder if in the meantime you would be interested in looking into the perf of self-hosted parser

1576459325
andrewrk
that's a very straightforward, blocking operation

1576459343
andrewrk
even when we have threads, the task of parsing won't be split into threads

1576459360
andrewrk
(perhaps 2 threads separately parse 2 files, but not 2 threads on 1 file)

1576459391
andrewrk
and I'm sure that we're not at top speed for self-hosting parser, I think there is probably a lot of room for improvement

1576459412
andrewrk
how the arena allocator works for one, as well as which list data structure to use (I doubt the current use of SegmentedList is the best choice)

1576459422
andrewrk
and then maybe even some of the parsing code, idk

1576459452
mq32
andrewrk: do you really want to tell me that zig can now again compile for AVR

1576459487
mq32


1576461880
daurnimator
andrewrk: at this point... do you think streams as mixins will be accepted? I don't want to build too much more on top

1576461905
andrewrk
the part where the namespaces conflict is a no-go

1576461968
protty
andrewrk: hey, am here from the PR if youd prefer faster feedback

1576462037
daurnimator
FWIW I actually consider the namespace conflict a good thing. I can't imagine wanting to do: myobject.something.read()

1576463242
pixelherodev
Seconded

1576463642
daurnimator
I can't say I like rust's solution...

1576463682
mq32
daurnimator: C# has a quite nice feature for "different implementation of a method with the same signature from two different interfaces"

1576463694
mq32
interface A { void Foo(); } interface B { void Foo(); }

1576463708
mq32
class C : A, B { void A.Foo() { } void B.Foo() { } }

1576463719
mq32
whereas a normal implementation looks like this:

1576463730
mq32
class C : A { public void Foo() { } }

1576463780
daurnimator
mq32: if I have a `C`, how do I call them?

1576463805
mq32
you have to explicitly cast into the interface

1576463817
mq32
lemme test

1576463827
daurnimator
mq32: for just the conflicting case? or the general case?

1576463862
daurnimator
if just the conflicting case... I guess that's okay, but I think that people's tendency for defensive coding will make it a mess where people use it too much

1576463878
daurnimator
if its the general case.... I don't get the ergonomics I'm after

1576463897
mq32
look here:

1576463904
mq32
it's a quite nice solution

1576463904
daurnimator


1576463919
mq32
oof :D

1576463992
mq32
btw, refresh the ideone link, i've changed a bit

1576464192
daurnimator
in scala:

1576464413
daurnimator
mq32: I'm a little confused with your example: could you show an example of an interface adding "helper" methods?

1576464431
mq32
what is a helper method?

1576464437
mq32
C# has only "pure" interfaces

1576464472
daurnimator
e.g. base class implements `fn add(x) {}`, and now you want to add a `fn inc() { return add(1); }`

1576464510
mq32
ah

1576464511
daurnimator
--> the whole idea of "mixins" is to have a library of these wrappers that you can add to your object

1576464517
mq32
i'll make an example

1576464545
mq32
but keep in mind: C# can't do implementation of methods in templates

1576464550
mq32
*interfaces

1576464590
daurnimator
mq32: I think that's the whole point though: the question is: if you implement methods in interfaces/templates, then how do you handle collisions

1576464744
mq32


1576464752
mq32
c# doesn't allow the call then and requires an explicit cast

1576465173
daurnimator
mq32: how does that work with chaining?

1576465178
daurnimator
mq32: e.g. what if an interface implements or requires another interface?

1576465252
mq32
you can just use inheritance on interfaces

1576465256
mq32
interface B : A { }

1576465272
mq32
which will require all methods from A to be available when implementing B

1576465316
mq32
extension methods in C# are quite powerful as well. you can even implement them on generics

1576469138
adamkowalski
What options do we have for sets in the standard library?

1576469305
daurnimator
adamkowalski: std.HashMap(T, void)

1576469484
adamkowalski
daurnimator: thanks! if I want to construct a set of items (but the items are already stored somewhere else) should I just store the pointers in the HashMap?

1576469508
adamkowalski
Or if the struct is a union of u64 types just with different tags, should I store it by value?

1576469512
daurnimator
depends on the lifetime of the items and the set...

1576469518
adamkowalski
It is still a "primitive" type at that point right

1576469525
daurnimator
what is?

1576469538
adamkowalski
a union(enum) of many different u64 types

1576469570
adamkowalski
the lifetime of the items is going to be longer then the lifetime of the set

1576469577
adamkowalski
so storing pointers is not dangerous

1576469604
adamkowalski
however a union will be the size of the largest member anyway right? so it will be 64 bits

1576469610
adamkowalski
and a pointer will be 64 bits

1576469614
adamkowalski
so it seems like it doesn't matter?

1576470671
daurnimator
adamkowalski: if its a tagged union then it will be size of largest member + tag size

1576470684
daurnimator
(+ alignment)

1576471272
adamkowalski
Thanks! Speaking of tagged unions, is there something akin to if let in Rust?

1576471287
adamkowalski
I know I can switch on the tag and then do something, but what if I only care about one case

1576472182
andrewrk
what's the floating point operation called, that is "ceil" but always away from zero

1576472208
andrewrk
`0.1 -> 2`  `-0.1 -> -2`

1576472250
daurnimator
andrewrk: towards infinities?

1576472262
andrewrk
yes

1576472312
daurnimator
that's what its called

1576472317
andrewrk
ceil?

1576472326
daurnimator
either "round_towards_infinity" or "round_away_from_zero"

1576472378
daurnimator
"ceil" is usually taken to mean towards positive infinity.

1576472399
daurnimator
i.e. `0.1 -> 2`, `-0.1 -> 0`

1576472418
daurnimator
uh, `0.1 -> 1`

1576472422
daurnimator
I assume you mean that before?

1576472488
andrewrk
I want: 0.1 -> 1,   -0.1 -> -1

1576472495
daurnimator
yep that would be "infinity"

1576472506
andrewrk
what libm function is that

1576472573
daurnimator
there isn't one IIRC. round-towards-infinity isn't defined as an IEEE754 mode

1576472579
data-man
C++ has nearbyint

1576472590
daurnimator
usually the modes are: up, down, zero, near

1576472622
adamkowalski
andrewrk: I'm having an issue with recursion. The compiler says it cannot resolve inferred error set: not fully analyzed yet

1576472649
daurnimator
adamkowalski: recursive functions need to specify their error set

1576472702
adamkowalski
Is there a way to query a function for it's error set? I should just be able to to look at all the functions I call try on and take the union of that right?

1576472866
daurnimator
data-man: in C that's FE_TONEAREST

1576472938
andrewrk
round is so close, but it's off by 0.5

1576472980
daurnimator
andrewrk: do you have a usecase for this?

1576472999
andrewrk
yeah it's for the codegen of comparison operators between ints and floats

1576473053
andrewrk
I'm working on merging the oldest open pull request

1576473119
andrewrk
new language change: comparison operators (<, >, >=, <=, !=, ==) work on any combination of ints and floats, no type errors

1576473158
daurnimator
sounds good. probably has some real funky edge cases!

1576473172
andrewrk
especially with vectors

1576473185
andrewrk
it's sound though, one can always answer the boolean question, regardless of the types

1576473252
adamkowalski
const error_set = @TypeOf(visited_nodes.putNoClobber).ReturnType.ErrorSet;

1576473265
adamkowalski
this complains that field access is not supported

1576473298
adamkowalski
Can I just query a hashmap directly? None of the error sets are listed in the source for hash map so it's hard to get that information haha

1576473346
andrewrk
adamkowalski, give the function an empty error set, and let the compiler tell you the errors you need to put in there

1576473373
andrewrk
this may be able to be improved in the future, inferred error sets of recursive functions

1576473457
adamkowalski
awesome, thanks!

1576473489
daurnimator
andrewrk: `@as(f16, 4096) <= @as(u16, 4095)` ?

1576473492
adamkowalski
Wow that was easy.

1576473529
adamkowalski
andrewrk: you also said in one of your streams that we should start using the async functionality to make sure our recursive functions don't stack overflow right?

1576473542
adamkowalski
Would that also apply to tail recursive functions?

1576473543
andrewrk
daurnimator, that codegens as @as(i17, op1) <= @as(i17, op2)

1576473571
andrewrk
assuming the operands are runtime known

1576473776
daurnimator
andrewrk: okay; similar question: `@as(f32, 33554432) <= @as(u16, 33554431)`

1576473782
daurnimator
uh, u32 on the right

1576473834
andrewrk
I don't see how this question is different

1576473944
daurnimator
andrewrk: because then I follow up with the question: what about `@as(f32, 3.4028234664e1038) <= @as(32, 0xFFFFFFF)`

1576473983
andrewrk
there is a mathematically correct answer to this comparison, which is clearly `false`

1576474020
daurnimator
yes mathematically its fine, but for codegen, wouldn't you need a branch before each comparison to check if the f32 is out of range of the integer before you try and convert it to an `i33`?

1576474106
daurnimator
for a given pair like f32/u32 there are numbers in one range that aren't in the other; and vice versa

1576474137
andrewrk
yes, I don't know how to codegen this without branching

1576474166
daurnimator
It seems like a tricky problem to figure out how to do it with a minimal amount of branching: you'd at least need one for checking too large; one for checking too small; and one for the comparison itself?

1576474186
andrewrk
yeah, I can tell you what it's going to do in stage1: error: TODO implement this

1576474208
daurnimator
though even then you'd probably need to do a check for fractional amounts..... though maybe you can do something clever with subtraction there

1576474235
daurnimator
but yeah: I was curious if you had figured out an elegant way to do it

1576474267
andrewrk
nope, only the realization that according to the type system, it is sound to allow for any (numeric) types

1576474301
andrewrk
which, I would argue, makes the language smaller. since it lets you do something that makes sense to be able to do

1576474328
andrewrk
maybe some hardware has float/int comparison instructions, idk

1576474353
daurnimator
you also can get lost in the realm of ULPs... e.g. when comparing an integer to a float, are you comparing it when the integer is converted to a float?

1576474382
andrewrk
I don't know that TLA

1576474405
daurnimator


1576474432
andrewrk
each value has a mathematical number that it represents; that is what is being compared

1576474459
daurnimator
it doesn't though

1576474468
daurnimator
floating point values essentially represent a range

1576474474
data-man
andrewrk: What do you think about new std.search module? binarySearch, Bitap, etc.

1576474478
data-man
And move to std.search some funcs from std.sort

1576474484
daurnimator
from x-ULP/2 to x+ULP/2

1576474503
andrewrk
daurnimator, I see your point

1576474519
daurnimator
andrewrk: e.g. if I write `@as(f16, 4095)`, then it's == to `@as(f16, 4096)`

1576474557
andrewrk
hmm that's a decent argument in favor of not allowing the comparison

1576474608
daurnimator
you

1576474623
daurnimator
but only for certain values

1576474638
daurnimator
or at least: if it's within 1 ULP.... the answer is "its complicated"

1576474716
daurnimator
Hmm... if you convert both operands to floating point.... is it always correct?

1576474736
daurnimator
I think yes; unless you get an infinity

1576474895
daurnimator
`@as(f16, 4096) <= @as(u16, 4095)` should be: `@as(f16, 4096) <= @as(f16, @as(u16, 4095))` which is: `@as(f16, 4096) <= @as(f16, 4096)` which is `true`

1576477803
daurnimator
andrewrk: ^

1576478649
Snektron
<daurnimator "I can't say I like rust's soluti"> You can already kinda do that with your mixin strategy

1576478706
Snektron
Then you would create a wrapper type every time you want to use a method

1576478740
Snektron
Ex Random(&rng).int(u2)

1576478788
Snektron
Hm, i guess that is a lot more different that i thought

1576482884
merlyndmg
Is it possible to hit this line of code?

1576483049
merlyndmg
I think that might be referring to a C++ enum, e.g. `SomeEnum::SomeEnumValue`

1576483074
merlyndmg
Does zig ever try to parse C++ in that way, or just C?

1576483445
merlyndmg
and how would one test out the remainder of that bunch? i.e. this line

1576483468
merlyndmg
It would be on one of the sides of a && or ||, of course, but what would the expression look like to trigger that line?

1576484094
vexu
merlyndmg: I think that should work if you copy the `.Typdef` switch value from `transType`.

1576499988
bgiannan
what happens to a `for (a_slice) |item, i|` loop if i remove things from the slice in the loop?

1576500224
Snektron
It explodes

1576500312
Snektron
It depends on the implementation and how you are removing it, bgiannan

1576500326
bgiannan
i figured

1576500342
Snektron
Probably wiser to calculate the index yourself

1576500353
bgiannan
right

1576500363
Snektron
Looks less nice but youre guaranteed that it works, and is probably also more readable

1576508349
fengb
Is it kosher to use struct assignment as memcopy?

1576508359
fengb
I know it works right now, but the semantics look pretty weird

1576508419
mq32
fengb, what do you mean?

1576508437
mq32
a = b; instead of memcpy( &b, &a, @sizeOf(@TypeOf(a))

1576508437
mq32
?

1576508444
fengb
Yeah

1576508452
mq32
i think it's the way better option

1576508455
mq32
allows better code generation

1576508459
fengb
It looks like var sorted = mmu.dyn.oam;`

1576508459
mq32
also is more readable

1576508468
fengb
But it doesn't look like a memory copy

1576508491
mq32
every variable assignment is a memcpy

1576508494
fengb
All because oam is a struct with an array (not slice)

1576508521
mq32


1576508530
mq32
i was

1576508539
mq32
this code is much easier to understand than a memcpy

1576508543
fengb
Yes I know, but it feels really weird since most languages don't have value arrays

1576508551
mq32
sadly!

1576508551
fengb
Even though you can convince C to have them by sticking in a struct...

1576508560
fengb
(Why is C so weird?)

1576508578
mq32
because it is old and "i++" was a single instruction back then

1576508614
fengb
I find it amazing that `a[i + 4] = 1` is a single instruction in x86

1576508631
fengb
Dereference, offset, assignment? Totally the same thing ðŸ‘

1576508665
mq32
yep

1576508675
mq32
fun fact

1576508692
mq32
memcpy(&a, &b, X); is a single instruction on x86

1576508729
fengb
I did not know that

1576508772
fengb
Well that expalins the @memcpy intrinsic :P

1576508781
mq32
"rep movsb" =>

1576508820
fengb
Oh I've seen that before. I should actually learn x86

1576508822
fengb
Also lol tripod

1576508957
WendigoJaeger


1576509280
fengb
I wonder how that'd be encoded in microops. And how much more efficient is it compared to a RISC memcpy

1576509633
pixelherodev
x86 != efficiency :P

1576509695
fengb
x86 is amazingly cache efficient

1576510170
lupine


1576510917
mq32
fengb: modern x86 processors are pretty much RISC processors emulating x86 in hardware :D

1576510954
pixelherodev
As I said

1576510956
pixelherodev
!= efficient

1576510972
fengb
Yeah, I mean more of how efficient a single instruction memcpy can be compared with a traditional RISC instruction set

1576511029
mq32
it isn't efficient

1576511032
pixelherodev
^

1576511037
pixelherodev
Right, but in practice, it

1576511038
mq32
rep movsb is slower than manually coded memcpy

1576511040
mq32
MUCH slower

1576511044
pixelherodev
Those are just hidden away

1576511066
fengb
wat, then why use it

1576511074
pixelherodev
Because it's one x86 instruction.

1576511083
pixelherodev
Which means cleaner asm

1576511090
pixelherodev
At least, that's my guess

1576511127
fengb
I think I need a better color to indicate "transparent"

1576511133
mq32
fengb, pretty much nobody uses it :D

1576511146
mq32
pixelherodev, use foof!

1576511184
pixelherodev
foof?

1576511362
mq32
0xFF00FF, also called magenta :D

1576511379
mq32
(i need to spread foof as a replacement for magenta)

1576511403
pixelherodev
mq32, wrong person

1576511406
pixelherodev
:)

1576511420
mq32
oh damn ;D

1576511434
pixelherodev
Freaking compiler segfaults...

1576511437
pixelherodev
Zig, that is - not mine

1576511438
mq32
my brain kinda messed up because of the join message

1576511453
pixelherodev
Gotcha

1576511461
protty
lupine: ever since

1576512097
fengb
Cert expired D:

1576512930
Snektron
<mq32 "memcpy(&a, &b, X); is a single i"> not on any optimizing compiler

1576512964
waleee-cl
Is the static builds from master on ziglang.org  compiled in debug mode?

1576513040
andrewrk
Release

1576513128
waleee-cl
Downloaded the latest and tried (and noticed that that was the case)

1576513196
pixelherodev
Is a segfault in ir_render_br via a llvm::BasicBlock::getContext call a known issue?

1576513362
andrewrk
pixelherodev, no

1576513375
mq32
Snektron: as i said, it's not efficient in speed, but only in size :D

1576513582
pixelherodev
Yay

1576513593
pixelherodev
I've run into this a number of times I think and just worked around it

1576513600
pixelherodev
But I'm holding off on pulling Zig until 0.6

1576513659
Cadey
is there a maybe type in the standard lib?

1576513679
Snektron
?<type>

1576513688
Cadey
how about an either?

1576513697
pixelherodev
You mean a union?

1576513714
Cadey
can you return a union in a comptime function that returns a type?

1576513720
pixelherodev
A union is a type, so yes

1576513722
Snektron
sure

1576513745
Cadey
can you define methods on a union?

1576513751
pixelherodev
99% sure

1576513754
Snektron
yes

1576513763
andrewrk
yes you can, and you probably want to give your union a tag

1576513763
pixelherodev
^

1576513774
fengb
Yes, you can also define methods on an enum if you want

1576513775
andrewrk


1576513889
leeward
I get an error when I try to run this example:

1576513906
fengb
andrewrk: you mentioned reworking how format is implemented. I believe generators will simplify it tremendously

1576513908
leeward
main.zig:8:19: error: expected token ')', found 'StringLiteral'

1576513925
fengb
Naturally embedding a context and iterator

1576513926
leeward
Am I doing something wrong? I thought the examples were tested.

1576513937
andrewrk
fengb, yes I agree

1576514017
andrewrk
leeward, they are tested, can you post your source?

1576514083
leeward


1576514083
leeward
3D+c.printf(c%22hello%5Cn%22)%3B%0A%7D%0A%0A'),l:'5',n:'0',o:'Zig+source+%231',t:'0')),k:41.28191675410983,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:z050,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'),fontScale:14,j:1,lang:zig,libs:!(),options:'',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,st

1576514083
leeward
artColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'zig+0.5.0+(Editor+%231,+Compiler+%231)+Zig',t:'0')),k:25.384749912556842,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,wrap:'1'),l:'5',n:'0',o:'%231+with+zig+0.5.0',t:'0')),k:33.33333333333333,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4

1576514087
leeward
Holy crap

1576514092
leeward
sorry, didn't realize that would be that long

1576514102
leeward


1576514142
andrewrk
your source does not match the example code you linked

1576514159
andrewrk
here it is fixed:

1576514223
scientes
how does it convert that to a C string?

1576514269
scientes
cause printf needs it null terminated

1576514277
leeward
Gah, thanks. I think I crossed versions.

1576514292
andrewrk
scientes,

1576514337
andrewrk
scientes, btw I took your proposal to make comparisons work for all integer types, about to push to master

1576514344
scientes
cool

1576514346
fengb
I'm actually really glad c"" is gone. I had thought that it returned c pointers, and inferred [*c] pointers were null terminated pointers

1576514408
Snektron
hm

1576514420
Snektron
i get segfaults when allocating too much stack

1576514509
leeward
While I'm on the subject, is there a canonical way to implement an opaque data structure in Zig? I've got a C library that I'd like to replace, and it's built around passing opaque struct pointers around.

1576514527
Snektron
@OpaqueType()

1576514529
andrewrk
Snektron, zig doesn't yet have the ability to detect stack usage at compile-time and request more at startup, but that is planned

1576514534
leeward
Snektron: Thanks!

1576514559
scientes
const slice: [:0]const u8 = "hello";

1576514561
andrewrk
Snektron, one problem I haven't quite worked out is what to do when we know we need a certain amount of stack space, but zig is not in charge of calling main()

1576514561
scientes
ahh that is really clever

1576514571
scientes
and it makes some of the stdlib work better on linux

1576514586
pixelherodev
This is... weird

1576514611
pixelherodev
That segfault I mentioned?

1576514616
pixelherodev
Returning an error seems to trigger it...

1576514625
pixelherodev
Rather, under specific conditions,

1576514629
fengb
andrewrk: I think this generator style is the "least bad" right now with async:

1576514656
pixelherodev
Or, worse: any

1576514660
fengb
It works and allows arbitrary yields along the entire stack

1576514660
pixelherodev
Even @panic

1576514661
leeward
Snektron: So if I want to export an opaque type in a generated header, I'll just "export const foo = @OpaqueType();"?

1576514667
scientes
const slice: [:0]const u8 = "hello";

1576514679
scientes
this also allows using null-terminated style with --release-small

1576514688
Snektron
andrewrk, did you consider to add it to TypeInfo? if you still want to remove recursion, you could provide an @typeInfo(main).Fn.required_stack_space

1576514706
Snektron
leeward, i think you're only allowed pointers to opaque types

1576514721
leeward
Snektron: Oh, right, there should be a * in there.

1576514733
leeward
er, an &?

1576514733
Snektron
oh wait

1576514743
Snektron


1576514829
Snektron
even with recursion, that value could be ?usize for required stack space

1576514855
andrewrk
Snektron, it's not really part of the type; 2 functions with the same type could have different stack requirements

1576514891
Snektron
depending on the invocation, yeah...

1576514894
fengb
Could we annotate function pointers with max stack size?

1576514904
Snektron
Thats another thing

1576514909
fengb
(Should we?)

1576514914
leeward
Snektron: Yeah, but that doesn't talk about generating header files. I need my library's users to have a name for the opaque type.

1576514922
andrewrk
fengb, I think that will be a necessary component of eliminating stack overflow at compile time

1576514969
Snektron
leeward, i think those OpaqueType's export just like normal types

1576515022
Snektron
andrewrk, you could always have @requiredStackSpace(expr)

1576515048
fengb
The only caveat to OpaqueTypes is that they can only exist as pointers and you can't dereference them, similar to forward declared structs in C

1576515068
Snektron
thats alright when you export them

1576515269
leeward
Snektron: Trying it

1576515297
Snektron
btw, are promises still a thing?

1576515312
Snektron
Because the documentation still lists them under TypeInfo

1576515378
Snektron


1576515417
leeward
Hey it worked! Nifty.

1576515484
leeward
Hmm, ok, so here's the C code I want to generate: "typedef struct foo foo_t"

1576515503
leeward
Instead, it's generating "struct foo_t;"

1576515540
leeward
Is this a thing I can do, and if not, will it ever be?

1576515693
leeward
Also, I'm guessing that my C API needs to have a bunch of functions that accept the opaque pointer type and @ptrCast it to the thing it's supposed to be, then call the function that actually does the thing with the pointer.

1576515784
leeward
A trivial example:

1576515809
leeward


1576515888
leeward
Is that a reasonable model for a library in Zig that's called by C?

1576515947
fengb
Seems like you can just export do_thing directly

1576516065
leeward
Well, there's a bug: "zig build-lib src/main.zig" generates a header with this in it: `struct ThingHolder(i8,8);`

1576516067
andrewrk
Snektron, fixed:

1576516094
Snektron
great, thanks

1576516120
leeward
But point taken. You may be right.

1576516144
fengb
leeward: oops yeah I see it. Probably a bug :P

1576516162
pixelherodev
Zig had promises?

1576516173
fengb
They were the old async stuff

1576516189
pixelherodev
Ah

1576516189
andrewrk
they were basically `anyframe`

1576516193
pixelherodev
Gotcha

1576516227
leeward
fengb: Hmm, even if I alias my comptime-instantiated type, it still generates that line. Definitely a bug. Time to search the bug db.

1576516234
Snektron
with more compile errors

1576516246
pixelherodev
I think any branch in a nested-while loop fails

1576516257
pixelherodev
Though there might be more to it, I need to nail down the minimal reproducing test case

1576516366
fengb
andrewrk:

1576516517
pixelherodev
I'd argue it should parse the signature and only the signature

1576516543
pixelherodev
So you'd be able to determine that it returns Foo and takes no parameters, but it wouldn't evaluate the function itself

1576516545
andrewrk
fengb, I think @typeInfo is going to stop having declarations in it

1576516580
pixelherodev
If you only analyze the type of a function without calling it, there's no need to parse the function, and thus it shouldn't be parsed

1576516620
andrewrk
something as drastic as removing decls isn't necessarily needed though. now that we have lazy values, they can be used to tackle this problem

1576516696
leeward
I don't see it in there. Filed:

1576516813
leeward
Incidentally, am I right in assuming that I just don't have permission to add labels like `bug` to issues I raise and PRs I submit? I've seen other people add tags to my stuff, but I don't see an obvious way to do it myself.

1576516976
shakesoda
leeward: yeah, github restricts that to people with write access to the repo etc

1576517017
shakesoda
i think there might be a second permission level for it also, but not sure

1576517036
leeward
shakesoda: Excellent. Just wanted to make sure I wasn't creating more extra work for people than I needed to.

1576517204
andrewrk
don't worry, the effort of labeling issues is nothing compared to the effort of actually solving the problem

1576517212
leeward
Hmm, getting a link error with that printf example from before: lld: error: unable to find library -lC

1576517220
andrewrk
if only zig could be improved, by futzing with labels all day :P

1576517249
shakesoda
andrewrk: wouldn't that be a convenient alternate reality, lol

1576517268
andrewrk
leeward, your `C` should be `c`

1576517269
shakesoda
as a maintainer of various things i always rather preferred doing them myself anyway

1576517281
leeward
Of course it should.

1576517340
leeward
andrewrk: thanks

1576517365
leeward
shakesoda: I understand that. Having no label is better than having wrong labels.

1576517721
fengb
I thought about lazy values, but that could lead to non deterministic declarations

1576517745
fengb
e.g.  running type info later can yield different results

1576518149
andrewrk
that's a good point

1576518470
andrewrk
fengb, a non-disruptive small improvement would be to make lazy all the declarations though. so if you never accessed the decls field then none of them get poked

1576518483
andrewrk
and accessing decls field would mean all get poked

1576518508
fengb
Ah I see. Thatâ€™d make sense

1576518534
fengb
That should fix it for this formatting issue. Thanks

1576518716
andrewrk
alright, oldest "ball-is-in-my-court" pull request is now in November

1576518863
dimenus
andrewrk: how long have you been working on zig fulltime now? a year?

1576518950
andrewrk
since 2018 Jun 07. there was another stretch of time before that, adding up to about 1 year as well

1576518978
dimenus
still enjoying it?

1576518990
andrewrk
yes

1576519010
andrewrk
impatient for async I/O & self-hosted to be further along though

1576519076
leeward
I'm having trouble linking a simple C program to a library written in Zig. The Zig source code is from mathtest.zig in

1576519134
andrewrk
leeward, I think you want --bundle-compiler-rt

1576519183
leeward
$ zig build-lib --bundle-compiler-rt src/add.zig

1576519192
leeward
andrewrk: like that? If so, no change.

1576519240
leeward
Oh, if I link to libadd.a it's better.

1576519241
leeward
:P

1576519330
andrewrk
leeward, you could also do -fno-stack-check

1576519518
leeward
andrewrk: Ooh, that might be preferable.

1576519977
mq32
can somebody explain why the "kernel" step isn't executed when doing "zig build run"?

1576519978
mq32


1576519995
mq32
i'd expect that it is built when running qemu_step

1576520150
andrewrk
mq32, that looks right to me

1576520166
andrewrk
this is where it would be nice to have build_runner.zig support a graph visualization option

1576520198
andrewrk
there's a better way to set this up though mq32

1576520271
mq32
okay, please share your wisdom with me :

1576520334
mq32
when doing "zig build run" with the above script, no "bin" folder is created

1576520341
andrewrk
addSystemCommand() with the first args, but not the path to your artifact output path, then use qemu_step.addArtifactArg(kernel)

1576520404
andrewrk
then you don't need the explicit dependOn() and the build system is aware of where the kernel gets built to etc

1576520430
mq32
tanks!

1576520436
andrewrk
I think that makes it run from the install dir as well, but I'd have to double check

1576520476
andrewrk
mq32, yes, when you make it aware that it's the path of another artifact, it gets smarter:

1576520551
Snektron
does zig have any way to write large numbers?

1576520559
andrewrk
std.math.big.Int ?

1576520562
Snektron
like 1_000_000 in python/rust or 1'000'000 in c++

1576520570
mq32
:)

1576520594
andrewrk
Snektron,

1576520600
Snektron
i realize "writing large numbers" is quite ambiguous

1576520714
pixelherodev
This is odd

1576520742
pixelherodev
If I don't catch the error and just exit the function calling the function for which codegen is failing, I get a completely different segfault

1576520761
Snektron
hmm thats too bad, andrewrk

1576520880
mq32
andrewrk, similar topic than number separators: would it be possible and reasonable to make zig fmt allow some alignments in declarations?

1576520901
mq32
if one is writing matrices or similar, it's really hard to read them after a zig fmt removes all white space

1576520929
andrewrk


1576520945
andrewrk
matrices? zig fmt already aligns arrays

1576520990
mq32
huh? how come i never noticed tha?

1576520996
pixelherodev
... or not. I somehow got an entirely different error without changing the code but at least I'm getting this one consistently now?

1576521014
mq32
i can swear that i haven't seen that working

1576521227
andrewrk
pixelherodev, if you're trying to debug a crash in llvm, I recommend a debug build

1576521241
andrewrk
there's probably a useful assert that you're not hitting otherwise

1576521568
pixelherodev
... I don't think I can afford to that anytime soon

1576521613
pixelherodev
It takes a lot of hours and battery life, and I'm w/o a charger for the rest of the day (I use a spare battery instead of a charger because it's easier to carry)

1576521679
pixelherodev
Hmm

1576521685
pixelherodev
I think I might be running into #3029 actually

1576521689
pixelherodev
The stack traces are very very similar

1576521704
pixelherodev
But it's not a simple inline for this time...

1576521757
pixelherodev
Huh

1576521761
pixelherodev
Found a workaround for this

1576521767
pixelherodev
It only happens when that return is inside of a while

1576521787
pixelherodev
Using a boolean and returning outside the loop works

1576521810
pixelherodev
I think my original suspicious of it being a nested loop issue was right

1576521819
pixelherodev
I think the basic block in question is one of the conditional blocks for the innermost loop

1576521833
pixelherodev
Furthermore, `break` in the loop causes the same issue, so it's not a return

1576521873
pixelherodev
And it also only triggers

1576521888
pixelherodev
This is really odd

1576521904
pixelherodev
I have `if (std.mem.eql) {...} else {return error / break / etc}` -> panic

1576521922
pixelherodev
s/panic/segfault

1576521926
pixelherodev
With `else {failed = true;} if (failed) {break / return error / etc` it works fine

1576521951
pixelherodev
I think Zig is generating invalid IR

1576521992
pixelherodev
Going to use `--verbose-llvm-ir` and see if I can figure this out

1576522776
pixelherodev
andrewrk, correct me if I'm wrong, but returning an error should not generate `ret void` in the IR?

1576522847
pixelherodev
Ah, was looking in the wrong place

1576522989
pixelherodev
Gah

1576522995
pixelherodev
That error table is huge

1576523012
pixelherodev
almost 5000 characters :(

1576523238
andrewrk
if you don't use @errorName then it doesn't generate one

1576523251
andrewrk
also there is optimization opportunity with error sets, not taken advantage of

1576523288
pixelherodev
Switching to @panic made it far easier to trace

1576523305
pixelherodev
Since it's just a global with the string, a global for the slice containing that string, and the call to panic using the second global

1576523415
pixelherodev
There a LLVM cli program to validate a module?

1576523675
andrewrk
probably opt

1576523699
pixelherodev
... huh. I split out the breaking part into its own function to make the IR easier to analyze

1576523704
pixelherodev
And the segfault vanished

1576523717
andrewrk
it can sometimes be an in-memory-only problem

1576523750
pixelherodev
No, I mean the normal compiler worked

1576523893
pixelherodev
Ah! Found the IR problem!

1576523900
pixelherodev
`br i1 %5567, label %ErrRetReturn1276, <null operand!>, !dbg !17228`

1576523905
pixelherodev
`<null operand!>`

1576524050
pixelherodev
... I think it might be an error merging error sets?

1576524183
pixelherodev
Weirdly, the error isn't even in the IR corresponding to the changed code

1576524188
pixelherodev
It's in the unchanged then branch

1576524260
pixelherodev
huh. And removing the error return from there causes an entirely different segfault which occurs before the codegen stage :(

1576524284
pixelherodev
weird. Removing the entire then branch causes the same thing.

1576524296
pixelherodev
Some integer overflow

1576525233
pixelherodev
huh. A grep for `null operand` gives nothing in the zig src

1576525239
pixelherodev
Am I to assume that's from LLVM?

1576525819
pixelherodev
... I have no clue how to really debug this...

1576525859
pixelherodev
Or not

1576525867
pixelherodev
Just remembered metadata exists :D

1576526148
pixelherodev
Okay, so this seems to occur in a very limited set of circumstances: has to be a conditional inside of a nested loop with two different branches which either never return (e.g. panic) or return immediately

1576526178
pixelherodev
There's an entirely

1576526211
pixelherodev
Importantly, the second bug only occurs if the

1576526256
pixelherodev
So, correction: the second bug doesn't occur if only the else branch is removed

1576526572
pixelherodev
Okay, here's another weird bit

1576526581
andrewrk
lupine, you're assuming that finding bugs is the bottleneck. we have 247 open bug reports

1576526587
pixelherodev
With `if (a) {} else { branch }`, segfault

1576526596
pixelherodev
With `if (a) {} else if (!a) {branch }`, compiles fine

1576526604
lupine
hehe

1576526654
pixelherodev
There a way to specify that e.g. past contributors can set labels in issues they open?

1576526697
andrewrk
there is not

1576526722
pixelherodev
Or possibly create a team for new contributors that gives them very limited permissions - such as setting labels?

1576526724
pixelherodev
Eh

1576526728
pixelherodev
That's probably more work

1576526735
pixelherodev
then just setting the labels manually :P

1576527106
pixelherodev
Yeah, this isn't just a hyper-specific bug

1576527128
pixelherodev
Plenty of other places I'm switching from debug.warnings to returning errors that are running into the exact same thing

1576527221
TheLemonMan
pixelherodev, are you trying to narrow down a bug in the LLVM IR?

1576527226
pixelherodev
No

1576527226
pixelherodev
Codegen

1576527232
pixelherodev
Zig compiler is producing invalid IR

1576527276
pixelherodev
ziglang/zig#3925

1576527289
TheLemonMan
hmm, are you using an inline for?

1576527302
pixelherodev
Nope

1576527308
pixelherodev
I know which issue you're referring to

1576527312
pixelherodev
That was my first thought as well

1576527316
pixelherodev
I suspect it might be the same issue though

1576527330
pixelherodev
I'll look into the inline for tonight, but it's quite possibly the same issue

1576527364
pixelherodev
An easy way to test: `zig build-exe ... --verbose-llvm-ir` 2>temp ; opt temp; rm temp`

1576527379
pixelherodev
Pass in an inline for to that

1576527398
pixelherodev
If you get a message about "expected value in address space, received <null operand!>" it's probably the same issue

1576527426
pixelherodev
It gets more interesting - returning an error from the if statement works fine

1576527443
pixelherodev
Adding a non-branching else condition works

1576527444
TheLemonMan
oh, so the error comes from opt?

1576527447
pixelherodev
No

1576527450
pixelherodev
`opt` verifies the LLVM IR

1576527464
pixelherodev
And detects that it's not valid

1576527485
pixelherodev
Adding a branch

1576527488
pixelherodev
The else still generates correctly

1576527489
TheLemonMan
...so it's `opt` that raises the error

1576527498
pixelherodev
No.

1576527503
pixelherodev
zig will still segfault there.

1576527514
pixelherodev
Because it's generating invalid IR and then trying to produce valid asm from it

1576527526
pixelherodev
opt just tells you what Zig is doing wrong

1576527530
pixelherodev
Well

1576527534
pixelherodev
Okay I see what you meant

1576527544
pixelherodev
The `opt` is what causes the error message to print, yes

1576527557
pixelherodev
Anyways, I think I figured out the specific logic that's breaking it

1576527617
pixelherodev
Adding in a branch in the else shifts the target of the if branch - at least

1576527660
pixelherodev
But that reference hasn't been updated

1576527662
pixelherodev
And is thus null

1576527724
pixelherodev
Branch in the if doesn't cause the same problem, because that's calculated before its target is

1576528196
leeward
How does allowzero interact with optional pointers?

1576528239
leeward
Should `var p: ?*allowzero u8 = undefined` be legal?

1576528765
TheLemonMan
yup, it's codegen'd as a *u8 and a i1 to store whether it's null or not

1576528836
leeward
So the thing in

1576529328
TheLemonMan
that'd be unsound if it were true, don't you agree?

1576529506
leeward
I do. I'm just pointing out a bug in the documentation.

1576529543
leeward
Though I think there's a bug with coercion. If I try to coerce a ?*u32 to a ?*allowzero u32, I get a segfault.

1576529574
leeward
I would expect it to either succeed or fail to compile.

1576529632
TheLemonMan
do you have a minimal test case?

1576529636
leeward


1576533724
protty
anyone know why the test cases from

1576533847
fengb


1576534077
pixelherodev
Okay, so uh - with a file opened via openWrite, is there an equivalent to fflush I need to use?

1576534155
pixelherodev
Never mind.

1576534165
pixelherodev
I was using the wrong file path :P

1576534195
TheLemonMan
leeward, good catch, you've found a simple yet gnarly-to-fix bug :)

1576534300
leeward
TheLemonMan: fun. Should I file it?

1576534330
protty34
fengb: looks like its always for single-threaded release-fast but cant find the reason of failure. All tests (excluding [free|net|open]bsd) work fine locally through qemu & wine

1576534359
TheLemonMan
leeward, sure thing, I have a one-line fix ready but I'm not 100% sure it's the right thing to doâ„¢ atm

1576534507
pixelherodev
What bug is this?

1576534530
pixelherodev
Ah

1576534531
TheLemonMan
protty, the windows build is slightly more informative as it exits with EXCEPTION_ACCESS_VIOLATION

1576534626
leeward
TheLemonMan:

1576535466
frmdstryr
protty34: Could you benchmark

1576535631
protty
TheLemonMan: you're right, its definitely segfaulting, but looks like it does so without outputting the test binary in zig-cache + the core dump backtrace in gdb is stripped..

1576535673
protty
frmdstryr: sure, I can try it out

1576536239
daurnimator
andrewrk: could you quickly verify

1576536625
TheLemonMan
protty, you're hitting a compiler bug, yay

1576536848
TheLemonMan
protty, and I have a workaround for you!

1576536867
Snektron
i hit one in gcc the other day

1576536870
protty
uh oh / yay

1576536907
TheLemonMan
protty, make sure your `Held` structure is never zero-sized, IOW make `lock_init` always `false`

1576536940
protty
frmdstryr:

1576536987
TheLemonMan
it's just another form of #3497, another silly yet nasty bug

1576537218
protty
ah ok. Its in the single threaded Mutex which is already in master. are other test cases hitting this as well?

1576537229
frmdstryr
protty: Thanks!

1576537682
fengb
`Easy peasy.` followed by some arcane voodoo encantation

1576538087
TheLemonMan
aand I also have a fix

1576538934
andrewrk
hello TheLemonMan

1576538941
andrewrk
how are things in the citrus world

1576539416
TheLemonMan
life's wildly swinging between easy peasy lemon squeezy and difficult difficult lemon difficult

1576539435
TheLemonMan
other than that I'm happy to unwind a bit by fixing some bug here and there

1576539508
andrewrk
haha

1576539566
andrewrk
you might be interested in this branch, if I can get it to work:

1576539606
andrewrk
it gets rid of the mem_slot thing, making all allocas the same, and gets rid of the differences in result locations between comptime code and non-comptime code

1576539653
andrewrk
lots of regressions to fix before it can be merged tho

1576539657
TheLemonMan
oh that sounds cool

1576539683
TheLemonMan
less tests -> less regressions to fix -> faster turnaround!

1576539690
andrewrk
lol

1576539777
andrewrk
the next major blocker for self-hosted is async I/O in std. the next major blocker for that is getting std.fmt.format to work as an iterator rather than using a callback function, so that std.fmt.format doesn't ever have to be async

1576539801
andrewrk
so that we can make std.os.write participate in async I/O

1576540058
TheLemonMan
aand I'm done for today, gn everybody!

1576540308
andrewrk
good night

