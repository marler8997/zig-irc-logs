1569456305
mikdusan
maybe add this to ci script at beginning: system_profiler SPHardwareDataType

1569458476
_Vi
What does man in Zig, when in C one passes a function pointer and `void* usrarg`? I.e. how callbacks work in Zig?

1569458606
_Vi
Shall it be like in C (passing some `usize` or equivalent value down) or like in Rust (making  the entire thing genetic, accepting type T for callback function argument type)?

1569458623
_Vi
*generic

1569459567
_Vi
Looks like generic approach (`fn do_things(usrdata: var, callback: fn(usrdata: @typeOf(usrdata), x))`) works.

1569459857
_Vi
Where is this "var" in `fn(arg: var)` context formally described?

1569459892
_Vi
I see it used in snippets in the documentation, but not explained.

1569466125
andrewrk
_Vi, good point, I don't think it's formally documented

1569466135
andrewrk
it is stable though

1569466252
andrewrk
mikdusan, done

1569466582
mikdusan
azure why don't you let me view the beginning of an in-progress log? (yes i clocked off follow-tail)

1569466668
andrewrk
I missed it too

1569466683
andrewrk
it shows the whole log after it's done

1569466685
mikdusan
i'm just going to bet 4GB VM

1569466688
andrewrk
agreed

1569466705
andrewrk
I'll leave this diagnostic on for now

1569467488
andrewrk
maybe it's some kind of vm overcommit thing though

1569468920
andrewrk
ok I apologize for this but I'm going to `mv std/ lib/` now

1569469044
mikdusan
so WORKTREE/lib/ == INSTALL/lib/zig/

1569469061
andrewrk
yes

1569469109
andrewrk
--override-std-dir gets deleted. it's just --override-lib-dir now

1569469119
mikdusan
Memory: 12 GB

1569469121
mikdusan
what

1569469128
mikdusan
overcommit. alert. lol

1569469153
andrewrk
hmm I do think this is evidence in favor of my hypothesis

1569469539
mikdusan
i think only real info there is #cpu_packages, #cpu_clock #cpu_cache_sizes; my guess: IntelÂ® XeonÂ® Processor W3680 MacPro5,1 (2010)

1569471317
andrewrk
damn, cmake doesn't have a way to add a custom target to `make install`. that's a pretty glaring deficiency

1569479272
andrewrk
Sahnvour, I think you will appreciate the new -DZIG_SKIP_INSTALL_LIB_FILES option

1569479305
andrewrk
in summary: enable the option and no lib files are copied on `make`. rm -rf your lib/ folder in your build directory and zig will pick up the one from the source directory

1569485241
marijnfs__
no zig update:(

1569485244
marijnfs__
working on something cool?

1569491780
_Vi
Is taking `var`-typed argument "x" equivalent to taking `comptime xType : type, x : xType` where xType auto-fills with @typeOf(x) at call site?

1569491867
mq32
_Vi: yes

1569492145
_Vi
How string is Zig's `translate-c`? Can it, for example, translate OpenSSL?

1569492148
_Vi
*strong

1569492341
ceymard
I think I'm onto something for the completion

1569494303
ceymard
say, do functions have properties ?

1569494309
ceymard
like slices and arrays have .len

1569496574
mq32
ceymard, afaik noot

1569496738
mq32
_Vi, it can translate (in theory) everything that is not "macro magic"

1569496749
mq32
so simple macros will work, but more complex macros will not

1569497692
_Vi
mq32, Can it just expand macro magic and translate the result?

1569497837
mq32
nah, that wouldn't work

1569497856
mq32
because macros emit C code and are not "inline functions"

1569499719
fengb
marijnfs__: andrewrk is preparing the scheduled release so all documentation all day

1569501077
_Vi
Why `fn something()void{}`, not `const something = fn() void {}`?

1569501129
fengb
Thereâ€™s an accepted proposal to change that

1569501140
mq32
_Vi, because andrew hadn't time to implement #1717 yet

1569501140
mq32


1569501224
_Vi
Maybe `struct qqq{};` can be a sugar for `const qqq = struct{};` then? (and so on for enums and unions).

1569501273
mq32
nah, with #1717 even the support for "fn foo() { }" will be dropped

1569501301
_Vi
Does handling of leading `fn`, `struct`, `union` and `enum` complicates parsing or language grammar?

1569501367
_Vi
I think immediately assigning newly defined something to a const is popular enough case to grant some syntax sugar.

1569501431
_Vi
Or does `var self_modifying_function = fn () void { ... }` have real meaning, so `const` or `var` choice should always be explicit?

1569501479
_Vi
If all types are immutable and cannot ever be `var`, then specifying `const`keyword every time seems redundant.

1569501661
_Vi
Otherwise Zig code would be recognized from afar by constant usage of `const`.

1569502423
mq32
const usage = const;

1569502476
fengb
We could rename all keywords to variations of const!

1569502537
rifkik
I have a question, about #1717

1569502546
rifkik
Does it make it better?

1569502555
_Vi
If `const` is intended to be used all the time then it should be abbreviated even more:  `cnst` or even `c`.

1569502561
rifkik
if it does, then why?

1569502580
fengb
More consistent grammar and a way to do anon functions

1569502586
_Vi
rifkik, 1717 brings uniformity between functions and other items.

1569502601
fengb
Like assigning a function directly into struct fields isnâ€™t possible atm

1569502601
rifkik
Ah

1569502606
rifkik
I isee

1569502632
rifkik
And it's planned for 0.6?

1569502642
fengb
Looks like it

1569502654
_Vi
rifkik, Don't trust Github issue milestones, they tend to be pushed all the time.

1569502774
rifkik
Oh, Okay

1569503054
ceymard
when displaying the symbols of a zig file, what would you want to see ? anything declared (const / var / fn), even in function scopes ? or everything minus function variables ?

1569503106
ceymard
also, would you rather see <just the name of the symbol>, or <parent>.<parent>.symbol in the list that is displayed ?

1569503117
ceymard
(I'm talking about editing in vscode)

1569504223
mq32
ceymard, good question

1569504230
mq32
probably stuff filtered by imports

1569504240
mq32
so if i type "std. " only the stuff that is contained in stf

1569504287
mq32
rifkik: anonymous functions are a great gain of #1717: "sortSliceBy(mySlice, fn(a:*Item,b*Item) bool { return a.value < b.value; });"

1569505461
ceymard
mq32: this is completion stuff

1569505470
ceymard
I'm talking about "all file symbols"

1569505478
ceymard
which I already have working (because it's a lot easier)

1569505507
ceymard
completion is a WIP

1569505513
ceymard
I only have completion working at the scope level

1569505525
ceymard
since I'm using a custom-built parser, I have to actually process types

1569505537
ceymard
which I don't intend on doing very "seriously" at first

1569505553
ceymard
so that we could complete some stuff albeit not completely correctly

1569505592
mq32
ceymard, yeah i know. but i think you can filter for const foo = @import("bla"); and then search those files as well

1569505596
mq32
that would be helpful

1569505602
ceymard
that's planned

1569505611
ceymard
since this is exactly what I needed in the first place :)

1569505811
ceymard
I also plan to handle somewhat @cImport

1569505817
ceymard
since I can run zig cc

1569505822
ceymard
zig cimport sorry

1569505842
ceymard
that and the builtin types also

1569509119
andrewrk
marijnfs__, I am planning on streaming today

1569509768
marijnfs__
andrewrk: awesome

1569509800
andrewrk
not sure the topic yet

1569512963
ceymard
mq32: I'm starting to get auto complete from imports, but it's still quite raw

1569512971
ceymard
well from variables too for that matter

1569512990
ceymard
but there's still some to be done before actually calling this an "alpha"

1569513012
ceymard
the progress is good though

1569513555
andrewrk
I think the stream topic today will be status update & demo of how to debug non-native architectures with qemu

1569513909
Tetralux
It's worth knowing that qemu seems to work differently on Windows.

1569513949
Tetralux
I can't seem to just `qemu-system-riscv64 program` for example.

1569513994
andrewrk
I don't think usermode qemu is available on windows, just whole system emulation

1569514015
Tetralux
Ugh..

1569514018
andrewrk


1569514019
Tetralux
That's annoying.

1569514030
andrewrk
well it makes sense. usermode qemu is very linux specific

1569514106
Tetralux
That's not an OS limitation though is it@?

1569514147
andrewrk
it might be

1569514173
andrewrk
linux has some neat syscalls that let you do tricks like usermode qemu

1569514204
TheLemonMan
usermode emulation means that the syscalls are just relayed to the host kernel, that's a bit hard to do on windows

1569514320
Tetralux
Hmmm.

1569514452
Tetralux
Sounds like a wine-like thing is required.

1569514723
TheLemonMan
a liquor?

1569514744
Tetralux
That took me second.

1569514788
_Vi
What is code style for enum variants? E.g. in std/io.zig I see: `pub const Mode = enum { blocking, evented};      pub const Packing = enum {Byte,Bit};`

1569514849
andrewrk
_Vi, being decided:

1569514895
andrewrk
there is a semantic component to this decision:

1569515088
mikdusan
is combining case(s) with `else` in a switch supposed to work? `switch (thing) { .one, else => {...} }`

1569515195
andrewrk
mikdusan, nope

1569515610
_Vi
Is there some mark for unimplemented code in Zig? It should be like `unreachable`, but never cause UB in release mode, only safe abort or panic. May fail compilation although.

1569515635
andrewrk
@panic("unimplemented")

1569515665
_Vi
OK, but long-ish. Can there be `@todo()`?

1569515671
andrewrk
no

1569515679
andrewrk
we have to keep the language small

1569515715
andrewrk
zig code will never be elegant

1569515734
andrewrk
but can be maintainable and correct

1569515765
Tetralux
I'm always slightly uncomfortable when you say "never be elegant" xD

1569515771
Tetralux
Always sounds like an anti-pattern.

1569515808
_Vi
What is elegance in context of programming languages?

1569515853
andrewrk
_Vi, appealing in a visual sense

1569515884
andrewrk
terse

1569515917
TheLemonMan
yeah, `usingnamespace` is such a eyesore

1569515959
andrewrk
I tweaked that on purpose to get people to use it only when it's semantically needed

1569515982
andrewrk
actually pretty happy with how that ended up

1569516010
andrewrk
just wait for thisfileisautotranslatedfromc

1569516037
Tetralux
So long as that has underscores x)

1569516042
TheLemonMan
hah, you're taking the whole thing a bit too far IMO

1569516077
TheLemonMan
I love me some usingnamespace + struct for grouping stuff

1569516097
andrewrk
yeah that's a good use case

1569516108
andrewrk
organizing APIs is the intended use of it

1569516145
TheLemonMan
I can't see any other way to (ab)use it

1569516227
dimenus
man, ninja + llvm = madness

1569516235
dimenus
maxing out 16GB RAM and 16GB swap

1569516242
andrewrk
TheLemonMan, usingnamespace @import("third_party_package_1"); usingnamespace @import("third_party_package_2");

1569516258
andrewrk
can cause a compile error if third_party_package_1 gets an update and adds a function

1569516292
andrewrk
even if that doesn't happen it's now more annoying to read code because any given symbol could come from 2 places

1569516324
TheLemonMan
ehh, annoying to type names won't stop people from doing that

1569516365
andrewrk
I'm not so sure about that. I've noticed many people use `var` instead of `const` even when the latter would be better

1569516372
fengb
But it does look less idiomatic so beginners hopefully do a double take

1569516389
mikdusan
with great power comes great responsibility

1569516518
Tetralux
andrewrk: Random thought, why did you go with qualifier-oriented declaration syntax and not something else - like name-oriented syntax, for example.

1569516591
andrewrk
I started with an existing language and morphed it into zig, I didn't invent zig from scratch

1569516597
andrewrk
metaphorically

1569516616
Tetralux
Oh interesting.

1569516627
andrewrk
zig is C with the problems fixed. one of the problems of C is fixed by rust/go which is the var decl syntax

1569516671
Tetralux
Did you essentially just say "Rust/go decl syntax is easier to read than C's - I'll use that" or did you evaluate several different kinds?

1569516709
andrewrk
the former, but not easier to read, it actually solves a parsing ambiguity problem

1569516719
andrewrk
I mean that also makes it easier to read, obviously

1569516737
companion_cube
also goes better with optional type inference

1569516785
andrewrk
yeah. zig benefitted a lot from copying existing good patterns of modern languages, without me fully understanding why (until years of work later)

1569516799
Tetralux
companion_cube: Can you show an example of that?

1569516815
companion_cube
`var x = 42;`  vs `var x : i32 = 42;`

1569516825
companion_cube
the structure is the same, you just have an optional type annotation

1569516842
companion_cube
(same in rust ofc)

1569516849
Tetralux
companion_cube: I see; named-oriented does that better IMO though.

1569516849
companion_cube
contrast with the super weird `auto` of C++

1569516862
andrewrk
same goes with LLVM. it's "training wheels". the backend I would have written 4 years ago if I didn't use LLVM would have been poor compared to if I started such a project today

1569516864
Tetralux
x := 42; x : i32 = 42;

1569516870
companion_cube
ughhhhhhhhh

1569516877
Tetralux
(note the sigils are the same)

1569516882
companion_cube
I hate this so much

1569516891
companion_cube
so easy to miss the declaration of a new variable

1569516896
fengb
Thereâ€™s more parsing ambiguity

1569516908
companion_cube
also it doesn't work with patterns, or makes parsing much harder

1569516917
companion_cube
`(x,y) := â€¦`  yuck

1569516926
andrewrk
also which one is which? your syntax would confuse go programmers

1569516944
Tetralux
So - there's several things here.

1569516954
Tetralux
First - "doesn't work with patterns" - elobration required.

1569516964
Tetralux
Second - "parsing much harder" -  citation needed.

1569516969
companion_cube
well, you have to parse a whole pattern before seeing the `:=`

1569516977
Tetralux
Third - "which one is which" - I'm not sure I understand.

1569516981
companion_cube
(which indicates that it's actually a pattern that should be parsed)

1569516995
andrewrk
var/const you know it's a var decl with 1 token

1569517006
andrewrk
whereas expressions can be arbitrarily long. this is the worst case of parsing ambiguity

1569517043
_Vi
Submitted proposal issue about --sloppy mode: #3320.

1569517048
andrewrk
thanks _Vi

1569517060
companion_cube
(in rust: `let <pattern> = â€¦`, doesn't get simpler)

1569517067
_Vi
That `@todo` is a good candidate for being a sloppy-only function.

1569517067
companion_cube
`let (mut x, y) = (1,2);`

1569517091
Tetralux
andrewrk: Surely you'd just iteratively parse the expression?

1569517107
Tetralux
I don't completely understand the advantage of being able to know that it's a decl in just one token.

1569517124
Tetralux
Also, it's just names or _ on the LHS.

1569517125
companion_cube
because what's on the left of `=` in a decl, isn't an expression

1569517133
Tetralux
It's not like it's a fancy expression.

1569517164
fengb
Expressions can be almost anything during parsing

1569517167
companion_cube
how do you even differentiate from assignment?

1569517173
fengb
Unless itâ€™s defined to not be an expression but something specific

1569517174
companion_cube
x.* = 42;

1569517186
Tetralux
These arguments are not making sense to me.

1569517195
Tetralux
Obviously the LHS is just an ident.

1569517222
Tetralux
You can tell between an assignment or a decl because an assignment omits the type and is just "=" rather than ":"

1569517226
Tetralux
x := 42; x = 42;

1569517233
Tetralux
x: i32 = 42; x = 42;

1569517242
fengb
Expression by definition is arbitrary and recursive. Youâ€™re asking for something thatâ€™s not a general expression but rather a defined LHS

1569517245
companion_cube
I find that quite confusing to read, tbh

1569517255
companion_cube
better to be explicit about scoping

1569517262
Tetralux
fengb: You cannot have a general expression as the var name as it is.

1569517275
Tetralux
`var f(x) = 32;` does not compile in any circumstance.

1569517279
companion_cube
what happens with multiple return values, or destructuring, orâ€¦ ?

1569517292
Tetralux
companion_cube: What happens?

1569517295
fengb
But that doesnâ€™t happen at parse time

1569517298
companion_cube
well your idea breaks :D

1569517299
Tetralux
x, y, z, _ := f();

1569517304
fengb
Unless you bloat the parser

1569517308
companion_cube
you need arbitrary lookahead to find the `:=`

1569517327
Tetralux
companion_cube: I don't really get why that's so bad - you have a stateful parser already.

1569517339
Tetralux
You have all the tokens in memory anyway.

1569517344
Tetralux
You're just iterating over them.

1569517345
companion_cube
good grammars should have 1-token lookahead, thank you very much :p

1569517358
Tetralux
Citation needed )

1569517360
Tetralux
:) *

1569517367
companion_cube
"should" is an expression of taste

1569517378
companion_cube
but it makes such grammars easy to parse with a variety of techniques

1569517384
companion_cube
hand written, parser generators, parser combinators, etc.

1569517443
Tetralux
I'm not hearing an advantage xD

1569517464
Tetralux
You can already parse extremely quickly.

1569517467
companion_cube
because we're not agreeing on any of the basic axioms :D

1569517472
Tetralux
Even with a basic recursive descent.

1569517493
companion_cube
for me, `let/var/â€¦` is: more explicit, more readable, easier/faster to parse, more general (you can have patterns, not just single variables)

1569517493
mikdusan
if a `:` or a `:=` token follows an identifier, it's an initialization at stmt level, or a arg-spec for fn

1569517517
companion_cube
mikdusan: still more complicated with multiple return values

1569517529
companion_cube
(I guess you can see the `,` already, but ugh)

1569517538
Tetralux
It's the same complexity.

1569517541
Tetralux
They're not different.

1569517542
dimenus
what about let instead of const for decls?

1569517545
dimenus
:D

1569517548
Tetralux
x, y, z = f(); var x, y, z = f();

1569517549
companion_cube
\o/

1569517561
Tetralux
x, y, z := f(); *

1569517583
companion_cube
Tetralux: you need to find the := first before knowing x,y,z are varaibles to bind

1569517587
companion_cube
(rather than assign)

1569517598
companion_cube
assignment could also stuff like `x[0] = â€¦`

1569517602
companion_cube
which binding doesn't allow

1569517615
companion_cube
(something rvalues something, forgot the C++ terminology)

1569517656
companion_cube
`x.foo = â€¦` is allowed; `x.foo := â€¦` doesn't make sense. So, lookahead needed.

1569517676
Tetralux
companion_cube: The only situation in which `x,` is valid is in a var decl...

1569517677
mikdusan
what?

1569517694
companion_cube
Tetralux: that's kind of ad-hoc though. but if you like itâ€¦

1569517702
Tetralux
Is it?

1569517703
companion_cube
(I'll take my `let`-binding, thank you)

1569517709
Tetralux
Name any other reasonable example of it?

1569517720
Tetralux
It's the same as saying that "var x` is only valid in a var decl.

1569517727
dimenus
Tetralux, we really need GB in here :P

1569517733
companion_cube
`var <any pattern>`, rather

1569517739
companion_cube
because when you see `var`, you know what to parse next

1569517767
Tetralux
where <any pattern> =

1569517771
Tetralux
x, y, z =

1569517773
Tetralux
x =

1569517783
dimenus
andrewwrk: I thought I saw you once recommend replacing const with 'let' for decls, do you have any recent comments on that?

1569517785
companion_cube
{.x, .y} =

1569517798
companion_cube
(x,y) =

1569517800
companion_cube
etc.

1569517811
dimenus
i think the big difference here is that zig has a lot more expressions than Odin does

1569517815
Tetralux
As I said -- x, y, z :D

1569517820
dimenus
most things are a statement in Odin

1569517823
mikdusan
fundametally you guys are arguing prefix (rpn) vs infix :)

1569517823
companion_cube
(I know, if you imitate Go you can deal with it because its expression language is so poor)

1569517848
companion_cube
dimenus: guess that's why I'm on #zig? ðŸ¤”

1569517849
dimenus
also, zig doesn't have separate return values

1569517868
dimenus
or rather multiple return values

1569517878
Tetralux
I think that's a missed opportunity, personally.

1569517887
dimenus
eh, don't really need it

1569517906
dimenus
i was annoyed by Zig's style of error handling back in 2017 when I first tried it

1569517909
companion_cube
I'd rather have tuples, woo

1569517910
dimenus
i've completely come around now

1569517915
Tetralux
If you like writing structs all the time, or write code exactly once, then sure.

1569517920
Tetralux
I do not.

1569517923
_Vi
`let`/`let mut` may be nicer match for Zig than `const` / `var`.

1569517924
Tetralux
I like simplicitly.

1569517929
Tetralux
simplicity(

1569517930
companion_cube
we all like simplicity

1569517930
Tetralux
*

1569517951
companion_cube
we just have different notions of simplicity

1569517967
Tetralux
Multi-return is strictly simpler - you don't have to leave the definition of the thing you're working on.

1569517976
dimenus
i think var is fine, why would we need two keywords for a mutable binding?

1569517980
Tetralux
You don't bounce around your code as much.

1569517991
fengb
More complex implementation

1569517991
Tetralux
And don't have multiple things you must read before reading the fn sig.

1569517996
fengb
So not strictly simpler

1569518010
Tetralux
fengb: Identically complex, in the way you mean, actually.

1569518025
companion_cube
Tetralux: tuples is strictly as simple

1569518036
Tetralux
.. which is how you'd implement multi-return.

1569518048
companion_cube
tuples are values, so it's even simpler

1569518085
Tetralux
Are we agreeing? xD

1569518113
companion_cube
not totally

1569518121
companion_cube
I'm arguing for tuples, you for multiple-return values

1569518156
Tetralux
I would only have tuples as the implemention for multi-return.

1569518160
Tetralux
I wouldn't have them in the language.

1569518167
companion_cube
exactly why we're not agreeing :p

1569518175
Tetralux
I'm not sure why you'd want them though xD

1569518187
Tetralux
My experience with Julia only seems to introduce complexity by having them.

1569518196
Tetralux
And Python, for that matter.

1569518207
companion_cube
you've never had tuples in a typed language, then? :/

1569518215
companion_cube
in OCaml and rust they're absolutely great

1569518240
companion_cube
it's simple a nameless struct with ordered fields, there's 0 complexity

1569518269
Tetralux
In what other situation would you use them for that an array or struct would not suffice?

1569518279
Tetralux
Or well - "suffice" - not the right word.

1569518300
companion_cube
it's totally different from an array; as for a struct, well, sometimes you don't want to name super simple things

1569518305
companion_cube
(eg returning stuff)

1569518316
fengb
Arrays are homogeneous collections

1569518342
Tetralux
Yeah - but in what situation would you use them for?

1569518354
Tetralux
Because I think you'd only really want them for named/non-named return values.

1569518361
Tetralux
In which case, you don't need them in the language.

1569518369
Tetralux
You just need multi-return values that can be named.

1569518387
fengb
Tuples? Where position makes more sense than naming

1569518436
Sahnvour
andrewrk: interesting. hopefully I was able to do my debugging in zig0 lately, but will give it a try

1569518439
Tetralux
Sounds like return values to me :)

1569518515
fengb
But it can also be passed around without unwrapping

1569518543
Tetralux
fengb: g(f()); return f()

1569518548
Tetralux
.. where f has multi-returns.

1569518703
dimenus
how  much swap do you guys use when you build llvm?

1569518706
dimenus
i keep getting owned by the oom killer

1569518758
andrewrk
dimenus,  -DCMAKE_BUILD_TYPE=Release makes it use much less

1569518773
dimenus
oh wow, can't believe i skipped that

1569518786
dimenus
i've built LLVM plenty of times on windows and always included that

1569518801
andrewrk
I always do that for clang. When I do a debug build of LLVM, I don't do any build parallelization

1569518844
dimenus
andrewrk: do you build all targets?

1569518887
Sahnvour
8GB RAM is enough on my windows but I guess it swaps from time to time

1569518911
dimenus
windows behaves far better under memory pressure in my experience

1569518918
dimenus
than *nix

1569519025
andrewrk
dimenus, my build flags are documented here:

1569519131
dimenus
yeah this is far better. cpu's basically pegged at 100% but i'm not experiencing memory/swap pressure at all

1569519328
TheLemonMan
the linking phase takes an awful lot of memory, I've tried to tame it by setting LLVM_PARALLEL_LINK_JOBS and using gold as linker instead of ld

1569519360
TheLemonMan
yay, the mips PR is green!

1569519394
TheLemonMan
and it even builds just fine with musl (with a small patch that I should upstream sooner or later)

1569519498
andrewrk
nice!

1569519509
andrewrk
sorry bout the mv std/ lib/ thing

1569519520
andrewrk
there was never going to be a good time to do it

1569519521
Sahnvour
TheLemonMan: did you try lld ?

1569519537
TheLemonMan
no problem, git rebase figured everything by itself

1569519566
andrewrk
oh, brilliant

1569519589
TheLemonMan
Sahnvour, yep, but I'm partial to the GNU toolchain :P

1569519724
andrewrk
std lib mips support is pretty bad ass

1569519743
andrewrk
TheLemonMan, ready for merge?

1569519795
_Vi
How do I zero-initialize static array without specifying its length again?

1569519844
TheLemonMan
andrewrk, sure thing, just in time for 0.5.0

1569519879
andrewrk
done

1569519900
TheLemonMan
I wonder what's next? PPC64? i386? :)

1569520010
andrewrk
my personal preference: -march=native for windows

1569520041
andrewrk


1569520056
andrewrk
that looks like it will not be fun to debug though. I've taken a few stabs at it

1569520101
TheLemonMan
it's not fun because it's windows

1569520345
dimenus
scientes: how's the SIMD patch looking recently?

1569520372
scientes
It got rebased, but I am not sure if Andrew will look at it again before releasing

1569520417
scientes
yeah the tests passed (which includes arm and arm64!)

1569520437
dimenus
my app still segfaults

1569520448
dimenus
i'll test again once LLVM finishes building

1569520510
scientes
dimenus, that is not a segfault, it is a failure to build, right. The one about sizing unions

1569520525
dimenus
nah, it actually segfaults on assignment

1569520530
dimenus
more recently

1569520535
dimenus
again, i'll verify in the next 30 mins

1569520628
TheLemonMan
soo, mips is promoted to tier 2?

1569520660
scientes
there are like 6 mips ABIS so you should be specific

1569520692
Tetralux
What is MIPS used for?

1569520699
Tetralux
Embedded?

1569520700
TheLemonMan
o32 of course

1569520701
scientes
cheap routers

1569520711
scientes
TheLemonMan, big or little

1569520713
Tetralux
I've never come across any use of it. :)

1569520727
TheLemonMan
scientes, mipsel, BE support in the compiler is flaky

1569520739
scientes
Tetralux, 99% change your router uses MIPS

1569520758
scientes
only the expensive ones use arm or x86

1569520764
Tetralux
What's the hallmark of MIPS? - Like, what's the usecase?

1569520775
TheLemonMan
PS2 and PSP too

1569520800
TheLemonMan
and PS1 of course, let's not forget about it... and N64 too!

1569520814
scientes
oh yeah, MIPS was hot shit on the N64!

1569520893
TheLemonMan
it's a pretty nice ISA

1569520913
TheLemonMan
from the ABI point of view is a clusterfuck tho

1569521103
Tetralux
They open sourced it recently. Huh.

1569521103
andrewrk
scientes, I'm not planning to merge any more for 0.5.0 but will give it priority in the next cycle

1569521122
andrewrk
TheLemonMan, ah yes, good call. I'll update that now

1569521208
companion_cube
Tetralux: g(f(x).1)

1569521220
companion_cube
if it's the second return value of `f` you want to give `g` ;)

1569521250
andrewrk
TheLemonMan, the update will get pushed monday; I have other misc. updates for the home page to launch as well with the release

1569521260
Tetralux
companion_cube: g(f()) would pass all the return values in order to g. :)

1569521290
companion_cube
assuming you have the exact same signature, how often does thatwork?

1569521326
Tetralux
That I do not know.

1569521408
Tetralux
fengb was talking about how tuple can be passed around without unwrapping them - that example, along with being able to directly return all the return values with `return f()` where f has multi-return is an example of that working without tuples.

1569521415
Tetralux
You probably would not do that though.

1569521439
Tetralux
Because you'd probably want to check one of them for an error or something before knowing that you'd need to return anyway.

1569521441
companion_cube
`return f().1;`

1569521454
companion_cube
`return (try f()).1;` ;)

1569521468
Tetralux
I'd do `x, _ := f(); return x;`

1569521469
companion_cube
this isn't go, Zig has proper error handling

1569521482
Tetralux
(Because I'd probably want to check one of the other values anyway.

1569521484
Tetralux
So really

1569521498
Tetralux
x, y, _  := f(); if y {}; return x

1569521500
Tetralux
Something like that

1569521522
companion_cube
so you think

1569521541
Tetralux
I mean, most of my Odin code is of that form.

1569521543
companion_cube
tuples are also useful in things lie iterators

1569521547
Tetralux
At least that that used multi-returns.

1569521561
Tetralux
In what way?

1569521571
companion_cube
well you can have an iterator of tuples

1569521579
companion_cube
like, if you iterate over the key/value pairs of a hashmap

1569521621
Tetralux
I'd rather something like 1)

1569521625
Tetralux
for x, y in map {}

1569521629
Tetralux
Or 2)

1569521648
Tetralux
for entry in map { /* use entry.key , entry.value */ }

1569521651
companion_cube
so, no first class iterators? :p

1569521657
companion_cube
now you want to name everything?

1569521675
Tetralux
I did not say "no first class iterators".

1569521681
Tetralux
Quite the reverse, in fact.

1569521682
companion_cube
`tbl.iter().map(|(x,y)| (y,x))`

1569521690
Tetralux
That looks awful.

1569521693
companion_cube
what's the type of the iterator then? :p

1569521698
companion_cube
that's very simple, please

1569521725
companion_cube
`tbl.iter().map(|e| {.key: e.value, .value: e.key})` is quite the mouthful

1569521727
fengb
Tetralux: you're making adhoc tuples everywhere while trying to avoid tuples

1569521731
companion_cube
^

1569521741
Tetralux
fengb: I mean - not ad-hoc.

1569521746
companion_cube
totally ad hoc

1569521755
Tetralux
Tuples only complicate simple things so far as I can tell.

1569521762
companion_cube
I actually know no language I'd call clean that has multi-return functions :s

1569521775
companion_cube
only untyped languages and weird stuff like Go

1569521780
fengb
Those are literally tuples you're using. You just didn't give them a real syntax

1569521785
Tetralux
Multi-returns make sense that a tuple-like thing is used for them - but you don't actually use them in that.

1569521789
Tetralux
The language does, as it were.

1569521808
Tetralux
fengb: That's the point.

1569521814
Tetralux
I would not give them a syntax.

1569521819
Tetralux
Or at least

1569521821
Tetralux
I'm not inclined to.

1569521823
companion_cube
except for all the constructs where you do

1569521827
fengb
A tuple is just a data structure where position matters. for x, y in blah implies x=[0], y=[1]

1569521837
companion_cube
so instead of 1 notion of tuples, you have multi bindings in varaibles, `for`, etc.

1569521854
fengb
So that's a tuple. And Zig basically demands a syntax for a concept that exists

1569521859
andrewrk
I'll publish a draft of 0.5.0 release notes on saturday evening, and anyone will be welcome to suggest improvements in the form of pull requests

1569521872
Tetralux
Referring to the elements of a tuple with x[0], x[1] etc tells me nothing about what they mean.

1569521883
companion_cube
same as multi return values? :D

1569521894
Tetralux
Where they have names?

1569521902
companion_cube
named return value? :s

1569521903
companion_cube
what?

1569521911
Tetralux
f :: proc(x, y: int) -> (ok: bool, result: int)

1569521917
companion_cube
ughhhhhhhhhhhhhhhhh

1569521930
companion_cube
`-> Option<int>` ;)

1569521931
fengb
(ok, result) looks like a tuple to me

1569521945
Tetralux
fengb: You're missing the point.

1569521945
companion_cube
.{.ok: bool, .result: int}

1569521946
fengb
(foo, bar) = f()

1569521951
fengb
Looks like assignment into a tuple

1569521969
fengb
They're all tuples. So why are you recommending us not having tuples?

1569521975
Tetralux
There. Are. No. Tuples.

1569521977
fengb
I'm actually not sur ewhat we're arguing

1569521978
Tetralux
None.

1569521985
Tetralux
It's just multi-returns.

1569521989
Tetralux
That is it xD

1569522011
Tetralux
Tuples are not, so far as I can tell, a useful programming construct for a programmer to use.

1569522014
fengb
"Just" multi-returns, multi-assignments, multi-iterators

1569522019
companion_cube
(I know no one cares about academia here, but I've never seen anyone talk about multi-return, it's always done with tuples because it's infinitely simpler)

1569522025
Tetralux
They make some sense to use as the mechanism for how multi-returns work, however.

1569522037
fengb
All pretending to use what will be tuples underneath the covers... but not tuples?

1569522038
companion_cube
fengb: ðŸ’¯

1569522060
Tetralux
I wish people would see what it is I'm saying and not cling to an idea sometimes :)

1569522077
companion_cube
we could say the  same of you :p

1569522080
Tetralux
All it is, is that you have multiple returns.

1569522090
companion_cube
and multi iterators

1569522093
Tetralux
They way you do that is the same data layout as what you might call a tuple.

1569522093
companion_cube
and multi assignment

1569522107
Tetralux
But you don't provide a way for a programmer to make or otherwise use a tuple.

1569522108
companion_cube
(and multi for)

1569522121
Tetralux
Beyond multi-assignment and multi-declaration.

1569522128
companion_cube
and multi for and multi iterator

1569522132
companion_cube
it's really a mess :D

1569522137
Tetralux
Multi-for?

1569522152
companion_cube
for i, x in â€¦

1569522167
Tetralux
That's only a tuple in appearance xD

1569522170
companion_cube
or is it `x, i`?

1569522180
Tetralux
And even then - that's a little tenuos.

1569522184
Tetralux
tenuous*

1569522188
Tetralux
I wouldn't consider that a tuple.

1569522196
Tetralux
I'd consider that part of the syntax for the 'for' construct.

1569522199
Sahnvour
companion_cube: I hope you're wrong that no one cares about academia :)

1569522200
companion_cube
Tetralux: the point is, with tuples, you don't need any of this special stuff. You just have expressions

1569522211
companion_cube
Sahnvour: well, no one wants to hear about dependent types :p

1569522227
companion_cube
and andrewrk doesn't like `noreturn` as a type :(

1569522235
companion_cube
(forgot who was arguing about it, but it made a lot of sense to me)

1569522273
fengb
I don't care about academia :P

1569522282
companion_cube
Tetralux: for me, "simple" means predictable and uniform (principle of least surprise). Tuples, being normal values, fit this requirement

1569522303
andrewrk
companion_cube, it made sense to me too, I think I was a bit more argumentative than I actually felt about it

1569522304
companion_cube
there's no need to think about the meaning of functions returning several values or stuff like that; functions always return one value

1569522312
companion_cube
:D no worries

1569522327
companion_cube
it's a bit weird, but `noreturn` fits well into the algebra of types, as a zero

1569522329
fengb
Except when it returns no value though :P

1569522338
companion_cube
fengb: it does, it returns void

1569522349
Tetralux
I don't really understand the need to simplify the idea of "a function can return multiple values as a blob" - I don't see the need to simplify that.

1569522350
companion_cube
I mean, it's simpler to have `unit` for that, but anyway

1569522361
Tetralux
Indeed, it's not "one value" - it consists of multiple values.

1569522367
andrewrk
if doing the official "zero" type theory thing results in simplifications of semantics or the way to think about how the type system works, I'm all in. If it creates more edge cases, then I'm against it

1569522367
Tetralux
You're hiding complexity.

1569522369
companion_cube
Tetralux: functions returning one value have been around for a lot longer

1569522373
companion_cube
and are simpler to reason about

1569522389
companion_cube
andrewrk: it simplifies a lot of things, like computing the size of a type

1569522414
andrewrk
as an example, using the zero type to "cancel" a union field, while I understand why the type theory would say to do that, it also seems pretty confusing and unnecessary if you're reading code

1569522442
companion_cube
it's useful when you instantiate templates, of course you don't write `noreturn` in an union directly

1569522445
companion_cube
(that'd be weird indeed)

1569522450
andrewrk
companion_cube, how does it simplify computing the size of a type?

1569522454
Tetralux
companion_cube: I don't really understand what functions always having returned one value being the case for a long time has anything to do with it xD

1569522469
companion_cube
andrewrk: I mean, more for canonizing a type

1569522478
companion_cube
a struct with noreturn in it, becomes noreturn (like multiplication with zero)

1569522486
Tetralux
Returning one value is limiting - "Simple! You can return an arbitrary number of values now."

1569522492
companion_cube
a struct with `void` in it can remove the `void` (like one in multiplication)

1569522497
andrewrk
companion_cube, ah, yeah, that is actually a pretty compelling argument. it's a lot like using void as the HashMap value type

1569522497
companion_cube
Tetralux: how do you compose functions?

1569522502
companion_cube
andrewrk: yes exactly

1569522503
Tetralux
The logic seems fairly easy to extend to that, in my mind.

1569522510
Tetralux
How do you compose?

1569522517
Tetralux
Be more specific.

1569522530
companion_cube
if you have `Result<T,E>` as in rust (or something like  that), using `E=noreturn` in contexts without errors makes it 0-cost

1569522535
companion_cube
Tetralux: function composition?

1569522569
Tetralux
Give me an example of what you mean that you don't understand how it would work.

1569522585
andrewrk
companion_cube, yes, this reasoning is affecting my stance on the topic

1569522591
companion_cube
andrewrk: ðŸŽ‰

1569522623
companion_cube
it's also like: `e1; e2` where `e1: noreturn` simplifies to `e1;` as e2 is dead code

1569522666
companion_cube
and for tagged enums (ahem, sum types :-Â°), the size is (sizeof(tag) + max(sizeof(each struct))`

1569522688
companion_cube
if there's only one struct, the tag is trivially `void` (no information stored in it) so you can simplify it to the only struct remaining

1569522699
dimenus
scientes:

1569522709
dimenus
builds and then seg faults when run

1569522713
companion_cube
Tetralux: more like, I'm used to lambda calculus as a basis, in which functions actually take and return one argument ;)

1569522723
companion_cube
I imagine you can do something similar with multi-return, it's just weird

1569522739
Tetralux
Oh yeah - that's your problem right there xD

1569522758
Tetralux
Computers are not mathematics xD

1569522763
Tetralux
They are structured.

1569522778
companion_cube
mathematics not being structured, that's a new one :D

1569522789
Tetralux
Functions with single-returns is status-quo.

1569522811
Tetralux
But there's not actually any good reason for it.

1569522816
andrewrk
dimenus, neat- experimenting with using @Vector to back linear algebra

1569522824
Tetralux
companion_cube: Also P.S: I did not say that xD

1569522836
companion_cube
you implied it, is all

1569522838
Tetralux
I said that computers are not math-first systems.

1569522850
Tetralux
They are structure-first.

1569522864
Tetralux
Like - you have fixed-size ints, as a trivial example.

1569522866
Tetralux
You have structs.

1569522878
Tetralux
Math is not integral to this.

1569522887
companion_cube
sorry to break it to you, but type theory has dealt with that for a long time :D

1569522921
Tetralux
Sorry to break it to you, but type theory does little to help you understand how to make a machine do its' job in a fast reliable way that actually gets work done. xD

1569522937
Tetralux
It's a whole field of stuff that you do not need to do programming.

1569522960
Tetralux
And having be the reason that multi-returns make no sense, is a good example of why XD

1569522978
companion_cube


1569522981
Tetralux
Not your fault though, I should be clear.

1569522993
companion_cube
this compiler:

1569523011
dimenus
andrewrk: yep, i'm using this in my vulkan code

1569523028
dimenus
i had a working system a month or two ago, but there's something odd going on  now

1569523058
Tetralux
companion_cube: You can test a compiler without using math?

1569523073
Tetralux
Maybe they

1569523079
companion_cube
Tetralux: my point is, this compiler is written in Coq (the most type theory thing in the world)

1569523083
Tetralux
I'm saying that you don't need it and that it overcomplicates.

1569523087
companion_cube
and it's more robust because it was mathematically proven

1569523112
Tetralux
Assuming you know you covered all possible cases, I can believe that.

1569523116
companion_cube
also, rust, which is arguably pretty robust, is based on a lot of type theory things (hello tuples/structs/enums)

1569523141
Tetralux
You also don't need type theory to make structs and enums work - cmon now xD

1569523174
companion_cube
enums as in, tagged unions, or sum types

1569523180
companion_cube
it's very mathematical

1569523195
Tetralux
It's a very well known way to do composition in C xD

1569523197
companion_cube
(after all it first started in MLâ€¦ a language designed for proving)

1569523213
companion_cube


1569523213
andrewrk
dimenus, I look forward to someone doing a perf comparison of doing that vs backing it with arrays

1569523219
companion_cube
no the disguised integer

1569523278
Tetralux
struct { tag: int, value: *void }

1569523283
Tetralux
Seems like a structure to me.

1569523284
Tetralux
:)

1569523348
companion_cube
-_-

1569523363
Tetralux
Like - don't get me wrong - I would not be at all surprised if someone was able to come up with these ideas or whatever - based entirely from maths.

1569523368
Tetralux
But that's not how I'd arrive at it.

1569523371
companion_cube
as they did :D

1569523376
companion_cube
no, but you can learn from other people, too

1569523387
Tetralux
Occamm's Razor.

1569523389
companion_cube
there's a middle ground between pure academia, and pure hacking

1569523410
Tetralux
It's literally just a simple way to represent multiple values.

1569523418
fengb
C++? ðŸ™ƒ

1569523419
Tetralux
This is a very simple construct.

1569523423
companion_cube
fengb: :D

1569523430
dimenus
andrewrk: i can't completely take credit, it's based on directxmath & glm

1569523432
companion_cube
Tetralux: sum types are also a simple way of representing multiple values

1569523442
companion_cube
while also offering a case distinction

1569523446
Tetralux
You could represent them in such a way, sure.

1569523464
Tetralux
But I don't really know why you would, really.

1569523474
Tetralux
You have all the info that a sum type would provide you already.

1569523486
Tetralux
What would that bring to the table?

1569523496
Tetralux
Generics? That infect all your types? xD

1569523499
companion_cube
better safety

1569523511
companion_cube
well, you do know that Zig has generics? ðŸ¤”

1569523551
Tetralux
Sum types give better safety than multiple-returns/

1569523552
Tetralux
?

1569523581
companion_cube
well, `Ok<T> | Error<E>` is cleaner than `(T,E)` + checking if the error is nil first, yes

1569523583
Tetralux
Also Zig generics are thankfully not yet at a 'Peekable<Rewindable<Iterable<byte>>>' yet. :)

1569523657
Tetralux
I think that depends on a few things.

1569523658
andrewrk
dimenus, scientes has a difficult task with the SIMD patchset. I've been slowly cherry-picking commits from it to upstream, and he's had to keep it based on upstream for a long time

1569523665
Tetralux
Namely how generics are implemented and how they are used.

1569523670
Tetralux
And whether that's ergonomic.

1569523683
Tetralux
But the latter is closer to the machine.

1569523684
companion_cube
here I'm just talking about sum types, really, not generics

1569523700
companion_cube
(or tagged unions, ofc)

1569523701
dimenus
andrewrk: yeah, i know it's a large task. I'm only bringing it up because he said his patchset was passing tests (and mergable)

1569525437
mikdusan
this macos ci. like a

1569525461
andrewrk
I'll be sad if the 0.5.0 commit fails CI

1569527213
companion_cube
damn, azure CI looks so much nicer than GCB

1569531255
andrewrk
I'm going to start the stream in 6 minutes:

1569531355
_Vi
What's wrong with this code? Why `comptime_int`?

1569531489
Tetralux
_Vi: Same problem as `var x = if(cond) 0 else 1;`

1569531497
Tetralux
Put `u8(...)` around all your 0x constants.

1569531519
Tetralux
I forget what issue tracks this problem, but it's on the list (I think).

1569531583
_Vi
Tetralux, Would it count as workaround or as a correction?

1569531602
Tetralux
Workaround.

1569531673
_Vi
Looks like just one `u8(0x7F)` suffices.

1569531703
Tetralux
That's something.

1569532105
mq32
TheLemonMan, thumbs up for MIPS support!

1569533196
companion_cube
woo for async/await

1569533209
scientes
dimenus, yeah that is the same problem as before

1569533239
scientes
and I really didn't figure out how to implement it yet

1569533254
scientes
as the union ABI size code was really complicated

1569533262
scientes
and I had trouble following it

1569533735
companion_cube
debugging with qemuâ€¦ insane stuff andrewrk

1569536722
Tetralux
"Well - we have async functions now. Excellent. All we gotta do now is generators!"

1569539587
nrdmn
andrewrk: how much time do I have to get changes in before 0.5.0?

1569540909
andrewrk
0-3 days depending on how easy it is to merge your PR

