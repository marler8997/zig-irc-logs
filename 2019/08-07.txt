1565136239
AlexMax
Hrm, trying to export a fn seems to result in "TODO implement get_c_type for more types"

1565136248
AlexMax
or something is doing that

1565136429
scientes
AlexMax, what type is it complaining about?

1565136430
fengb


1565136440
scientes
my patch series implements it for vectors

1565136616
scientes
oh, "more" types

1565136617
scientes
AlexMax, it is probably because your function returns an error

1565136617
AlexMax
scientes: There's no error position, so actually I haven't a clue

1565136617
scientes
well its one of those three

1565136617
scientes
case ZigTypeIdErrorSet:

1565136617
scientes
case ZigTypeIdErrorUnion:

1565136617
scientes
case ZigTypeIdFn:

1565136617
AlexMax
here is my function, please note that this isn't a promise to do anything ,I'm just noodling around with this

1565136617
AlexMax
export fn longest_match(s: [*]c.deflate_state, cur_match_param: c.IPos) c_uint

1565136618
AlexMax
so I'm not sure where it's getting a function pointer or error union from.

1565136650
AlexMax
Here's the original C code

1565136652
AlexMax


1565138005
scientes
maybe a function pointer?

1565138483
AlexMax
probably, but as I just get a TODO and no error position I haven't the foggiest what it's complaining baout

1565138500
scientes
AlexMax, you can break on zig_panic in gdb

1565139168
AlexMax
I'll try that sometime.  If it piques anybody's curiosity, I get the same panic even with an empty function body.

1565139184
AlexMax
panic, TODO, whichever mechanism it uses

1565139893
dimenus
why woudl vulkan make the y axis point downwards? o.0

1565139897
dimenus
*would

1565139933
scientes
dimenus, maybe they think they are piloting an airplane?

1565139983
dimenus
it' uses the same depth range as D3D, but the choice to flip Y feels random

1565140335
AlexMax
i always flip Y-coordinates dealing with opengl

1565140661
dimenus
yeah, i guess  it's just clip space

1565140978
Tetralux
[Modified the "Troubleshooting Build Issues" wiki page to mention how to fix apparently problem with building on Ubuntu.]

1565144436
mikdusan2
is 'DutchGhost' on irc?

1565144949
dimenus
777 issues!

1565144959
dimenus
I think Zig is popular

1565144966
Tetralux
It seems we are

1565145004
Tetralux
In three different digits no less!

1565145910
AlexMax
Out of curiosity, is there a nice way to get "zig build" to deposit the executable in my current directory

1565145918
AlexMax
or someplace other than somewhere in the cache?

1565145995
mikdusan2
b.setInstallPrefix(".");

1565148487
andrewrk
AlexMax, for what it's worth, the reason for the default is that there are other kinds of things to be installed besides binaries: libraries, headers, and other data files

1565148513
andrewrk
I don't consider that aspect of the design to be complete, I'd welcome a well thought out proposal for where things should be "installed" by default

1565148527
andrewrk
there are also the differences between platforms to be considered

1565148858
fengb
translate-c somehow converted `c=a+((b-a)>>1)` into `c = (a + ((b - a) >> @import("std").math.Log2Int(c_int)(1)));`

1565148988
andrewrk
yep

1565149004
andrewrk
that's how C works. if your type doesn't fit in that cast it's undefined behavior

1565149029
andrewrk
it should be @intCast though. I think that translate-c code outlived explicit-casting-as-functions

1565149084
fengb
What's with the log?

1565149105
andrewrk
note that's a function that takes a type and returns a type

1565149121
andrewrk
related:

1565149228
andrewrk
shift operations take, as a right-hand-side operand, a type which has log2 the number of bits of the left-hand-side operand

1565149260
fengb
Oh I see

1565149358
fengb
I totally forgot about that. So overshifting is undefined?

1565149404
andrewrk
well you can't overshift in zig

1565149411
andrewrk
because of the types

1565149432
andrewrk
but @intCast is illegal behavior if you cast your int to a type that can't fit it

1565149496
Tetralux
It seems very weird to me that C doesn't just say "oh - if you overshift, it just shifts in zeros"

1565149525
Tetralux
Like - I hate undefined-behavior-that-doesn't-need-to-be, SO. Much.

1565149541
Tetralux
Just do the reasonable thing or error already x'D

1565149569
andrewrk
zig has std.math.shl for that

1565149577
andrewrk
it even supports negative operands

1565149838
curtisf
did some really old cpus have only one of shift rotate / shift zeros maybe? and maybe some of them only took a few bits to do the shift instead of a full word? it also helps compilers somewhat to just always assume the rhs is in bounds

1565149847
curtisf
specifying an assert is probably something they didn't think they could do

1565149861
curtisf
but it would have been nice if some c compilers came prepackaged with a way to insert asserts on all of these things

1565150089
curtisf
I'm really happy with Zig's choice to have a "safe" mode, because it makes UB a whole lot less scary

1565150157
Tetralux
Personally, I might prefer to totally remove UB completely, and allow the compiler to optimize anything it can provided that behavior is maintained.

1565150237
curtisf
I don't really believe it's meaningful to eliminate UB from a language without having an extremely expressive type/constraint/invariant language

1565150244
curtisf
meaningfully possible*

1565150285
fengb
The only way to remove UB completely is bubble up every possible error. Either you take the performance check for error bounds checks, or you have to convince the compiler it cannot happen

1565150314
fengb
Like... a + b is undefined for edge cases of a and b. That'd make math insanely tedious

1565150320
curtisf
it's far, far beyond bounds checks, though

1565150333
curtisf
what do you do if you pass `qsort` a non-transitive comparison function?

1565150368
curtisf
you can detect this _sometimes_, but you won't always detect it unless you compare every element to every other element

1565150371
fengb
Eh... I'd argue userland bugs are userland bugs. Otherwise you have a halting problem

1565150569
fengb
I like the way Zig handles it. UB is an error for safe mode, but I can still "escape" if I ask the compiler nicely

1565150570
fengb
And thar be dragons but it's my own fault

1565150584
curtisf
parallelism is also a problem, because you can't specify the language to behave like an interleaving of atomic instructions, since that's not possible without taking a lock every other cycle. so data races also produce undefined behavior

1565150626
curtisf
you can try to push this to say "oh, the language doesn't have undefined behavior, but things can still go arbitrarily wrong if you miscall libraries" which is maybe better but the thing that's actually bad about UB is still there

1565150679
fengb
Rust kinda solves that

1565150758
Tetralux2
The only way to solve it is to bubble up every possible error

1565150763
Tetralux2
I mean

1565150780
Tetralux2
Just define the behaviour?

1565150799
Tetralux2
Like

1565150812
curtisf
How do you solve the `qsort` example?

1565150819
Tetralux2
"shifting always shifts in zeroes"

1565150898
fengb
Well, if you have one reference implementation, you can always define it as the "defined" behavior

1565150906
fengb
Whether it's sensical is up for debate

1565150922
Tetralux2
point is

1565150936
Tetralux2
Choose Sane Behaviour

1565150983
Tetralux2
If you tell me that you don't know what a shift is gonna do I'm gonna burn a hole in your soul XD

1565151092
Tetralux2
It seems the most sane to just define it that in debug mode trying to shift to far is an assertion failure

1565151106
Tetralux2
Or just so nothing

1565151110
Tetralux2
Do*

1565151114
Tetralux2
Or something

1565151128
Tetralux2
But more importantly

1565151147
Tetralux2
If you shift to far, it shifts in zeroes

1565151182
Tetralux2
And in debug mode, you could enable bound checks for it if you want them

1565151199
fengb
C was also created at a time when "portable assembly" was more important than language spec

1565151201
Tetralux2
There. Typing on a phone with autocorrect is hard work man

1565151247
Tetralux2
And you don't need a reference implementation to do that

1565151252
fengb
Yeah it's kludgy and underdefined, but people build stupid C compilers that worked on weirdo architectures

1565151263
Tetralux2
Even an informal spec would do XD

1565151330
fengb
ANSI was the first real spec, and it basically left anything that existing C compilers disagreed on as "undefined". Maybe it should have been more strict?

1565151383
Tetralux2
Force people who want to compile for those arch's to provide a `--enable-real-bollocks` flag

1565151404
Tetralux2
Just to make it THAT obvious

1565151414
Tetralux2
And yes

1565151432
Tetralux2
I like Jais approach

1565151447
Tetralux2
Choose Sane Behaviour.

1565151516
Tetralux2
It's just like "stack vars are always zeroed unless you declare them uninit"

1565151534
Tetralux2
This is Sane Behaviour.

1565151561
Tetralux2
I

1565153852
andrewrk
I don't think this "sane" "insane" characterization is helpful. it's better to make actual arguments

1565153933
andrewrk
for example: not defining zero as a meaningful initialization value has benefits in that tools can know when use of undefined values occur. with guaranteed zero initialization, bugs are indistinguishable from well-defined behavior

1565154358
emekankurumeh[m]
with stage 2 would there be any value in rewriting it in pure zig? or is that stage 3 I'm thinking of?

1565166953
samtebbs
Nice article by kristoff_it:

1565170787
gamester
Async functions are going to be incredible, I can't wait to experiment with them.

1565180467
mq32
hey

1565180478
mq32
Tetralux, you wrote earlier:

1565180491
mq32
> Personally, I might prefer to totally remove UB completely

1565180513
mq32
i don't think, it's technically possible with native languages

1565180888
scientes
with any language

1565180905
scientes
well, as long as you make infinite execution UB, like C++ does

1565180929
scientes
that means you have to have an intrinsic to do an infinite loop however

1565180958
fengb
It‚Äôs possible with a reference language: what the runtime does is expected behavior :P

1565181005
scientes
its not a feature, its a bug!

1565181009
scientes
errr

1565181016
scientes
got that backwards

1565181073
mq32
scientes: It's also possible with any "soft-executed" language (like Lua)

1565181084
mq32
you can just define every behaviour and check it

1565181092
scientes
"and check it"

1565181102
mq32
but you cannot check "invalid memory access" on bare metal

1565181106
scientes
> infinite loop

1565181114
scientes
infinite loops cannot be checked

1565181127
mq32
why should they be undefined behaviour?

1565181133
scientes
they are in C++

1565181143
mq32
no reason to be undefined in other languages

1565181145
scientes
because they are useless

1565181162
mq32
why so?

1565181189
mq32
every embedded program, every OS has infinite loops

1565181190
scientes


1565181266
scientes
if you want to pause infinitely you should use an intrinsic for that

1565181275
scientes
os.halt()

1565181291
scientes
os.sleep(-1)

1565181315
mq32
my current home automation project is primarily something like

1565181331
mq32
void entry_point() { init(); while(true) { update(); } }

1565181340
mq32
there is no "exit condition"

1565181340
scientes
@halt()

1565181352
mq32
nope, no defined "halt" or similar

1565181360
scientes
we really should add @halt() to zig so it can have the above linked optimizations

1565181366
mq32
hardware is halted by removing power supply

1565181386
scientes
mq32, the kernel can also enter an infinite loop

1565181390
scientes
very common in firmware

1565181410
scientes


1565181419
scientes
Its unsafe to rely on an infinite loop never terminating

1565181483
mq32
crazy

1565181487
mq32
i should return to assembler :D

1565181622
scientes
lol, he uses fermat's last theorem to avoid the compiler from outsmarting him

1565181875
mq32
but still: my point is that i can create languages with completly defined behaviour, but then i have an insane amount of checks to do

1565181887
mq32
of which are some impossible on real hardware

1565181895
scientes
seL4 was prooved correct in many ways

1565181904
scientes
including proving that the compiler did not add bugs

1565181958
fengb
Can‚Äôt have undefined behavior if we don‚Äôt optimize!

1565181972
scientes
yes it can

1565181974
mq32
scientes, i wonder how they did that

1565181986
scientes
mq32, they wrote a ton of test code

1565181994
scientes
that testing absolutely everything

1565181994
mq32
yeah, but for what input?

1565182008
scientes
they tested the the code did not have any corner cases

1565182009
samtebbs
scientes: halting only addresses the case where you don't want to be doing something in that loop, like mq32 does

1565182009
mq32
i get a memory map from BIOS which tells me where memory is and where not

1565182031
scientes
samtebbs, if you do something---i.e. have side effects, then the loop is defined

1565182043
mq32
if this map is

1565182046
scientes
of course generating heat is not counted as a side effect

1565182064
scientes
if you are trying to heat your house with a EPYC or Talos II or something

1565182065
samtebbs
scientes: What do you mean by "defined"?

1565182073
scientes


1565182089
gonz_
mq32: Do you have some posts / info about your home automation stuff?

1565182102
gonz_
I'd love to read them

1565182103
mq32
gonz_: Not yet, only a bit of a video

1565182116
mq32
have to get up and complete some services still

1565182130
mq32
(device switching (on/off) currently doesn't really work)

1565182210
gamester
scientes: It seems that infinite loops are now sometimes well defined:

1565182230
gamester
thankfully

1565182255
samtebbs
scientes: I see. Just pausing with an infinite loop is less desirable than sleeping as sleeping explicitly tells the scheduler that this process can be yielded in favour of other processes

1565182271
scientes
I still think we should have a @halt() and then set it as undefined

1565182271
gonz_
mq32: Whatever you end up writing about it, maybe just releasing some code, etc., toss me a message.

1565182297
scientes
if you have an OS @halt() will call the os, and sleep infinitely

1565182305
samtebbs
mq32: I'd be interested too :)

1565182325
samtebbs
scientes: Yeah, that's a nice idea

1565182364
scientes
we can probably also trick the compiler to tell use where all the infinite loops are so we don't forget to convert soe

1565182452
mq32
gonz_, samtebbs: you guys give me a motivational boost :) something to do for the weekend :)

1565182523
mq32
hm, random brainfart:

1565182528
samtebbs
scientes: Perhaps a warning on finding an halting loop (while(true) {}) that suggests converting it to a sleep or halt would be good

1565182544
scientes
samtebbs, zig does not have warnings

1565182565
samtebbs
By design?

1565182569
scientes
yes

1565182580
samtebbs
mq32: Looking forward to it :)

1565182581
scientes
but the most trivial version could be pattern matched and be an error

1565182597
samtebbs
Is it really an error?

1565182598
mq32
does anyone except me find the idea of having arbitrary significance integer literals useful (or just literals for bit groups)

1565182645
mq32
so like quaternary numbers or similar?

1565182721
scientes
mq32, the problem with such things in the language is that it require the compiler writer to understand such math

1565182747
scientes
and you would really need to get it into LLVM to be worth putting into Zig

1565182756
scientes
LLVM is in the process of adding complex numbers

1565182778
mq32
nah, it's just number iterals (binary, quaternary, octal, hexadecimal), ...

1565182801
scientes
oh, no, just binary and headecimal

1565182804
scientes
octal should be removed

1565182815
scientes
and quaternary is too similar to "quaternian"

1565182817
mq32
quaternary is useful for writing stuff like manchester encoding, color values with 2 bit per channel, ...

1565182820
scientes
which is something totally different

1565182855
scientes
mq32, you can do that in comptime, this is zig after all

1565182868
scientes
and octal should be removed and replaced with a comptime implementation

1565183275
mq32
you mean like

1565183284
mq32
xq.numbers.quaternary("031234");

1565183292
mq32
damn. I like zig

1565183302
mq32
this whole comptime thing is just too powerful

1565183993
mq32
scientes:

1565185029
samtebbs
mq32: I'd be interested in seeing what similar C code produces

1565185040
samtebbs
Would be cool to see a comparison

1565186968
mq32
samtebbs, i don't think there's a real C equivalent to this

1565187214
samtebbs
Not with the comptime concept. Without it, there must be

1565187347
mq32
also only partial support (you cannot do templates)

1565188251
kristoff_it
Hello everyone, guess which language is on the frontpage of r/programming :D

1565188428
mikdusan
üëç pretty positive all around

1565188445
andrewrk
nice article kristoff_it :)

1565188502
kristoff_it
thanks, and please feel free to correct me if you think I'm misrepresenting any concept

1565188524
andrewrk
everything looked accurate to me

1565188694
samtebbs
kristoff_it: It's a really good, I learnt some stuff and especially liked the part on code elision

1565188708
samtebbs
a really good article*

1565188940
kristoff_it
samtebbs: thanks!

1565189256
gonz_
In honor of the zeitgeist I made this:

1565189327
dimenus
does anyone build zig with the vs2019 toolchain?

1565189341
mikdusan
yes in a vm

1565189355
dimenus
Mine used to compile but now it fails when building libuserland

1565189360
dimenus
what version mikdusan?

1565189374
mq32
gonz_, neat. does it support spaces like seconds("3h 23m 33s"); ?

1565189378
dimenus
i have a master tree that builds fine with v2017 but fails on v2019

1565189413
gonz_
mq32: Not right now, but it's a `continue` in the `switch`

1565189415
mikdusan
dimenus: i usually build against windows10 vs2019 before making a PR but it's been a week or so

1565189425
gonz_
+ "... away"

1565189433
mikdusan
dimenus: i'll fire it up and run against master. do you get a build error or test error?

1565189477
gonz_
mq32: Actually, it does ignore any other character that isn't relevant

1565189485
gonz_
so yeah, it'll just happily truck on with those spaces

1565189498
dimenus
mikdusan: build error

1565189506
dimenus
i'm running 19.22.27905 for cl

1565189554
kristoff_it
gonz_: nice library! if you want to improve it, remove some `comptime` constraints. the function doesn't seem to really need comptime arguments and a caller would still be able to call your function at comptime using `const seconds = comptime humantime.seconds(...);`

1565189582
kristoff_it
gonz_: this way it's possible to use it to parse user input, for example

1565189599
gonz_
kristoff_it: I did have that from the beginning, yes, but was debating whether or not to constrain it. I'll open it up and let it be decided at the call-site.

1565189788
gonz_
`comptime` should be needed for the `@compileError` bit, but I guess I'll just make it crash

1565189873
gonz_
I still don't know that it's worth it to even handle it because of the condition already being checked in the `switch`

1565189949
mikdusan
dimenus: i'll launch a build as soon as the vm settles down. every week or so windows likes to do a ton of disk IO (prob security scan or somesuch) and I can't get anything done until that finishes because VM disk IO is sloooow

1565190105
dimenus
heh

1565190107
dimenus
sounds good

1565190249
mikdusan
builds for me: windows10, cl 19.21.27702.2, master branch 7f23dac6dce2ce897295e8186f164f695cacdbc9

1565190275
mikdusan
what build error do you see?

1565190322
dimenus
o.0

1565190339
dimenus
invalid builtin function 'hasDecl'

1565190353
dimenus
it's like the FNV32 hash has a bug or something when compiled on my system

1565190365
dimenus
ah, your cl is older

1565190381
dimenus
which would fit with my memory that it used to compile for me but doesn't now

1565190414
mikdusan
i'll try to upgrade. do you have a buildtools update link handy? :)

1565190431
dimenus
no, this is my work pc - i use the full vs install

1565190435
dimenus
it's not as bad now with 2017/2019

1565190441
dimenus
unlike the 50GB install it used to be

1565190466
dimenus
you can pick and chose components in an adhoc fashion

1565190471
mikdusan
heh my entire VM is 50GB

1565190473
dimenus
**choose

1565190512
dimenus
you can use chocolatey?

1565190519
dimenus


1565191247
dimenus
scientes: your simd5 branch didn't modify translate/compile c code right?

1565191363
mikdusan
dimenus: can confirm same build failure w/ 19.22.27905: invalid builtin function: 'hasDecl'

1565191380
dimenus
so is this a cl bug lol?

1565191403
dimenus
thanks mikdusan

1565191513
mikdusan
it's possible this terse report is same issue:

1565191558
dimenus
yeah i saw that issue yesterday, I'm glad we have it narrowed down to being msvc

1565191565
dimenus
i was so frustrated yesterday

1565191597
kristoff_it
gonz_: you could also change the function return an error in such case. at comptime making the build fail is probably ok, at runtime the right reaction really depends on the usage context. I think that it would be best to let the caller decide what to do in both cases.

1565191738
gamester
I'd just have it comptime-only.

1565191920
gamester
gonz_: The library is a really nice idea btw, I love it!

1565192391
scientes
dimenus, no, and I don't really see a reason why, because any code that uses vectors in C uses non-portable x86, arm, or ppc intrinsics

1565194090
dimenus
hmmm, zig clang is not picking up that it's a native target

1565194329
scientes
dimenus, can you give more details?

1565194379
dimenus
i take that back, it is

1565194407
dimenus
basically, i'm getting a bunch of undefined references for intrinsic instructions on win10 x64

1565194415
dimenus
eg _mm_setr_epi16

1565194421
scientes
dimenus, that is a known bug

1565194425
scientes
those are not functions

1565194427
dimenus
this worked before o.0

1565194431
scientes
I think I explained this before

1565194437
dimenus
i know they're not supposed to be

1565194445
scientes
no, the compiler should error out when importing those special header files

1565194475
scientes
I think we already have special handling for #include <stdbool.h>

1565194482
scientes
and there are a few other special header files

1565194522
andrewrk
dimenus, did something change on your computer? I've been building with win10 x64 msvc2019

1565194535
dimenus
andrewrk: yes, msvc updated

1565194539
dimenus
19.21 works fine, 19.22 does not

1565194541
andrewrk
hmm let me try it now

1565194561
dimenus
andrewrk: mikdusan confirmed the issue on his vm

1565194574
dimenus


1565194574
scientes
andrewrk, I marked the SIMD PR ready for review

1565194581
dimenus
that's a separate issue from the intrinsics though

1565194584
dimenus
i'm not sure what's going on there

1565194585
andrewrk
oh nvm I've been using 2017

1565194593
dimenus
yeah CI is for 2017 as well

1565194622
scientes
its far from complete, but it was functional enough that I could run some real-world stuff

1565194623
dimenus
zig emits -march=native, but clang seems to not care

1565194635
dimenus
scientes: i don't know what you mean by special headers, zig ships with xmmintrin

1565194638
dimenus
or whatever the header is called

1565194648
scientes
dimenus, yeah but it doesn't work

1565194653
scientes
that's just from musl

1565194657
andrewrk
dimenus, I don't get it, did msvc ship a broken compiler?

1565194674
andrewrk
what does this have to do with libuserland?

1565194691
andrewrk
oh I see, that's the step the build fails at because msvc produced an invalid zig.exe

1565194694
dimenus
yes

1565194705
dimenus
@andrewrk

1565194709
andrewrk
uhh ok so I guess we just wait for the fix to ship then

1565194745
scientes
dimenus, or rather, that is a clang header file

1565194755
scientes
return (__m128)__builtin_ia32_sqrtss((__v4sf)__a);

1565194762
scientes
see we don't have all these __builtin_* functions

1565194764
andrewrk
dimenus, I guess we can make sure it's not UB

1565194782
scientes
there are some we should implement, like __builtin_popcount and __builtin_clz

1565195078
gonz_
We do have popcount, no?

1565195081
gonz_
`@popcount`

1565195088
gonz_
`@popCount`*

1565195095
scientes
gonz_, yeah but we don't convert from GNU popcount extension to @popCount

1565195100
scientes
in translate-c

1565195104
gonz_
Ahaa

1565195106
gonz_
Right

1565195166
scientes
but of course if you just build with zig cc (which is clang) then it will work

1565195630
mikdusan
vs2019 19.22.xxx CMAKE_BUILD_TYPE=Release is build failure

1565195653
mikdusan
here is a hint: CMAKE_BUILD_TYPE=MinSizeRel is build success

1565195687
mikdusan
her is another hint: changing `/Ob2` -> `/Ob1` is build success with CMAKE_BUILD_TYPE=Release

1565195693
scientes
mikdusan, you could set up an automated bisection

1565195700
mikdusan
no

1565195703
dimenus
scientes: I'm sorry i'm being thick here, but I don't know why SSE2 intrinsic would not work on x64

1565195721
dimenus
i've totally used this setup before

1565195741
scientes
dimenus, you can compile it with clang, but zig doesn't implement those __builtin_* functions, those are not in C, they are implemented by the compiler

1565195743
donpdonp
nice writeup on 'comptime' at the top of lobste.rs

1565195762
dimenus
scientes: nothing is calling a __builtin_* function here

1565195768
dimenus
this is straight _mm_set_epi16

1565195772
dimenus
which compiles just fine with mingw on windows

1565195777
dimenus
it's only the msvc toolchain that's failling

1565195799
scientes
dimenus,   return

1565195815
scientes
that's the definition of _mm_set_epi16 in the clang headers

1565195861
scientes
dimenus, the only way to use those directly is to use llvm's inline assembly

1565195864
scientes
which is what clang does

1565195885
dimenus
i'm compiling a c file using zig cc

1565195893
scientes
oh then it should work

1565195895
dimenus
....

1565195908
dimenus
indeed

1565195915
scientes
maybe you are using a differn't compiler's headers

1565195921
scientes
are those headers are compiler-specific

1565195923
Tetralux
mq32: RE UB, you can remove it in low level languages. You just put effort into thinking about what sane behavior would be, and then implement that on all platforms.

1565195979
dimenus
mikdusan: so MSVC is generating invalid code when it tries to inline either the table get call or the hash itself

1565196004
dimenus
i bet this is msvc's fault again....

1565196029
mikdusan
yes something is manifesting with `/Ob2` and 19.22.xxx

1565196105
dimenus
le sigh, yep it's msvc

1565196114
dimenus
scientes: msvc defines _mm_setr_epi16 as extern

1565196127
dimenus
good call

1565196148
scientes
dimenus, but why are you using the wrong headers? it should use the internal (clang) headers first

1565196192
dimenus
scientes: I'm not using the wrong headers, zig just appends msvc's headers first

1565196198
dimenus
let me make that change....

1565196200
scientes
that sounds like a bug

1565196245
scientes
like it will probably break <stdbool.h> <stdnoreturn.h> et cetera

1565196444
gonz_
gamester: Yeah, it's one of those small things that I've really liked having in our code in other languages.

1565196495
gonz_
kristoff_it: In this case I don't know that it actually needs to be handled explicitly since the pre-requisite is checked in the switch anyway.

1565196614
dimenus
scientes: it was indeed a header precedence bug, thanks for the tip

1565196627
scientes
dimenus, i think you should file a bug/write a patch

1565196635
scientes
cause I'm pretty sure the clang headers should come first

1565196645
dimenus
/ According to Rich Felker libc headers are supposed to go before C language headers.

1565196655
scientes
oh ok

1565196657
dimenus
the problem here is that it's not just libc, it's the intrinsics for the compiler

1565196669
scientes
then complain to him in #musl that stuff breaks then

1565196701
scientes
or rather, special C language headers should come first

1565196709
scientes
the ones in the C standard and the SIMD extension headers

1565196721
scientes
well, the C standard also defines libc stuff

1565196726
dimenus
i'll write a patch, winsdk headers should come first

1565196727
scientes
so there is complicated overlap

1565196738
dimenus
but not MSVC specific sones

1565196795
dimenus
in msvc, stdio, stdlib, stddef = winSDK - stdarg, stdbool, intrinsics etc = MSVC dir

1565196812
scientes
ahh yes, that sounds right

1565196900
dimenus
actually, we really shouldn't even be using msvc's header dir

1565196904
dimenus
since clang does that grunt work

1565196915
scientes
are you sure?

1565196922
scientes
oh yes, indeed

1565196930
scientes
just winSDK

1565196988
dimenus
ah, native clang does include it - but it uses its own headers first

1565196995
dimenus
so i think we should just replicate what regular clang does

1565197048
dimenus
andrewrk: do you care to weigh in here? Not sure where you read that detail from Rich

1565197152
dimenus
andrewrk: to summarize, because we're adding libc headers to the search path before the C language headers from clang - intrinsics and anything specific to MSVC are broken

1565197184
dimenus
we either need to separate "compiler specific headers" into its own list and put them further down the totem pole

1565197195
dimenus
or just move clang's headers up to the top of the list

1565197204
dimenus
(which is what regular clang does on windows)

1565197367
mikdusan
dimenus: related for macOS; 1..5 describes the separations i found where 2, 3, 4 look applicable to windows too:

1565198610
dimenus
good ifno

1565199476
andrewrk
dimenus, he said it in #musl

1565199509
andrewrk
if it needs to be the other way around for intrinsics to work, so be it. let's make that change.

1565199525
dimenus
do you want me to submit a PR/issue for it then?

1565199537
andrewrk
yes please, feel free to skip to the PR

1565199896
dimenus
andrewrk: submitted

1565199925
andrewrk
emekankurumeh[m], thank you for the great question about an async function being able to destroy its own frame. that's now part of the semantics in the branch, and i'm about to write a test for it

1565200229
dimenus
andrewrk: code note updated

1565200314
andrewrk
dimenus, merged. the code was this way for some time so I'm pretty sure it should be ok. if it breaks things then we can investigate

1565200343
dimenus
clang uses its own headers first

1565200367
dimenus
so we have it mostly correct, we should just split "libc" headers from other platform headers

1565200388
dimenus
eg with windows, WinSDK can be high up on the list, but MSVC headers cannot be above clang's

1565200512
andrewrk
I see

1565200636
mikdusan
makes sense. by putting clang-intrinsics first, other "libc" can be used. beit zig+musl, or linux /usr/include or winsdk provided, or macos-sdk provided

1565200939
scientes
andrewrk, I am interested in submitting a proposal to give a talk on SIMD in Zig at the LLVM dev mtg in october, here are what I have for slides for my proposal (which can of course change)

1565201008
andrewrk
scientes, that's exciting. I can do that within a couple weeks

1565201022
scientes
ok, but I have to submit the proposal this week

1565201107
andrewrk
ok I can give a high level patch series lookover tomorrow

1565201135
scientes
thank you

1565201179
scientes
the submission deadline is sunday night

1565203324
donpdonp
2019-07-06/bin/zig build => works fine. 2019-08-05/bin/zig build => /usr/include/unistd.h:229:10: note: 'stddef.h' file not found

1565203557
donpdonp
hmm could be a prob with the installation. 2019-07-06/lib/zig/include/stddef.h is there but 2019-08-05 has it in the wrong place. probably my problem. <grin>

1565204831
emekankurumeh[m]
wait, I thought you can't `try` in defer...

1565208155
scientes
emekankurumeh[m], i don't see why not

1565208182
scientes
i only see that it wouldn't make sense in errdefer

1565208226
emekankurumeh[m]
I've got an error whenever I've tried to do it in the past...

1565208247
scientes
well i guess you would want all the defers to run

1565208255
scientes
and try would mean that wouldn't be the case

1565208308
scientes
like return should also not be allowed

1565208462
andrewrk
the only way to prevent the rest of the defers from running is to panic / exit

1565208471
andrewrk
you can't "return early" to skip defers

1565208511
andrewrk
in the async/await branch, I've made it legal to suspend inside a defer -  e.g. await or cancel - because these operations are now guaranteed to complete. cancellation points are now fully explicit

1565208721
shachaf
Is "fn foo() int { defer { return 1; } return 2; }" permitted?

1565208736
shachaf
I guess I can test it.

1565208812
shachaf
It's not permitted. Why would try be different?

1565208835
Tetralux
Because try is different? xD

1565208858
Tetralux
I'm also not sure what 'defer return' should do.

1565208873
Tetralux
Override any return you otherwise did?

1565208893
andrewrk
you shouldn't be able to `try` inside a defer either, sounds like a missing compile error

1565208893
Tetralux
try is just "attempt to do something that may fail"

1565208915
shachaf
Oh, maybe it's not permitted and I misunderstood the above.

1565208936
Tetralux
'defer try' is orthogonal to 'defer return' isn't it?

1565208942
andrewrk
`try x` can be desugared to: `x catch |e| return e`

1565208959
Tetralux
Oh yeah... fair point.

1565208991
Tetralux
Though, to be fair, I still think those two things are different.

1565208999
Tetralux
'defer return' doesn't make much sense.

1565209028
Tetralux
I'd prob be okay with both being illegal though.

1565209030
fengb
Try is just a special return so it would also not make sense

1565209052
fengb
*conditional return

1565209086
Tetralux
Well

1565209089
Tetralux
Actually.

1565209099
Tetralux
Both

1565209150
Tetralux
fn foo(x: usize) bool { defer return x == 0; x *= 2; }

1565209182
Tetralux
Or at least 'defer return' does - I'd have to think more about the other.

1565209233
mikdusan
defer is not a return hook

1565209460
Tetralux
I mean it makes logical sense in the context I laid out.

1565209469
Tetralux
I'm not saying that it should be in Zig x)

1565209532
Tetralux
It might help to set up the expectation of what's being returned at the top of a procedure before you read anything about what happens to the expression in the rest of the procedure though, which I think might help reading code.

1565209541
scientes
it is well defined, but it makes the control flow too confusing the reason about

1565209543
Tetralux
I dunno - maybe some research in that direction could be interesting.

1565209557
scientes
and the whole point of defer and errdefer is to have more understandable control flow

1565209585
scientes
so i think forbidding return and try from defer and errdefer makes sense

1565209618
Tetralux
I think that it would

1565209639
Tetralux
It may mean you don't have to read some code more than once.

1565209646
Tetralux
(.. in order to correctly understand it.)

1565209661
Tetralux
But I think research would be warranted to explore that.

1565209672
Tetralux
And yeah, we'll be fine without it.

1565209684
Tetralux
Though, I have no actual evidence with which I say that.

1565209703
Tetralux
You can still express the intent either way.

1565209706
scientes
you can always use if() for your control flow

1565209717
Tetralux
Indeed, and you can return an if.

1565209719
Tetralux
Although curiously

1565209720
scientes
defer and errdefer is just to simplify common stuff

1565209739
Tetralux
return if() { code } else expr;

1565209740
scientes
as is the whole error handling stuff

1565209749
Tetralux
^ doesn't seem to work iirc.

1565209757
Tetralux
and yeah, indeed.

1565209760
scientes
Tetralux, yes it does

1565209772
scientes
a similar thing with return switch is all over the code

1565209790
Tetralux
scientes: I say that because I tried returning an if the other day and I seem to recall that putting braces for the else fixed it

1565209806
fengb
defer isn't always at the top

1565209831
Tetralux
fengb: I know.  But the context I was describing, the point would be that you probably would.

1565209857
Tetralux
Also, andrewrk, you said about how coroutines will be cancelled explicitly; can you clarify how that's different from before exactly?

1565209888
Tetralux
Does doing cancel destroy the frame immediately? Or more like "marks it as done without a result value".

1565209893
mikdusan
Tetralux: i'm ok with idea of defer code to examine/modify stuff

1565209898
scientes
Tetralux, the main difference is that memory allocation of the co-routine frame is separate

1565209901
scientes
AFAIU

1565209934
andrewrk
Tetralux, `cancel` is the same as `await` except it sets the cancel bit

1565209940
andrewrk
cancel is a suspend point

1565209995
Tetralux
cancelling just means "we would have resumed it otherwise, we now will not"

1565210010
andrewrk
almost. it means we would have

1565210029
andrewrk
using `resume` on a frame that is ready to be awaited is a safety panic

1565210064
andrewrk
`resume` goes with `suspend`. `cancel` goes with `await`

1565210079
Tetralux
You'd use cancel on something that doesn't give a result and you don't care when it's done? Kind fire-and-forget style thing?

1565210099
andrewrk
basically after every await, you're going to defer a cancel

1565210115
andrewrk
sorry, after every

1565210123
Tetralux
.. Had me confused for a sec there xD

1565210135
Tetralux
So it's like

1565210142
andrewrk
after async, you have 2 choices: cancel, or await. cancel is safe to do multiple times

1565210155
Tetralux
.. because if you already cancelled, it does nothing?

1565210168
andrewrk
right, if you already canceled or awaited

1565210176
Tetralux
Does awaiting multiple times return the same result as the first time?

1565210179
Tetralux
Or is that panic?

1565210184
andrewrk
awaiting multiple times is panic

1565210200
Tetralux
How do you know if a promise is complete?

1565210210
andrewrk
you don't. you await it when you want the result

1565210230
scientes
these are co-routines, they run in a single thread

1565210240
dimenus
is it possible to create a slice from a ptr?

1565210240
andrewrk
scientes, we're calling them async functions now

1565210254
andrewrk
dimenus, you can slice the ptr

1565210257
andrewrk
ptr[0..n]

1565210264
scientes
andrewrk, but are they always asyncronos?u

1565210305
andrewrk
nope, you can in fact define a function whose async-ness will be inferred by what functions it calls

1565210332
scientes
but I mean, co-routines are not really asyncronous

1565210345
scientes
and they do not have race conditions that asyncronous code has

1565210361
Tetralux
From the point of view of the imperative code you are writing, they are though. No?

1565210386
andrewrk
what's the question?

1565210394
fengb
I thought the point is you can toss the async function to a thread pool and then it'd be really asynchronous

1565210431
dimenus
'slice of single-item pointer'

1565210447
andrewrk
fengb, it's the other way around: std.fs.File.write will decide whether it should use an event loop or a blocking syscall based on some comptime configuration (e.g. pub const io_mode = .blocking; // in root source file)

1565210460
dimenus
do i just change the c import?

1565210476
andrewrk
dimenus, this is an auto generated type?

1565210480
scientes
like if you do if (some_variable) { do_something() }; well, if some_variable is change by another thread then that is a race condition

1565210481
andrewrk
or did you decide the type?

1565210504
scientes
and you would need to do an atomic load with .Acquire semantics

1565210522
scientes
but you don't if you know the only other thread to change it is actually a co-routine

1565210529
dimenus
andrewrk: the c type is [*c]const stbi_uc

1565210531
andrewrk
scientes, yes we're going to need some safety features for concurrency

1565210541
dimenus
I want []Pixel

1565210549
dimenus
which is align 4

1565210553
andrewrk
dimenus, oh you can't slice [*c] pointers? that's a bug

1565210565
scientes
some calling it "async" seems kind of funny, when it isn't necessarily asyncronous

1565210567
dimenus
maybe i can

1565210589
andrewrk
scientes, they are "async functions" because unlike normal functions, the start and end of the function call are not at the same call site

1565210638
scientes
or rather, because they use the "async" keyword (which is fine)

1565210672
andrewrk
I think the name works and it gives people a better idea of the semantics than "coroutines"

1565210683
scientes
yeah, its fine

1565210690
scientes
and if you write async then you will always be fine

1565210690
andrewrk
they really are just functions

1565210693
andrewrk
functions that can suspend

1565210706
dimenus
andrewrk: I can slice them, i was just doing this backwards

1565210711
Tetralux
.. and only when they return with .Complete, effectively, do they

1565210713
andrewrk
but normal functions can be suspended by the kernel. so really they're just functions! it's beautiful

1565210746
scientes
andrewrk, yes, user-space programs are always async

1565210773
Tetralux
I assume that you have to defer cancel by the way, because you

1565210810
Tetralux
And if you cancel, does that mean the function won't resume once it next suspends, even if it didn't get to the '.Complete' stage?

1565210817
andrewrk
it's well-defined what happens if you don't await/cancel

1565210833
fengb
JS promises let you await multiple times. Can we emulate that behavior? (Or is it even desirable?)

1565210842
Tetralux
andrewrk, Oh? What happens?

1565210891
andrewrk
Tetralux, the defers don't run. probably a resource leak. but if you don't have any resources to leak, it's fine

1565210929
scientes
but that would mean the async function would have to be stackless

1565210939
scientes
to not leak any resources

1565211036
andrewrk
fengb, I don't think that's going to happen. async functions really are equivalent to functions, but with separate start (async) and end (await/return) positions

1565211049
andrewrk
however you could design a userspace type which does this

1565211146
Tetralux
Where

1565211181
fengb
I think I'll need to relearn this. JS async map to promises directly so it's a lot more value driven than control flow

1565211310
andrewrk
async functions have a "frame" which all their state is stored on. the async caller supplies the frame to the callee

1565211377
Tetralux
Does "supply" mean that the callee essentially does 'alloca' on the caller's stack for this?

1565211457
fengb
It wouldn't be alloca since we know the callee's stack size

1565211466
scientes
and can they both use the caller's stack and their own stack?

1565211505
mikdusan
callsite choice. if LHS is a stackvar then it goes in stackvar. if LHS is a `p.* = async foo()` then p is presumably heap alloc

1565211514
scientes
because they aren't really async they can actually all share a stack

1565211528
andrewrk
Tetralux, not literally alloca (a runtime stack bump) but yes it goes in the caller's frame

1565211543
andrewrk
you decide where it goes, it's the return type of async

1565211554
andrewrk
var frame = async foo(); // you chose for it to go in the frame of the caller

1565211565
andrewrk
heap_ptr.* = async foo(); // you chose for it to go on the heap

1565211570
Tetralux
AHHHHH

1565211572
Tetralux
I see

1565211572
scientes
but how do you set the stack pointer?

1565211586
Tetralux
So the promise, IS, quite literally, the stack of the async fn?

1565211595
andrewrk
scientes, async functions are generated with all locals in a struct, which is passed as a secret pointer parameter

1565211614
andrewrk
Tetralux, yes but just one stack

1565211623
scientes
andrewrk, but what if the async function calls another function, which expects a stack?

1565211652
Tetralux
It depends on where the top level async fn put the promise.

1565211657
andrewrk
scientes, async functions have a kernel stack which they use for function calls. it's only their one frame that does not go on the kernel stack

1565211684
scientes
so all functions calls from a async function would have to use @newStackCall ?

1565211718
andrewrk
why don't you have a look at the passing tests in the rewrite-coroutines branch - all the tests from master branch are (modified and) passing

1565211726
scientes
oh ok, cool

1565211745
andrewrk
there are also some interesting safety panic tests

1565211780
andrewrk
here's how you can think about this: you take a normal function, ok, everything is the same so far, and you take its stack frame, and you put it somewhere else.

1565211790
andrewrk
that's it. that's the main idea

1565211794
andrewrk
everything else follows from that

1565211858
Tetralux
.. and the stack frame of the async fn, is just it's promise?

1565211871
andrewrk
the concept of "promise" is deleted

1565211879
andrewrk
`anyframe->T` is the type you can await

1565211893
andrewrk
which is a pointer to a frame of a function which has return type T

1565211914
Tetralux
.. and is the type that you get back from 'async f()' which can be awaited or cancelled.

1565211927
andrewrk
from async f() you actually get a @Frame(f)

1565211943
andrewrk
but you can implicitly cast *@Frame(f) to anyframe->T where T is the return type of f

1565211959
andrewrk
@asyncCall returns a anyframe->T

1565211970
andrewrk
because that one lets you call async function pointers

1565211980
mikdusan
here's a frame put on heap:

1565212042
fengb
andrewrk : I found an edge case where I want a @call(). The compiler is inlining incorrectly, so I want release-small to force @noInlineCall(), but I don't have a default fallback for non-small variants

1565212082
andrewrk
fengb, that's a good use case

1565212125
fengb
Should I write up a proposal?

1565212132
andrewrk
I think we can solve this by making inline and noinline calling conventions, and having @call let you choose a calling convention from an enum

1565212163
andrewrk
fengb, related:

1565212185
andrewrk
hmm maybe not. yeah a proposal would be welcome

1565212341
mikdusan
so if a fn has suspend keyword, what happens if it is call'd just like a good'ole regular function without `async` keyword?

1565212348
mikdusan
*fn body

1565212399
andrewrk
mikdusan, then it makes the calling function also be an async function

1565212402
Tetralux
Turns the fn async, and gives an error along the lines of "must cancel or await" ?

1565212423
Tetralux
Or no - it's fine - because defer just don't get run right.

1565212430
Tetralux
defers*

1565212441
andrewrk
when you call an async function (without the async keyword), that's the same thing as doing `await async foo();` which is a particularly efficient way to call an async function

1565212477
andrewrk
it works like a normal function

1565212530
Tetralux
Presumably, 'await async f()' means "suspend myself, run f(), give me the result and resume myself", essentially.

1565212544
Tetralux
And by "means", I mean "does." xD

1565212770
Tetralux
Hmmm. What circumstance would you want to NOT cancel or await?

1565212798
Tetralux
Surely you'd always want defers to be run upon asyncfn completion, no?

1565212831
mikdusan
i am amazed at how much is going into zig 0.4.0 -> 0.5.0

1565213034
nrdmn
will #786 (better handling of error set integer type) be going into 0.5.0?

1565214054
gamester
andrewrk: The idea of detecting unused functions and raising a compile error on them is interesting. I imagine the experience is going to be very varied when testing out ideas as sometimes the unused functions are behind an import which can be commented out, and sometimes they aren't which would then entail hunting down a chain of functions to comment out. Once you comment a line out, you have to comment out a function, which would then make

1565214054
gamester
another function not called and you'd have to comment it out, and so on.

1565214138
Tetralux
Yeah - that'd be fatal for me.

1565214183
Tetralux
"Dead code elim except for exported functions" + 1

1565214189
Tetralux
+1*

1565214295
dimenus
does the std lib have any kind of generic lexer? eg expectChar (or rune)..

1565214472
mikdusan
dimenus: std.mem has tokenize() and separate() for some basic stuff

1565214477
Tetralux
+1*

1565214488
Tetralux
Whoops, wrong window lol

1565216485
emekankurumeh[m]
andrewrk: so without `try` in `defer` blocks, an async function deallocating its own frame would look like `allocator.destroy(@frame()) catch unreachable`?

1565216810
mikdusan
allocator.destroy() doesn't return an error

1565217854
emekankurumeh[m]
ohhh, that makes a lot more sense

1565221724
fengb
I can't alias a builtin function? `const smallNoInlineCall = @noInlineCall;`

1565222103
scientes
fengb, i didn't even know we could alias regular functions

1565222128
emekankurumeh[m]
that works fine

