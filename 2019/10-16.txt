1571188447
pixelherodev
What text editors have the best support for Zig? e.g. I use Geany, but it has zero support at the moment and I'm not starting yet another side project to change that

1571188677
andrewrk
vscode, vim, sublime, emacs

1571188698
andrewrk
you're not going to find type-aware auto completion in any editor yet

1571188805
tgschultz
gruebite see 1268 and 1669 for current state of discussion on traits

1571188896
pixelherodev
I was honestly just thinking of

1571188898
pixelherodev
It's so awkward having colorless text all of a sudden

1571189064
tgschultz
I use Notepad++ and distribute a UDL for highlighting, but that's Windows only

1571189200
tgschultz
speaking of which, doccomments are in a different color now so it looks even more like unicorn vomit than ever

1571189229
andrewrk
just as advertised

1571189336
pixelherodev
I might use Notepad++ for it - could you link me the UDL file?

1571189355
pixelherodev
(I have Notepad++ along with other useful utilities on a USB, and I run them through WINE when the occasion calls for it)

1571189367
pixelherodev
Terrible solution, but in the short term it's probably easier to set up

1571189542
andrewrk
what library for syntax highlighting does geany use?

1571189558
andrewrk
if it were e.g. pygments then you could update to the latest version to gain zig support

1571190196
tgschultz


1571190205
tgschultz
that's the notepad++ udl. I just updated it

1571190217
tgschultz
fair warning, looks like this:

1571192168
pixelherodev
Scintilla, apparently

1571194002
companion_cube
like, wow, light background?!

1571195698
pixelherodev
:P

1571195888
torque
doesn't notepad++ also use scintilla

1571195947
pixelherodev
...huh. So it does.

1571196094
pixelherodev
Not that it matters

1571196102
pixelherodev
UDL is np++-specific IIUC

1571196114
torque
unfortunate

1571199601
kurufu
Is it possible to know the type of ... args? I would like to have a function that takes variable args and a callback of the same arguments as what was passed in.

1571199954
kurufu
and be able to call that callback with the given args. Both of which im not sure are possible.

1571205065
andrewrk
a little bit better:

1571205096
andrewrk
this still doesn't have any of the more sophisticated type merging that I have planned

1571205229
andrewrk
the links don't work yet either on those generic types

1571206228
ntgg
oh jeez those are some fast docs!

1571208478
daurnimator
andrewrk: one example there `array_list.AlignedArrayList(...` array_list isn't mentioned anywhere

1571208632
andrewrk
daurnimator, they're all AlignedArrayList. #3406 and #3404 are still open

1571208881
daurnimator
andrewrk: but the examples section is really cool!

1571209566
muffindrake
Yello!

1571209688
bgiannan
So the rewrite of my game is Zig is going well:

1571209721
daurnimator
andrewrk: idea: add a "see also" section that includes links to other structs/methods that link to the current one.

1571209919
muffindrake
bgiannan: Presumably you're using SDL to get around the platform window stuff? What do you use to draw?

1571210681
bgiannan
muffindrake, everything is done with SDL, the graphics are really simple

1571210706
muffindrake
bgiannan: Oh, so it's just SDL's graphics drawing. That's fine.

1571210729
bgiannan
yeah don't need much else right now

1571210770
muffindrake
I've heard about Zig about 3/4 of a year earlier, but it didn't seem too interesting to me at the time. Is there a comprehensive resource I can use to get started with, being mostly a C programmer?

1571210816
muffindrake
I suppose I'll scour

1571210828
bgiannan
yes that's pretty much all you need

1571210993
pixelherodev
Yeah, Zig is really really neat. I've been working on a C project for a few hours and there were so many times I wished I could switch to Zig

1571211268
telemach
bgiannan: just curious, rewrite to Zig from which language?

1571211283
bgiannan
telemach, from lua (l√∂ve 2d)

1571211327
muffindrake
Ah, that's quite a slow library, yeah

1571211331
pixelherodev
Does that use LuaJIT?

1571211355
bgiannan
yes it does

1571211418
pixelherodev
Could be worse then :P

1571216096
gustav_o
hi everyone

1571216154
gustav_o
how do I use b.standardTargetOptions(null)? I can't seem to supply -target to my `zig build -target x`

1571216196
gustav_o
found it, sorry spoke to soon (`-Dtarget=x`)

1571217143
gustav_o
andrewrk: Do you know of the top of your head which libc folder `zig cc ... -target wasm32-unknown-emscripten-musl` will result in? This is what gets supplied when I specify When I supply `-Dtarget=wasm32-emscripten`

1571217246
gustav_o
I wanted to see if I could compile the sokol libs to wasm32 as you said yesterday. Please bear in mind that I'm new to this kind of low level stuff :)

1571218098
mq32
<andrewrk> you're not going to find type-aware auto completion in any editor yet

1571218134
mq32
that's not completly true. ceymard has written a vscode module that provides at least

1571220477
muffindrake
I see that you can make arbitrarily-sized integer types, up to a bit length of 2^16 - 1. Is there some reason for this choice, or is it merely an implementation limit right now?

1571220902
mq32
muffindrake, afaik it's an LLVM limit

1571224304
daurnimator
muffindrake: do you have a use-case for something bigger?

1571224336
muffindrake
No, I was simply curious

1571224371
muffindrake
Besides that, is there an existing implementation of arbitrarily-sized integers in zig that we can use?

1571224522
daurnimator
do I recall tgschultz having one?

1571224568
mikdusan
math.big.Int

1571225071
tgschultz
daurnimator you might be recalling my work on PackedIntArray/Slice.

1571225114
gustav_o
Hmm.. seems like referencing c code in a comptime expression falls into an infinite loop?

1571225440
gustav_o
or it seems to happen when I include the same headers from different files

1571225682
gustav_o
putting all cImports into a c.zig and exposing declarations with `usingnamespace` does not infinite loop

1571225701
gustav_o
Even if c.zig is imported and used in multiple places. Does anyone know why?

1571226881
bgiannan
did someone built a zig program with sdl on windows?

1571226901
tgschultz
a few of us have, yes. long time ago for me.

1571226937
bgiannan
do you have gist of it?

1571227065
tgschultz
Not on hadn, it would be outdated anyway. Anything specific you're trying to do? I think the consensus is that the easiest way to use it is to translate-c the header and import the result, modifying as necessary.

1571227083
tgschultz
I can paste what I have quick, but it'll be about 2 zig versions behind so no guarantees.

1571227261
bgiannan
i was hoping too still be able to link with libc and use cImport (am i right in thinking cImport == needing libc?)

1571227306
tgschultz
cImport just means you're using C code, it doesn't necessarily link to libc (which is unnecessary for SDL2, IIRC)

1571227344
bgiannan
huh i had `exe.linkSystemLibrary("c");` for no reason...

1571227366
bgiannan
so if i don't need that i can try and use the msvc version of SDL2

1571227489
tgschultz
yeah, that's what I used. Though I did try the mingw version first and had all sorts of trouble with it. But, zig's support for mingw was worse back then.

1571227490
tgschultz


1571227536
tgschultz
I just copy-pasted really old code there. No guarantees. Someone else probably has newer examples

1571227578
bgiannan
i use @cImport, not sure what's your SDL2.zig

1571227579
tgschultz
the build line just had to add --library "SDL2.lib"

1571227584
bgiannan
ah

1571227593
bgiannan
SDL2.lib, that's the file it needs

1571227644
tgschultz
So cImport translates C to zig internally. You can dump the output of that process, which is handy if the translation doesn't quite work right because you can hand edit it. That's what SDL2.zig is

1571227673
bgiannan
worked fine for me, i had to rewrite some missing macros but that's about it

1571227678
tgschultz
I don't know if it is still true, but there used to be a few parts of SDL that didn't translate properly.

1571227893
bgiannan
actually

1571227920
bgiannan
removing the libc bits works on macOS because it always links against libc on macOS

1571227939
bgiannan
but when targetting windows it does complains about libc missing when using cImport

1571227969
tgschultz
strange. I definitely didn't have to link C

1571227989
bgiannan
/Users/giann/git/zsettlers/src/sdl.zig:17:17: note: libc headers not available; compilation does not link against libc

1571227991
bgiannan
pub const sdl = @cImport({

1571228166
bgiannan
is mingw the `gnu` abi?

1571228254
tgschultz
I think so

1571228990
bgiannan
ok i maybe have something that will work, it seems to only fails now because it's trying to find windows symbols and i'm doing this on macOS.... maybe i need a msvc dll or something

1571229022
bgiannan
scratch that last bit i'm not usign the msvc abi

1571229044
daurnimator
you would still need the windows SDL2.lib file though?

1571229242
bgiannan
i do have it, the mingw one

1571229327
bgiannan
here's what i have so far

1571229781
bgiannan
looking at my old windows/SDL game i had things like: `-lmingw32 -lws2_32 -mwindows`

1571230276
bgiannan
andrewrk, when you're around i'd love your help with this

1571232654
gustav_o
hmm.. I wonder how to go about handing errors in zig functions that are called from c-code..

1571232939
fengb
Same way as C functions: error codes or some other convention. You can‚Äôt export error unions

1571233095
daurnimator
would be cool to have a convention though

1571233128
fengb
Well it‚Äôs C. So error codes or errno :P

1571233138
daurnimator
not always

1571233160
daurnimator
e.g. openssl usually has an error code per function

1571233248
daurnimator
I think something that iterates `@typeInfo(myerrorset).ErrorSet` assigning numbers/offsets. then you could provide a reverse mapping. and also a offset->string via @errorName

1571233281
daurnimator
oh Error actually has a `value: comptime_int` field

1571233329
mq32
daurnimator, i don't think it's reasonable to use that value as it may change when new error values are introduced

1571233371
daurnimator
mq32: that's fine: the value would only be suitable for passing back to a library-exported "error-number-to-errorstring" function

1571233408
companion_cube
file:///home/simon/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/std/primitive.never.html oh btw, about the empty type

1571233412
companion_cube
gaaah

1571233421
daurnimator
companion_cube: traitor ;)

1571233440
companion_cube
file:///home/simon/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/std/primitive.never.html actual URL

1571233456
companion_cube


1571233465
companion_cube
nah, I just think it's a neat pattern :p

1571233499
daurnimator
companion_cube: looks like zig's noreturn

1571233540
daurnimator
or just the empty error union `error{}`

1571233734
companion_cube
yes, exactly

1571233753
companion_cube
but the point I emphasize is how it behaves in sum types^W^W tagged unions ;)

1571233869
gustav_o
Regarding the c errors... I use a library that calls into my zig code to draw each frame of a game. Ideally I want this zig function to be able to throw errors but then I need to figure out how to do custom error passing through the C side?

1571233928
mq32
companion_cube: seems pretty similar to zigs noreturn

1571233951
mq32
for Result<!,E> you should be able to create error{}!noreturn

1571234082
companion_cube
sure

1571234144
mq32
oh damn.

1571234153
mq32
i will do a bug report :D

1571234160
mq32
my code will out-of-memory the zig compiler

1571234171
mikdusan
get more memory :)

1571234180
mq32
aren't 32GB enough?

1571234275
fengb
gustav_o: you can export a wrapper function that manually maps the errors to static values

1571234363
gustav_o
fengb: I'm thinking of something like `myZigCode() catch |err| { global_var = err; doLogicToThrowErrorAndQuit(); }`. Is this what you meant?

1571234427
gustav_o
I forgot to say that the c-code that calls zig-code is in turn called by zig-code, so I can return the error at the outer-most point, probably

1571234488
fengb
Ick that doesn‚Äôt sound very pleasant >_>

1571234626
gustav_o
you're right :)  but the impact is fairly limited. All of the game is written in zig and this is for the native window management.

1571234627
daurnimator
gustav_o: `extern fn foo(a: i32, b: i32, result: *R) usize { if(myzigfoo()) |r| { result = r; } else |err| { return @errortoInt(err); } }; extern fn errorToString(err: usize) []const u8 { return @errorName(@intToError(err)); }`

1571234647
daurnimator
^ I'd probably play with that sort of construction

1571234696
gustav_o
daurnimator: Thanks!

1571234803
gustav_o
do you know of a way to save the error trace as it's printed?

1571234940
daurnimator
gustav_o: maybe @errorReturnTrace() will work in that wrapper function there? however you'll probably end up using std.debug.dumpStackTrace or its friends

1571234982
mq32
companion_cube: thanks for this:

1571235046
mq32
daurnimator, you are fast :D

1571235287
gustav_o
daurnimator: So I can save @errorReturnTrace after I'

1571235310
gustav_o
ve cathed an error and then in my outer zig code dump it in order to print?

1571235328
gustav_o
*catched

1571235386
daurnimator
gustav_o: sorry I don't know; and I don't even have any examples of using @errorReturnTrace. so you might have to play...

1571235406
gustav_o
no problem, thanks for the hint. I'll try!

1571235423
daurnimator
gustav_o: oh wait; see std/special/start.zig

1571235448
daurnimator


1571235505
gustav_o
perfect, thanks!

1571235744
daurnimator
gustav_o: you can also just stash away that stack trace in your "error struct" and export another function that allows the user to print it when they want

1571236084
mikdusan
is `!noreturn` even supposed to be a real thing?

1571236185
daurnimator
mikdusan: I don't see why it shouldn't: you might have a function that can throw an error or otherwise e.g. calls exit()

1571236188
fengb
Not noreturn üôÉ

1571236415
companion_cube
mq32: :DD

1571237715
mq32
mikdusan: the rust article posted by companion_cube explains it quite good

1571237757
mq32
"!noreturn" is "i have something that either runs endless or errors

1571237808
tgschultz
I keep getting bitten by capture+result location

1571238286
tgschultz
#2915 that is

1571240461
bgiannan
do i need to build zig myself to run it on mingw? the windows binaries complains about a missing unkowned shared object file

1571240860
tgschultz
hmmm: link: `could not find .def file to build opengl32`

1571240880
tgschultz
said `.def` is in the same directory as main.zig and is also the cwd

1571240944
andrewrk
mq32, nice, that's good to know about ceymard's vscode module

1571241009
bgiannan
nevermind i was missing visual c++ redistribuables

1571241026
andrewrk
bgiannan, need help with something?

1571241053
bgiannan
andrewrk, yes i'm trying to build my game (SDL2) on windows

1571241100
bgiannan
i have this so far

1571241121
andrewrk
are you using vcpkg?

1571241132
bgiannan
i don't know what that is

1571241159
tgschultz
did something change recently regarding building lib stubs for dlls or something?

1571241166
andrewrk
never mind that. are you interested in setting up your project for cross compiling to windows?

1571241174
andrewrk
tgschultz, yes

1571241202
andrewrk
tgschultz,

1571241208
bgiannan
andrewrk, i'm interested in being able to build it for windows, doing it from another system is not the goal

1571241243
andrewrk
bgiannan, you shouldn't need the windows option then; the default target is native

1571241251
andrewrk
you can detect whether the native target is windows

1571241265
bgiannan
right my first test were on macOS

1571241302
andrewrk
const target = b.standardTargetOptions(null); if (target.isWindows())

1571241315
andrewrk
oh and don't forget exe.setTheTarget(target);

1571241369
andrewrk
start with that, and none of the include dir/lib path stuff, and let me know what error you hit

1571241379
andrewrk
tgschultz, did something regress?

1571241390
bgiannan
alright

1571241472
bgiannan
andrewrk, right so it complains about missing libc. So related question -> do I need to link against libc for @cImport to work?

1571241521
andrewrk
can I see the output?

1571241530
tgschultz
andrewrk: possibly. If I'm reading 3434 correctly this is actuall intended? On Windows (64bit), using `extern "opengl32"`I never had to provide anything in the past and zig would just create and link a stub on its own. Now it appears that isn't the case.

1571241593
bgiannan
andrewrk,

1571241631
bgiannan
build.zig being

1571241651
andrewrk
tgschultz, I believe opengl32 (and maybe more) need to be added to a list of things that zig can provide. I'll be happy to do that now

1571241693
tgschultz
no rush. this isn't really code I care about in the near term.

1571241723
andrewrk
bgiannan, there's some issue with detecting your installation of MSVC

1571241731
tgschultz
but I do have defs already, from previous builds. how would I specify zig should use them?

1571241755
bgiannan
andrewrk, i was going on the route to do it with mingw, since i though libc was required

1571241808
andrewrk
bgiannan, I see, this is why you target  x86_64-windows-gnu. Yes that should make zig pick up libc

1571241857
bgiannan
right and i believe i just miss some libs to link against since it then complains about missing symbols like __imp_XXXXX

1571241884
bgiannan
probably some windows libs ?

1571241912
andrewrk
every time you ask about an error, I need to see the actual output rather than a summary

1571241922
bgiannan
yeah sorry 1sec

1571241924
andrewrk
no prob

1571241954
bgiannan


1571241994
andrewrk
where did you get your libSDL2.a from?

1571242031
bgiannan


1571242056
tgschultz
oh nevermind, I can probably just link the generated lib file from before.

1571242078
andrewrk
bgiannan, oh I think you need to additionally link these system dlls

1571242110
andrewrk
for each undefined symbol, look up which dll it's in and linkSystemLibrary("winmm") etc

1571242129
bgiannan
makes sense so i was on the right track

1571242136
andrewrk
yeah, sorry it took me a minute to catch up

1571242145
bgiannan
will it find them on its own or do i have to point it to the right dll

1571242148
andrewrk
unfortunately, zig has no way to look at libSDL2.a and learn which dll dependencies it pulls in

1571242172
andrewrk
for system libraries, zig will actually provide them, you just need the name, as in the example above

1571242391
andrewrk
tgschultz, anything else besides opengl32?

1571242460
tgschultz
not that I use currently.

1571242482
tgschultz
but I can get you a list of what is in win32.zig

1571242602
bgiannan
andrewrk, so `__imp_PropVariantClear` seems to be in comctl32.dll which i have on my system, but zig can't seem to find it. SHould i manually add it? if so how?

1571242754
andrewrk
tgschultz, master branch has cross compiling support for opengl32.dll now. let me know if you hit anything else, it's easy to add. maybe it's a good idea to add all the dlls from mingw-w64, but I'm not ready to make that decision right this minute

1571242773
andrewrk
bgiannan, ok that's another one I'll add right now ^

1571242825
tgschultz
andrewrk: here is what I have defined in win32.zig, which should be anything the win32 api touches.

1571242968
andrewrk
if I add everything from mingw-w64, it's 7 MiB (1.2 MiB gzipped)

1571242981
andrewrk
that's probably a reasonable trade off

1571243099
andrewrk
I'll start with this list provided by tgschultz for now

1571243231
bgiannan
that's not in mingw though

1571243236
bgiannan
it's in windows itself

1571243377
andrewrk
yes these are system dlls which zig can provide the ability to dynamically link against when targeting x86_64-windows

1571243395
andrewrk
or i386, or arm 32 bit or arm 64 bit

1571243415
andrewrk
tgschultz, i'm not sure what mincore is. that one is not provided by mingw-w64

1571243774
bgiannan
andrewrk, ah yes sorry misread you there

1571243813
tgschultz
I'll see what mincore is attached to

1571243855
bgiannan
andrewrk, do i need a .def file for each missing dll?

1571243888
andrewrk
bgiannan, no. which dll is missing?

1571243933
bgiannan
comctl32

1571243978
tgschultz
mincore is a Windows 8 api, I have 4 functions listed for it: GetOsSafeBootMode,WaitOnAddress,WakeByAddressAll,WakeByAddressSingle

1571243984
tgschultz
What is our minimum supported Windows ver?

1571244074
muffindrake
Are bare metal targets supported? How about 8-bit Sharp LR35902?

1571244146
nrdmn
muffindrake: bare metal targets are supported.

1571244179
bgiannan
andrewrk, maybe i need mingw-w64 ?

1571244286
andrewrk
bgiannan, you just need to pull latest zig master and rebuild

1571244313
andrewrk
tgschultz, Windows 7 is the minimum

1571244326
andrewrk
muffindrake, see

1571244368
bgiannan
andrewrk, ah thanks i'll wait for the binary to be on ziglang.org, never tried building zig on windows yet

1571244377
andrewrk
should be about 1-2 hours

1571244419
muffindrake
Welp, no z80 here. Too bad!

1571244437
tgschultz
llvm doesn't support any 8-bit archs as far as I'm aware

1571244455
bgiannan
andrewrk, perfect thanks for the help!

1571244463
muffindrake
Ah, yes, I was reading about that.

1571244481
andrewrk
tgschultz, all the libs in your list except mincore are now available in master branch

1571244788
tgschultz
cool, thanks

1571245183
andrewrk
anyone else blocked and need some help?

1571245379
andrewrk
gustav_o, I wonder how many bytes it would cost to provide emscripten's libc for -target wasm32-emscripten

1571245413
nrdmn
andrewrk: I'm documenting UEFI structs and functions. Can I copy & paste function descriptions if they're no longer than one or two sentences?

1571245424
nrdmn
copy & paste from the spec*

1571245698
andrewrk
that should be ok

1571245841
muffindrake
Is it currently possible to switch on anything but integers? How about strings?

1571246139
andrewrk
muffindrake, not possible

1571246765
sossy
Apologies for beginner question, but the designated assignment syntax p = { .a = 1, .b = 2}; only works for one level deep, right? I can dig down mutiple structs one statement at a time, but was attempting to find a less redundant way to assign a struct within struct.

1571246823
andrewrk
it works for any number of levels

1571246876
sossy
So p = { .a.c = 1, .a.d = 2}; should work?

1571246956
mq32
no, but p = { .a = A { .c = 1, d = 2 } }

1571247065
andrewrk
if you want to leave some fields uninitialized, use `undefined`

1571247886
sossy
I'm sure I'm missing something obvious

1571247896
sossy
const Td = struct { a: i32 = 0 };const T = struct { const D = Td; };export fn main() void {    const t = T;    t = {        .D = Td {            .a = 1        };    };}

1571247927
sossy
That minimal thing gives error: type '(enum literal)' does not support struct initialization syntax

1571248115
tgschultz
`const t = T` makes `t` a value of type `type` identical to `T`

1571248166
tgschultz
`var t: T = undefined; t = {....}`

1571248220
tgschultz
but you don't even need to declare T undefined. just do `const t = T{ .D = Td { .a = 1}, };`

1571248311
tgschultz
oh, your struct def is wrong too

1571248321
tgschultz
at least for how you're initializing it

1571248368
sossy
I was suspecting, cause what you told now gave error: no member named 'D' in struct 'T'

1571248371
tgschultz
`const T = struct { const D = Td; }` means "create an empty struct and place within its namespace a constant 'D' that is a type identical to Td"

1571248407
tgschultz
`const T = struct { D: Td, }` creates a field named 'D' in the struct.

1571248473
sossy
Thank you, I had wondered all over trying to change different parts to get it to work

1571248498
tgschultz
structs contain both fields and decls. fields are struct members that can vary for each instance of the sturct (just normal every day struct fields really), but decls are variables and constants within the namespace of the struct type itself.

1571248498
sossy
So at some point the declaration switched to const

1571249039
tgschultz
andrewrk, is there a known issue with result location and doing things like `x = x.func();` where `func()` does not modify x?

1571249079
andrewrk
tgschultz, in this case func() will be modifying x with the `return` statement

1571249106
tgschultz
so `x = x.func()` is now also a footgun

1571249110
andrewrk
yes

1571249117
tgschultz
wonderful

1571249124
andrewrk
in this case the result location aliases the first parameter

1571249145
andrewrk
which is planned (pending research) to be illegal

1571249249
tgschultz
so I should really get into the habit of explicitly copying everything I guess

1571249271
andrewrk
that's the idea, nothing is copied unless you make a copy

1571249299
nrdmn
should I add `test` statements just so docs are generated from my comments? Or will this not be necessary in a later version?

1571249307
andrewrk
tgschultz, however, your characterization of this as a footgun is accurate, and my goal is for there to be no footguns in the language before it becomes stable

1571249332
andrewrk
I don't consider status quo with regards to result locations to be anywhere close to acceptable for 1.0 status

1571249386
andrewrk
however the progress on result locations is important, and closer to where we need to be than before

1571249508
andrewrk
nrdmn, that's something I'm still figuring out. you'll definitely need to reference all the imports so that the files get looked at

1571249518
tgschultz
sure, and I don't even mind the explicit copying really, it's just that we're in a state where the compiler isn't catching it and that makes it non-obvious what went wrong

1571249557
andrewrk
I agree. one of the big goals for this release is safety

1571249589
andrewrk
safety and making it obvious when something goes wrong are the same thing to me

1571249838
andrewrk
it's a footgun either way btw, although I'll agree that the newer one is worse. the previous one is that a copy might move a "pinned" field

1571249878
andrewrk
we don't have pinned fields yet, but now the language semantics are even capable of dealing with them correctly

1571250046
Sahnvour
do you consider double optionals (??T) a code smell ?

1571250483
pixelherodev
... double optionals?

1571250708
tgschultz
I am really curious about the usecase for that one

1571250738
tgschultz
seems like you might want a custom union{enum{}, T}

1571250779
tgschultz
er.. you know what I mean. A union with two void fields and one typed one

1571250815
Sahnvour
let's say I have an operation that can return a result or null (in case of failure) ; and this operation's result will not change during the program, however I'd like to know if I already attempted it

1571250866
Sahnvour
tgschultz: interesting

1571251018
tgschultz
Personally I'd do the custom union thing. union{ .Failed: void, .Unattempted: void, Value: T, }

1571251243
Sahnvour
yeah that looks nice

1571251263
Sahnvour
thanks

1571251743
andrewrk
!noreturn would be the return type of std.os.execve

1571252268
pixelherodev
Inline assembly is a pain. "Error: invalid operand for instruction" "outb %dx, %al". This'll take a few hours...

1571252335
andrewrk
bgiannan, the new build is up

1571252351
bgiannan
andrewrk, yes on it :)

1571252419
bgiannan
andrewrk, do you have a better that googling symbols to find out in which dll they are?

1571252423
bgiannan
method*

1571252440
andrewrk
nope

1571252474
andrewrk
bgiannan, it's probably these:

1571252500
bgiannan
ah right saw that this morning

1571252568
Sahnvour
bgiannan: if you're talking about windows functions, you can look at the associated msdn page, it will list the header and dll where it's located

1571252587
pixelherodev
The correct way to refer to an input in an asm block is %[INPUTNAME], where INPUTNAME is the name given in the input constraints section, correct?

1571252652
bgiannan
andrewrk,

1571252654
pixelherodev
Is there a problem with referring to registers less than 32-bits?

1571252680
pixelherodev
That game looks awesome

1571252684
andrewrk
bgiannan, beautiful

1571252699
bgiannan
:)

1571252705
pixelherodev
Is that extended ASCII?

1571252753
bgiannan
pixelherodev, that's a bitmap codepage 437 font

1571252753
companion_cube
looks like dwarf fortress :)

1571252765
bgiannan
yeah same charset as dwarf fortress

1571252805
bgiannan
i'm rewriting:

1571252822
tgschultz
bgiannan, andrewrk: when creating the win32 package I wrote a script using dumpbin and every dll in system32.

1571253333
pixelherodev
okay i'm losing my mind here. Anyone know why "outb %dx, %al" would be rejected?

1571253336
Sahnvour
tgschultz: void types in a union have to be initialized with `TheUnion{ .Field = {} }` correct ?

1571253362
tgschultz
yeah. you could also use u0 instead of void and set it to 0

1571253693
andrewrk
pixelherodev, duplicate the %%

1571253706
pixelherodev
Nah, I figured it out. I had the operands backwards :P

1571253715
pixelherodev
It's %al, %dx; not %dx, %al

1571253748
andrewrk
if the zig project takes on the task of an assembler we can have better syntax and error messages for inline assembly

1571253756
andrewrk
it's a big project though

1571253764
pixelherodev
Yeah, especially given the sheer number of targets

1571253786
pixelherodev
Though a simple table format isn't impossible

1571253966
pixelherodev
When you @import a file, are its functions compiled as part of the current compilation unit?

1571254081
andrewrk
pixelherodev, the top level declarations are noticed; functions and variables are ignored unless referenced. comptime blocks are executed

1571254120
andrewrk
the `export` keyword or `@export` builtin forces a function to be exposed in the object

1571254123
pixelherodev
If a function is used though, it's merged into the current unit?

1571254128
andrewrk
yes

1571254131
pixelherodev
Ah

1571254138
pixelherodev
That explains the "duplicate symbol" error :P

1571254181
andrewrk
does it? are you exporting a library or an executable?

1571254248
pixelherodev
This is for the kernel. Each file is built on its own, but some of them @import others, so `export`ed functions and symbols get duplicated

1571254259
andrewrk
I see

1571254280
andrewrk
why have more than one compilation unit?

1571254288
pixelherodev
Habit?

1571254298
pixelherodev
Didn't realize there were any reasons

1571254311
andrewrk
I think you will have a smoother ride if you do a single build-exe from a root source file that imports the other ones

1571254322
pixelherodev
So I've noticed

1571254333
pixelherodev
How big does a file have to grow before that becomes a performance issue?

1571254406
andrewrk
in zig land there are plenty of reasons: * better optimization (equivalent or better than LTO) * compiler is aware of all source files when linking; can help with diagnostics and codegen * theoretically faster builds

1571254431
pixelherodev
*Faster*?

1571254452
pixelherodev
Anyways, good to know; time to untangle the kernel :)

1571254457
andrewrk
yes, if you don't force separate objects, the compiler is free to do its own separation, integrated with incremental building & linking

1571254469
Sahnvour
andrewrk: just a thought, the test suite knows how to use wine and qemu, it could also learn to use WSL (if present on windows) to have linux, linux+qemu and even linux+wine from a windows box :)

1571254470
pixelherodev
...

1571254482
andrewrk
pixelherodev, that is vaporware though; there's a proof-of-concept in the self-hosted compiler but stage1 does not have this capability

1571254501
andrewrk
hence "theoretical". but if your project grows slowly enough, zig will gain this ability before your project build becomes slow :)

1571254510
pixelherodev
Alright thanks for the info

1571254512
andrewrk
Sahnvour, I was thinking the same thing :)

1571254524
andrewrk
-Denable-wsl

1571254540
pixelherodev
regarding the self-hosted compiler, does that still depend on LLVM?

1571254548
mikdusan
also afaik, Zig is really good at doing work only once - ie: the cost of the same templates spread across multiple units in C++ is completely avoided

1571254587
Sahnvour
that'd be cool

1571254615
andrewrk
yeah. for an OS project that is beginning right now, single compilation unit will be just fine. larger projects (e.g. the size of linux) would not be possible with stage1 but that is a use case I have in mind for self-hosted

1571254745
andrewrk
stage1 just has to get self-hosted into orbit :)

1571254861
donpdonp
maybe zig needs a "starship operator" syntax :)

1571255157
fengb


1571255246
pixelherodev
Yeah, single compilation unit is actually much easier

1571255248
pixelherodev
Thanks for the tip!

1571255301
andrewrk
pixelherodev, no problem, and in case you were unaware, you can use comptime logic to selectively @export. see for example

1571255326
pixelherodev
I knew that actually :) Comptime is amazing

1571255496
pixelherodev
If e.g. two `u4`s are used in a packed struct, will the struct actually use eight bytes?

1571255500
pixelherodev
I mean

1571255502
pixelherodev
One byte

1571255511
daurnimator
pixelherodev: yes

1571255515
pixelherodev
Thanks

1571255623
nrdmn
proposal: it should be possible to specify a minimum alignment for types (not only for structs, but for all types in general)

1571255815
daurnimator
nrdmn: I'm not sure that makes sense for non-extern things

1571255855
daurnimator
nrdmn: given that memory layout of enums/structs/unions in zig isn't defined for non-extern... what would alignment on the type do?

1571255936
nrdmn
hmm... s/all types in general/extern and packed types/

1571255947
nrdmn
s/minimum/default/

1571255967
daurnimator
nrdmn: so the thing about extern and packed types; is that you can add the alignment requirements to the relevant members.

1571256000
nrdmn
if the type has members, yes

1571256005
nrdmn
but what if it is an enum?

1571256036
nrdmn
or a pointer?

1571256098
daurnimator
nrdmn: an extern enum has the alignment of the underlying ABI type; which is ABI-defined

1571256213
nrdmn
I can imagine there may be reasons to have a different, specific alignment in some cases

1571256217
andrewrk
Sahnvour, so you'd rather stick with MSVC2019 for now, is that correct?

1571256234
andrewrk
with regards to #3430 and rebuilding the tarball

1571256237
daurnimator
nrdmn: then its probably not an extern enum any more :P

1571256766
pixelherodev
What's the correct way to cast from a u8 to a bitfield (packed struct)?

1571256786
pixelherodev
Manual assignment of each component using bitshifting? Is there some sort of explicit cast?

1571256825
bgiannan
@ptrCast ?

1571256831
andrewrk
pixelherodev,

1571256833
pixelherodev
Not a pointer :P

1571256838
pixelherodev
Thanks!

1571256840
bgiannan
that's the one

1571257365
Sahnvour
andrewrk: yes, technically we're not bound to a particular compiler, just making it easier by providing prebuilt llvm for this one

1571257593
andrewrk
I see, ok

1571257630
andrewrk
I'll include LLD in this one since we no longer have any outstanding patches

1571257642
andrewrk
that might shorten Windows CI time a bit

1571257737
Sahnvour
okay

1571258855
andrewrk
nrdmn, give me a few more days for this multibuilds docs stuff, and you'll be able to see your fresh docs in the generated html

1571259773
andrewrk
holy cowabunga, qemu-devel is a high volume mailing list

1571260370
FireFox317
I got some basic completion support working for functions in vscode using the new dump-analysis functionality:

1571260425
andrewrk
oh! statx is the thing that can make the std lib event loop smarter with regards to parallel file system access!

1571260454
andrewrk
it can at least tell the device major/minor id of a file descriptor

1571260459
emekankurumeh[m]
you've piqued my interest.

1571260479
andrewrk
FireFox317, nice!

1571260541
emekankurumeh[m]
is that something specific to VSCode FireFox317?

1571260575
emekankurumeh[m]
also why do i keep getting projects involving schedulers in my feeds?

1571260892
FireFox317
emekankurumeh[m], not vscode specific. It is a LSP server and in theory every IDE that has a LSP client should be able to use that

1571260937
ceymard
FireFox317: sweet

1571260946
ceymard
I'm sad though

1571260962
ceymard
I've been working on a JS based solution but you beat me to it

1571261040
FireFox317
ceymard: well, it is really basic now and not ready to publish yet :) I implemented the server in Zig

1571261073
ceymard


1571261112
ceymard
well, the gripe I had with dump-analysis is that it wasn't very resiliant to malformed files

1571261130
ceymard
also, I sensed that completing in the same file was gonna be hard

1571261138
FireFox317
Nah, you beat me to it haha, I'm not that far yet

1571261158
ceymard
I've been at it for a while though :)

1571261183
ceymard
the good part is I've built a correct understanding of what would be needed to have a forgiving parser

1571261199
ceymard
so I might look at working on the stage2 parser to that end

1571261238
FireFox317
Ah cool! I really just started on this two days ago

1571261308
FireFox317
Yeah, we need a forgiving parser for sure, isnt the current self-hosted parser not such a forgiving parser?

1571261346
andrewrk
the current self-hosted parser bails out on first error

1571261380
ceymard
I had to write my own parser to achieve what I'm doing

1571261381
andrewrk
I think a parser intended to be used in an IDE should take advantage of whitespace as a heuristic to correct parse errors

1571261411
ceymard
andrewrk: I had a different approach

1571261422
ceymard
I basically "allow" some nonsense

1571261432
ceymard
for instance, I don't require binops to have a right hand side

1571261441
ceymard
useful for <ident>. --- ?

1571261473
ceymard
whenever I sense something is awry, I just go to the end of a statement or block and ignore everything

1571261492
ceymard
I guess a way of doing could be creating error nodes

1571261512
ceymard
which could get into the ast

1571261528
ceymard
during compilation, these would prevent code emitting, but not all the type checking

1571261580
ceymard
you can check

1571261595
ceymard
especially src/grammar.ts (which doesn't need much typescript understanding)

1571261697
FireFox317
Damn, that's cool! I'm really not that deep into it yet, but I'm also enhancing my Zig skills by writing it in Zig

1571261726
ceymard
yeah I ought to do that too

1571261779
ceymard
andrewrk: anyway, I don't go the "self-correcting" route, rather the "lax" route

1571261797
ceymard
and just bail on stuff that really doesn't make sense until I find something that does

1571261859
ceymard
I find it interesting that I was able to express a grammar of Zig (with AST creation !) in 600 or so lines

1571261891
ceymard
(granted, the parser doesn't intend to be correct, but still... that's not many lines - the grammar is really simple)

1571262000
Sahnvour
docs + lsp will be such a qol improvement :)

1571262201
ceymard
yes, it will for sure drive more people to the language

1571262676
Snektron
hi

1571262721
andrewrk
hi Snektron

1571262860
Snektron
andrewrk: It caught my eye that offset in structs is calculated in both bytes and bits

1571262875
Snektron
Wouldn't it make more sense to just calculate it in bits?

1571262961
pixelherodev
Got the GDT working in pure Zig :) Well, "pure" in the sense that I'm not using C for it anymore; I of course have to use inline asm for the lgdt instruction :P

1571262977
andrewrk
Snektron, there's an important difference, which is demonstrated by integer types which are not divisible by 8.

1571262988
andrewrk
u7, for example, is 1 byte, but 7 bits

1571263008
Snektron
ah you make a good point

1571263013
andrewrk
the size in bits tells how much padding there is after the actual data of the type, which is important for packed structs

1571263019
Snektron
yet for packed structs, shouldn't the offsets be defined in bits anyway?

1571263020
andrewrk
because you can put u7 and u1 in a packed struct and it will be 1 byte

1571263037
pixelherodev
Right, which means the bytes are being ignored, aren't they?

1571263049
andrewrk
the byte offset for packed struct is also important; it tells the offset of the "host integer" which contains the packed values. this matters because of endianness

1571263081
andrewrk
I think there are some bugs and issues with this; the initial implementation was done before it became clear in my mind

1571263090
Snektron
""because you can put u7 and u1 in a packed struct and it will be 1 byte" that was my problem with it, it didn't work in some cases

1571263095
Snektron
after which my friend told me off for using a compiler which can't do that

1571263122
andrewrk
this does work: @sizeOf(packed struct { a: u7, b: u1}) == 1

1571263154
Snektron
Hang on, let me try something

1571263237
pixelherodev
`: @sizeOf(packed struct { a: u7, b: u1}) == 1` can confirm :)

1571263249
pixelherodev
If it wasn't, I'd be boot looping ~~still~~

1571263317
andrewrk
packed structs which don't end with a clean byte boundary are currently buggy, but this will be fixed. it will be equivalent to e.g. u7 which also doesn't end in a clean byte boundary

1571263354
Snektron
I think the problem i had with it has disappeared :) granted i didnt look at it for some time

1571263391
Snektron
My problem was @offsetOf(packed struct{a: [3]u8, b: u32}, "b") returning the wrong value

1571263477
Snektron
Sadly the code i was working on was a small test which i didnt upload to git and then i accidently deleted it

1571264343
nrdmn
andrewrk: I'm not sure if multibuilds would make the uefi doc comments be rendered into html. I think the issue is that most structs in std/os/uefi are not referenced anywhere, even when building as *-uefi-msvc. I made a workaround in src/codegen.cpp so that for the zig_print_analysis_dump() step that generates the documentation, g->zig_target is set to x86_64-uefi-msvc. But apparently that didn't make any

1571264349
nrdmn
difference.

1571264413
nrdmn
so to test my doc comments, I wrote `test "" {}` blocks that reference everything once but don't do anything with it

1571264467
andrewrk
nrdmn, that can also be done with reflection. comptime {refAllDecls(@This());}

1571264556
nrdmn
andrewrk: why isn't it done that way in lib/std/std.zig?

1571264625
andrewrk
I'm still working on it

1571264646
nrdmn
ah, ok :)

1571264784
andrewrk
I'm thinking the merging tool will also print out a list of unreferenced symbols, which should essentially be treated as errors. all symbols should be referenced by at least one build configuration, or, in the case of a library, explicit references or tests should be added for every symbol

1571264812
andrewrk
it's planned for all this functionality to exist directly in the self-hosted compiler

1571264852
THFKA4
nooooo

1571264893
pixelherodev
How much work is needed for the self-hosted compiler to be even mildly functional?

1571264931
andrewrk
6 months ish

1571264939
nrdmn
what's supposed to happen if I put a doc comment over a `pub const Foo = @import("foo.zig").Foo;` and another over the definition of Foo in foo.zig?

1571265000
pixelherodev
Better question: what can I do to help?

1571265009
andrewrk
that's a good question

1571265028
andrewrk
you could help work on the std lib event based abstractions, making them robust and fixing bugs

1571265064
andrewrk
what's your home OS, pixelherodev?

1571265070
pixelherodev
Linux usually

1571265076
pixelherodev
Though I have windows in a VM

1571265101
pixelherodev
And running on another partition on my PC until I get around to cleaning it up and moving everything into a VM-accessible drive :P

1571265906
andrewrk
nrdmn, FireFox317, ceymard, THFKA4: I'm considering adding this rule to zig's semantic analysis: if zig looks at a struct/union/enum, then it looks at all the declarations therein. However if no declarations are referenced from a given type, then they are all omitted. I think this would be a good compromise for the downsides of lazy analysis

1571265947
andrewrk
so if you wanted, for example, a freebsd-only function, you would have to put it in a separate struct (note: files are structs) so avoid it from being analysed

1571265974
andrewrk
this would prevent this refAllDecls silliness

1571266023
andrewrk
it means semantic analysis dumps would include pretty much everything, unless something is explicitly omitted by putting it in a separate struct/file

1571266103
nrdmn
I'm not sure what the implications of this change are

1571266133
THFKA4
i'm not sure that would help the case i was nooo'ing about. i'm concerned about the mild annoyance of commenting out a line while experimenting and getting an unused declaration compiler error

1571266150
THFKA4
if i move all variables into a struct, chances are that it'll still be referenced through another member

1571266283
nrdmn
to answer my own question about doc comments over imports: we're importing structs, not their documentation. So there may be different text depending on whether you view the parent namespace or the namespace/struct itself

1571267236
Snektron
Im still not sure what to imagine on using async

1571267280
Snektron
i know the basic of how it works, but i have yet to see a concrete example

1571267481
andrewrk
Snektron, I haven't updated and re-enabled this test yet, but here's an example:

1571267496
andrewrk
the general idea here you can see is quite powerful

1571267507
nrdmn
... so we'd document the struct and the symbol that we're binding the struct to separately

1571267539
andrewrk
nrdmn, when a decl doesn't have any doc comments, probably it would be good to use the doc comments on the thing it refers to

1571267567
andrewrk
the reality is that things are what they are and the doc renderer's job is to display it in a useful way

1571267586
andrewrk
a decl might reference different things on different targets

1571269851
pixelherodev
What would be the correct way to write an interrupt handler in Zig?

1571269889
pixelherodev
I don't see e.g an "interrupt" keyword / attribute, should I just leave them in assembly?

1571269971
Snektron
andrewrk: looks interesting. I think you've done a really original job on async

1571269986
Snektron
pixelherodev: i was thinking about that the other day

1571270009
Snektron
You could wite a function that wraps another as interrupt handler

1571270028
Snektron
Depending on the system that is

1571270065
Snektron
I'd just leave them in asdembly though

1571270220
ky1ko
i'm trying to rewrite a small emulator framework of mine in zig and i have a couple questions. in my existing C framework, i write an abstraction around the base idea of a "busDevice" that can be read from or written to. i do this abstraction with a struct containing function pointers and a void pointer that the device-specific functions dereference into whatever they store there.

1571270230
ky1ko
is there some recommended way i could write a similar abstraction in zig right now?

1571270249
ky1ko
could i do effectively the same thing?

