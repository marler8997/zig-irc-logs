1568764878
_Vi
Why arm 32-bit / Linux is listed as "Tier 2" in the table, yet `zig/std/os/linux.zig` throws "unsupported arch" for anything besides x86_64, i386 and aarch64? Is the table valid for last released version (0.4.0) or for master?

1568764914
errpr
the godbolt example works in 0.4.0

1568764950
Aransentin
Curious... :)

1568765062
Tetralux
_Vi: I think 32-bit ARM is different from Linux, no?

1568765099
_Vi
Tetralux, I mean intersection of "arm 32-bit" row and "Linux 3.16+" column.

1568765100
Tetralux
Also, I'm not sure what the table is specific to, but there's a decent chance it's master.

1568765143
_Vi
Tetralux, Unreleased Tier 2 does not look like a real Tier 2...

1568765721
andrewrk
_Vi, I'm not sure why unused symbols are getting included when linking musl statically. that's worth looking into

1568765896
_Vi
With zig from master instead of 0.4.0 the difference is much less drastic: 16104 vs 10256 bytes.

1568766033
andrewrk
_Vi, where do you see 32-bit / linux in the support table?

1568766077
_Vi
andrewrk,

1568766114
andrewrk
ok - arm 32-bit. listed as tier 2. have a look at

1568766123
andrewrk
"There may be some standard library implementations, but many abstractions will give an "Unsupported OS" compile error. One can link with libc or other libraries to fill in the gaps in the standard library."

1568766170
_Vi
andrewrk, For 0.4.0 it's not even Tier 4, as it flatly refuses to compile anything.

1568766188
_Vi
Maybe it's just the time for 0.5.0?

1568766200
fengb
Thatâ€™s in like 2 weeks

1568766201
andrewrk
0.5.0 is scheduled for sept 30

1568766236
_Vi
Are releases on schedule?

1568766256
andrewrk
prior to 1.0, they are approximately 1 week after LLVM releases, which are every 6 months

1568766281
_Vi
And after 1.0 is what?

1568766292
andrewrk
unknown

1568766368
_Vi
6 months look rather rare for an actively developed pre-1.0 project... How many zig developers use non-master zig?

1568766433
scientes
_Vi, everybody is using master

1568766444
scientes
_Vi, its because it is tied to the llvm release schedule

1568766514
_Vi
Why tied to LLVM? Are minor releses like 0.4.(x+1) planned?

1568766530
fengb
The nightly builds are generally pretty stable

1568766545
mikdusan
_Vi: the offset is... master is released with via continuous integration builds/testing. there's a ton of stability to master because of that. other "pre-1.0 projects" imo, anecdotally, are no where near as stable for master builds

1568766584
_Vi
Are releases needed at all for pre-1.0?

1568766607
_Vi
Or are they supposed to be used mostly for comparisons?

1568766772
mikdusan
use master. if master has an LLVM requirement too new for you, use the most recent "Release" that has a lower LLVM match for you.

1568766925
fengb
It gives andrewrk a nice schedule and a chance to catch up on documentation

1568767046
stratact
andrewrk: scientes is right, 8192 is a good size for the dir entry buffer. I've noticed dirread implementations from NetBSD and Suckless.org use a 8192 sized buffer when inserting into getdentries. However from peeling the onion in the std library, it seems that eventually there is a buffer of [4096]u8 is used, but that's because of MAX_PATH constant from glibc and musl. So I think doing MAX_PATH * 2 or 8192 is a good size for the buffer to ensure

1568767047
stratact
no problems and better performance, like scientes said.

1568767119
scientes
yeah master has to past the test suite

1568767127
scientes
so it is no less stable than the releases

1568767268
fengb
This is quite a monster release though. Async, elision, and SIMD ðŸ¤ž

1568767285
companion_cube
what'll be missing after that? bootstrapping?

1568767385
daurnimator
_Vi: I tend to use the releases for about 3 months... and then use master again as things get too out of sync

1568767424
_Vi
daurnimator, That's a sign of too rare releases.

1568767439
scientes
no really, we don't really have that many users yet

1568767444
scientes
*not

1568767480
andrewrk
result location (aka copy elision) has been rough. I'm not happy with the quality of implementation, and it's definitely introduced bugs

1568767497
scientes
yes, I've seen some of those bugs

1568767517
andrewrk
I hope that when implementing it with a fresh start in self-hosted, a better way to implement it will reveal itself, which can potentially be backported to stage1 if necessary

1568767532
mikdusan
yeah the money question: spend time fixing it or "good enough" and full-ahead on self-hosting?

1568767562
andrewrk
I agree that is the money question

1568767567
scientes
IMHO as always, the only way to find out better ways it to re-write things, you can't "fix" anything until you discover the new method

1568767612
andrewrk
and then stuff like

1568767639
scientes
I also got ticked as this habit of allocating everything on the stack in LLVM so that the debug info works, and then having the compiler optimize to registers

1568767652
scientes
because it means not really using LLVM as SSA that it was designed as

1568767729
scientes
but that is kinda minor

1568767745
mikdusan
i'm not convinced zig-ir should be ssa. maybe it could get lowered into a zig-ir2 that is ssa before llvm

1568767769
scientes
what i'm saying is that the llvm-ir that zig produces isn't ssa either

1568767784
andrewrk
I do think that having our own backend independent from llvm will be instructive into how zig-ir should be

1568767888
mikdusan
i don't ask because of preference, only curiousity. has it been considered to codegen to '.llvm' as opposed to LLVM API? there are decoupling pros. cons i guess { slower? and illegal codegen slips through? }

1568767979
scientes
illegal code gen is already hard to debug, I think you can get better debug with a asserts-enabled llvm

1568768099
andrewrk
mikdusan, we have that with --emit llvm-ir

1568768126
andrewrk
generally though, zig the language is not supposed to depend on LLVM

1568768131
scientes
I think he is talking about generating llvm-ir without using libllvm

1568768136
andrewrk
even though the "reference implementation" very much does

1568768157
scientes
supporting gcc as a backend would be cool

1568768181
_Vi
Is pure infinite loop an undefined behaviour in Zig?

1568768193
mikdusan
i mean avoid LLVM-API bindings altogether and emit .llvm or .bc and feed that into llvm

1568768211
scientes
no. But I've talked in sopport of that without really pushing it.

1568768234
scientes
it would require some sort of infinite loop intrinsic

1568768250
scientes
@halt()

1568768272
scientes
or @sleep(-1)

1568768324
scientes
mikdusan, i really don't see that that gains us anything

1568768407
mikdusan
scientes: my understanding is that zig uses c compatibility to get to all that is LLVM-API. when LLVM C-API is insufficient, C++ is wrapped in C to bring it to zig,

1568768418
scientes
correct

1568768434
mikdusan
this needs to continue if self-hosting will use LLVM C-API

1568768463
andrewrk
_Vi, ultimately, at this point in time, zig's development process is optimized for productivity & progress of the language to get towards maturity and stability as soon as possible

1568768470
scientes
llvm-c bindings can probably be fixed

1568768480
andrewrk
at some point, priorities will shift

1568768484
scientes
^

1568768506
scientes
that model worked well for go

1568768507
_Vi
andrewrk, Is it reply to comment about release schedule or to question about infinite loops?

1568768543
mikdusan
so in a self-hosted compiler, there is going to be C wrapper for C++ "support" library. no getting around that until as you say llvm-c can be "fixed".

1568768566
scientes
mikdusan, well libclang really is c++ only

1568768583
andrewrk
_Vi, release schedule. I think there is an issue open to deal with the infinite loop thing

1568768586
scientes
so we kind of have a problem anyways, but that is quite a ways down the road

1568768685
mikdusan
here a little writeup I found:

1568768743
stratact
Why can something of type `*[N]T` be passed as `[]T`?

1568768782
andrewrk
stratact, *[N]T represents a pointer to a bunch of contiguous items in memory, and the length is known as part of the type (N). A []T represents a pointer to a bunch of contiguous items in memory, and the length is runtime known (the .len field of the slice)

1568768809
andrewrk
so it's very straightforward and safe to convert *[N]T to []T

1568768829
scientes
.*[0..]

1568768842
stratact
Oh, gotcha

1568768855
andrewrk
scientes, there's an implicit cast for it

1568768883
andrewrk
mikdusan, I might have a better answer for you if I better understood what problem you were trying to solve with outputting .llvm

1568768889
mikdusan
fyi this project emits llvm assembly as their backend as well:

1568769447
mikdusan
andrewrk: no

1568769582
andrewrk
mikdusan, one thing I don't like about that is how it complicates what a zig installation looks like

1568769625
andrewrk
currently we have a single binary, a language reference html document, license file, and a lib directory tree

1568770070
companion_cube
one binary sounds good

1568770219
rohlem
andrewrk: By its recent mention, are you currently working on #3234 ? Is my assumption correct that the underlying problem extends to similar aliasing when constructing a struct?

1568770265
andrewrk
rohlem, I'm sort of thinking about it subconsciously while working on other issues. it's not a problem with structs because fields don't alias each other

1568770334
rohlem
I was considering a scenario like x = S{.a = f(x), .b = f(x)}; My questions were whether all side-effects should only be observable _after the statement, or whether that should be outright illegal in the first place.

1568770568
andrewrk
currently, such aliasing is allowed, and there is a well-defined order of things happening. f(x) runs with result location set to &x.a. f(x) runs with result location set to &x.b. Proposal

1568770838
rohlem
andrewrk: I was thinking, if it's intended the assignment "appears atomic", i.e. both invocations of f can read the old values of x.a and x.b, we could pass a copy of x, but pretend its address were the original x's address, to get result location semantics.

1568770972
andrewrk
that's just the old semantics, without result location

1568770980
rohlem
though escaping that ruse via `@fieldParentPtr` would require further vetting

1568771025
rohlem
It is "new semantics" in that the init function could already depend on the result's address.

1568771096
andrewrk
ah, I see. you are proposing byval parameters

1568771119
rohlem
Well, it would only be under-the-hood. I'll have a gist with an example in 3 minutes.

1568771353
stratact
Sigh, I made the buffer adjustments, but cmake returns a 255 error code from rebuilding the compiler, which means it's not able to see a file even though it exists?

1568771494
andrewrk
stratact, can I see the full output from make?

1568771567
stratact
andrewrk:

1568771634
andrewrk
the helpful output is nto error code 255, it's the message above that

1568771714
andrewrk
it built zig0, then used `zig0 build libuserland install` which failed. that build step depends on the std lib files you edited, so you've caused a regression that made zig no longer able to build

1568771737
andrewrk
you can use zig0 to run the relevant std lib tests and/or a debugger

1568771774
andrewrk
you'll need `--override-std-dir` when using zig0

1568771850
andrewrk
you can also `make zig0` to skip the steps that are failing while you troubleshoot

1568771896
stratact
Thank you and will do. I had to change something in std.build to fit the changes in std.fs, since most things are interconnected

1568772406
andrewrk
yep, makes sense

1568772561
rohlem
andrewrk: Took longer than expected, less feasible than I thought, but judge for yourself:

1568773032
andrewrk
rohlem, I'm going to have to look at this tomorrow, I'm getting sleepy

1568773276
rohlem
andrewrk, sure, no need to rush or prioritize over anything else even, just wanted to give my 2 cents on the topic while the iron's hot. Rest well, and thanks for all the great work!

1568773416
andrewrk
cheers

1568774947
donpdonp
so fyi, i tried zig head (0.4.0+c6e77f248 Sep 16 Fix tripping llvm assert) and after updating std.mem.<hash stuff> to std.hash_map, I'm still getting a " Assertion failed. This is a bug in the Zig compiler." compiling zootdeck (head)

1568775012
andrewrk
donpdonp, thanks for letting me know. I'll make sure zootdeck builds with latest master and then ping you when it's fixed

1568775029
donpdonp
great, thx.

1568775149
donpdonp
the zig that does compile zootdeck is 0.4.0+7f23dac6d Aug 5 'Update readme'

1568775205
andrewrk
noted

1568775804
stratact
Well from trying to run (and debug through gdb with) test-std through zig0, for some reason it can't open() from the buffer through FreeBSD's implementation at least.

1568775858
stratact
which explains why it can't find the file, even though it exists

1568775900
stratact
hash miss?

1568776140
stratact


1568776624
stratact
(gdb) print *full_path

1568776626
stratact
$13 = {list = {items = 0x806ae9ce0 "/home/stratact/Projects/Zig/zig/lib/std/special/build_runner.zig", length = 65, capacity = 78}}

1568776998
stratact
andrewrk: I think issue #2885 is rooted deep in the compiler level instead of standard library, because I think, and I'm just guessing, that removing file_path buffer allocation in the standard library requires that `Buf` types in the zig compiler not be allocated as well...

1568777162
stratact
This issue is probably too big for me and I'd be responsible for tons of breakage

1568777536
stratact
the dots are connecting

1568777582
afon
\leave

1568779402
mikdusan
stratact: is that on master or private branch?

1568780328
stratact
mikdusan: the issues are on my local branch, upstream master is unaffected. The problem is when one decides to remove the allocator from Dir.open() which creates more work and problems down the road.

1568780372
mikdusan
if you give me a diff i can add another pair of eyes to it

1568780886
stratact
mikdusan:

1568781238
mikdusan
have you narrowed to a test (without using build_runner) ?

1568781269
stratact
No, I haven't.

1568781295
mikdusan
ok so i'd avoid `zig build` or `zig0 build` until manual test runs work

1568781366
mikdusan
i have an unofficial doc/notes on this kind of stuff:

1568781398
mikdusan
so right now this completely passes for me on freebsd with your patch: _build/zig0 --override-std-dir std --override-lib-dir . test test/stage1/behavior.zig

1568781427
mikdusan
and I moved on to testing "std" which is very large and get a failure:

1568781444
mikdusan
_build/zig0 --override-std-dir std --override-lib-dir . test std/std.zig

1568781496
stratact
Ah, interesting, thank you.

1568781567
mikdusan
are behavior tests passing?

1568781588
stratact
yes

1568781611
stratact
the 2nd test didn't but I got those errors you mentioned

1568781644
mikdusan
ok. i got some missing arguments errors. if you're on the same page, it can be reduced further.

1568781682
stratact
Yeah, just remove the `a` argument, and I think you would be good.

1568781699
mikdusan
this runs a "subset" of std... -> _build/zig0 --override-std-dir std --override-lib-dir . test std/os.zig

1568782122
stratact
I got past the errors, but now I got a real test failure:

1568782201
mikdusan
i'll need an updated patch to look at that

1568782243
stratact
oh... whoops, I used std/std.zig instead of std/os.zig...

1568782270
mikdusan
fyi if you look at "test { ..... }" inside std/std.zig that's where all the sub-files can be found.

1568782295
mikdusan
all of which direct test can be invoked

1568782305
stratact
ah, I see, that's cool

1568782328
stratact
Let me get you that patch

1568782549
stratact
mikdusan:

1568782631
mikdusan
ok i get test failed: `os.test.test "makePath, put some files in it, deleteTree"..`

1568782633
mikdusan
same?

1568782677
stratact
Different for me: 28/1218 build.test "builder.findProgram compiles"...Segmentation fault (core dumped)

1568782691
stratact
oh sorry, wait

1568782754
mikdusan
yeah just test `std/os.zig`

1568782766
stratact
Yes, I got the same result now from std/os.zig

1568782766
mikdusan
so the big long line means run that executable to get the failure.

1568782776
mikdusan
running that i get a core-dump

1568782860
mikdusan
so debugger time. lldb tells me SIGSEGV during memcpy a couple frames inside makePath

1568783122
stratact
I really should learn more about debuggers and how to use them more effectively

1568783330
mikdusan
a lot of times what i'll do in a situation like this is reduce.

1568783340
mikdusan
so we have the exact line of test that is failing:

1568783373
stratact
Still I'm grateful for your expertise in debugging or knowing where to look.

1568783388
mikdusan
are you using lldb? if so i can walk you through some simple stuff

1568783412
stratact
currently have gdb on hand, but I can install lldb as well

1568783451
stratact
oh right, it naturally comes with FreeBSD, hah

1568783476
mikdusan
so just `lldb exename` which is that long test executable

1568783508
mikdusan
once in. at prompt "run"

1568783528
stratact
oh wow, this is cool

1568783561
mikdusan
now it's stopped you at the actual nested frame where it faulted

1568783571
stratact
Yeah, it's nice

1568783608
mikdusan
lets get a backtrace: `bt`

1568783632
mikdusan
that shows call stack for thread #1. we only have 1 thread. you should see 10 frames.

1568783645
stratact
Now I see, makePath is in the #3 frame

1568783662
mikdusan
lldb command completion. so enter "fr" and hit tab to expand to "frame"

1568783677
mikdusan
or short form works.  "fr s 3" (frame select 3)

1568783682
stratact
gotcha

1568783702
mikdusan
`fr s` is useful if you lose your place. just shows you which fr is selected and nice little code segment.

1568783720
mikdusan
so do you see how "full_path" says unavailable?

1568783723
stratact
this is much better way to debug than using breakpoints all of the time :)

1568783740
stratact
Yes, I see it

1568783760
mikdusan
ok i am not sure but it may have something to do with lldb being confused with some zig special test stuff.

1568783772
mikdusan
what i think is a good option is... go to frame 4. --> fr s 4

1568783783
mikdusan
and we see a pretty good reduction.

1568783804
mikdusan
let's make this about as simple as it gets and create a 2-liner executable of our own.

1568784069
mikdusan
actually reducing to main doesn't help

1568784118
mikdusan
there's still that <unavailable> marker. i think it might mean bad memory

1568784134
stratact
like a dangling pointer?

1568784360
mikdusan
not sure. so if you're still in frame 4

1568784372
stratact
yep

1568784395
mikdusan
to look at local variables: fr v

1568784414
mikdusan
but what we're really concerned about is that 2nd arg passed to makePath

1568784488
mikdusan
let's switch to using our own executable instead of test. here's a reduction that faults as well.

1568784490
mikdusan


1568784499
stratact
Will look.

1568784516
mikdusan
just build an executable directly: _build/zig --override-std-dir std --override-lib-dir . build-exe bug.zig

1568784541
mikdusan
(you'll note i stopped using zig0 because it's probably ok to use stage1 but still have to point it to our workstree))

1568784569
mikdusan
so now --> lldb bug

1568784593
mikdusan
run; bt; fr s 4

1568784595
mikdusan
fr v

1568784644
mikdusan
hey look we see tmp. that looks decent enough.

1568784655
stratact
yep, but allocator doesn't

1568784673
mikdusan
yeah that's a red flag

1568784685
mikdusan
so i wonder... is there no global debug allocator?

1568784742
mikdusan
well here's a quick test.

1568784750
mikdusan
how about we just use direct allocator and see if that helps

1568784821
mikdusan
same deal.

1568784905
rohlem
andrewrk: as a heads up, I updated the gist, the new idea is much simpler and should be more readable now. I initially thought that promoting variables to result location ( #2765 ) was already implemented, but I think it's worthwhile either way.

1568785453
mikdusan
i'm just going to try a newer lldb

1568785481
stratact
mikdusan: what's interesting is that in frame 3, the `a` allocator pointer has an address

1568785503
stratact
sorry `allocator` allocator

1568785504
mikdusan
yeah i noticed clang is back in version 6. so lldb is probably aged as well

1568785571
stratact
mikdusan: ah, well I'm using FreeBSD12-stable, so I would have the llvm 8.0.1 since it's from the stable branch, iirc?

1568785585
mikdusan
i'm just 12.0

1568785604
stratact
So the release version

1568785628
mikdusan
just tried on macos same deal with lldb.

1568785634
mikdusan
let's see what gdb says

1568785717
stratact
mikdusan: btw, I wouldn't mind another debugger training session from you ðŸ˜„

1568785804
mikdusan
ok i installed gdb: gdb bug

1568785808
mikdusan
run

1568785810
mikdusan
bt

1568785828
mikdusan
instead of `fr s 4` it's just `fr 4`

1568785848
stratact
I'm there

1568785862
mikdusan
what the f.

1568785867
mikdusan
fr 3

1568785870
mikdusan
p full_path

1568785899
stratact
wtf indeed: $1 = <optimized out>

1568785932
mikdusan
i don't claim to understand it. but what i do understand is if it ain't there... that explains why a mem cpy is faulting.

1568785970
stratact
It explains the what, but not the why.

1568785989
bgiannan
Is there a syntax i'm not aware of to test more than one thing when unwrapping an optional? In Swift i would do `if let myoptional = unwrapped_optional, myoptional == 42 && something_else == 42 { ... }`

1568786032
bgiannan
but in zig i end up doing: `if (myoptional) |unwrapped_optional|  { if (unwrapped_optional == 42 and ..) {...} }`

1568786503
mikdusan
so the debugger isn't being entirely useful. and looking at your diff, i'm a little concerned at some stack memory escaping

1568786592
stratact
ðŸ˜…

1568786867
mikdusan
stratact:

1568787145
mikdusan
i added another comment showing nothing more than a syntactical work around. i don't think it's a solution.

1568787172
mikdusan
so after doing that there's no more crash and a legit error comes through.

1568787206
stratact
Yep, it was my stupidity.

1568787621
mikdusan
so are these changes driven from trying to remove allocator from fs.Dir ?

1568787632
stratact
correct

1568787700
mikdusan
ok but deleteTree also removed allocator?

1568787734
mikdusan
i admit just glancing at this quickly. but it seems to me that TODO was for fs.Dir API... not the other things in std.fs

1568787747
stratact
That's part of issue #2886 as well, after #2885

1568787882
mikdusan
hmm... so makePath is recursive. it calls path.resolve ... which needs memory but doesn't appear to be recursive

1568787896
mikdusan
(reminder that hack i did with global is just a hack)

1568787951
mikdusan
smells like path.resolve if it is to drop allocator, then it needs to be passed a buffer.

1568787999
mikdusan
that buffer can be from caller's stack or one given to the caller

1568788085
mikdusan
oh it takes an array of paths. so it would need the same number of buffers.

1568788192
mikdusan
anyhow just shooting from the hip. but i gotta run; late here. take care.

1568788213
stratact
mikdusan: ah no worries, thank you so much for helping me

1568788232
mikdusan
ðŸ‘

1568788240
stratact
Even if I never solve this issue, I learned a lot

1568797755
stratact
lldb is actually a way better debugger than gdb, I'm really impressed how informative it is.

1568797985
bgiannan
is it? i find gdb + dashboard pretty unbeatable

1568798140
stratact
oh wow, dashboard looks pretty amazing. The UI looks like the ideal debugger setup

1568798238
alexander92
have you tried rr ?

1568798246
alexander92
it's quite good for low-level languages like zig

1568798264
alexander92
(it can be used with both gdb and lldb afaik, but not sure about dashboard)

1568798280
bgiannan
alexander92, got a link?

1568798286
stratact
Ah yes, I've heard of it. It records the execution session in which you step forward and backwards right?

1568798326
stratact


1568798430
alexander92
yes, and otherwise you use it just like gdb (or maybe lldb as well? i think they got support fot it, not sure)

1568798451
alexander92
but + fast and light reverse execution

1568798483
alexander92
pretty good for harder to reproduce bugs

1568799341
bgiannan
alexander92, huh seems super useful i'll give it a go

1568801444
_Vi
Is there some package central for Zig deps?

1568801561
_Vi
Perl - CPAN, Rust - crates.io, Java - Maven Central, Zig - ?

1568801592
vegai
the whole packaging thing is still on the design table

1568801629
vegai
issue here:

1568802020
_Vi
Why lockfiles are mentioned there as something to avoid?

1568808482
bgiannan
Why is `==` not allowed between two optionals?

1568811222
firefox317
What should the result be when you compare two optionals where one of them is null?

1568811394
fgenesis
not equal

1568811673
firefox317
And both of them null true? Not sure if that makes sense because I think the intention is to compare the value of the optional

1568811684
fgenesis
yes

1568811697
fgenesis
optionals are equal when they have no value

1568811728
alexander92
if they point to the same type

1568811730
alexander92
?

1568811743
mq32
alexander92, that should be the only possible way

1568811749
mq32
it doesn't make sense to compare ?f32 to ?i32

1568811757
alexander92
yes, just asking in case

1568811766
bgiannan
for me two null optional should be equal

1568811790
alexander92
does zig support something like "recursive" == for structs ?

1568811797
mq32
yes

1568811799
mq32
std.mem.eql

1568811877
alexander92
hm, but does this work recursively: i guess it directly compares memory

1568811885
alexander92
e.g. if you have a field which is a different struct

1568811903
alexander92
does it compare a.b == other.b (comparing their fields as well)

1568811920
alexander92
i am mostly interested in trees: in nim i find myself often reimplementing `==` for my trees

1568812029
mq32
for trees, you have to compare manually

1568812063
mq32
because zig can only compare pointer values, but will

1568812183
alexander92
i see, and i guess zig is against custom operator overloading

1568812221
mq32
correct :D

1568812246
alexander92
ok, just read about generic structs as a result of comptime functions

1568812249
alexander92
interesting approach

1568812286
mq32
it's great

1568812291
alexander92
can you have something like constraints

1568812294
alexander92
like this

1568812303
mq32
much more readable than most other approaches on metaprogramming i've seen

1568812306
alexander92
e.g. you don't take fun(T: type)

1568812309
alexander92
but something like

1568812319
alexander92
fun(T: hashableType)

1568812320
gonz_
No constraints on generics, no.

1568812340
alexander92
but it does seem like something possible to me

1568812342
gonz_
I would recommend taking a comptime function or a set of functions if you want to parameterize behavior.

1568812361
mq32
gonz_, we can have trivial constraints on generics

1568812394
gonz_
mq32: What do you mean by that?

1568812403
alexander92
so i should write t: type

1568812413
alexander92
and then comptime { if not hashable(t) .. comptime error }

1568812414
mq32
if (MyConstraint(T)) { @compileError("MyConstraint not met for T"); }

1568812415
alexander92
?

1568812431
alexander92
yes

1568812443
mq32
well, there's a "not" missing, but you get the point

1568812446
gonz_
This isn't really needed with a set of functions, though.

1568812457
mq32
huh?

1568812460
alexander92
how can it be written with set

1568812466
gonz_
It's much clumsier than a function parameterized on a set of interface functions

1568812471
mq32
?

1568812474
alexander92
i think those constraints can be much more powerful tho

1568812480
alexander92
as you can run custom code inside of them

1568812483
mq32
gonz_: i think you're missing something here

1568812483
alexander92
similar to concepts

1568812485
mq32
"This generic is restricted to integer types only"

1568812495
gonz_
What's more powerful than guaranteeing that you're passed an actual implementation of a desired behavior?

1568812508
alexander92
but how can you express it with a set

1568812527
gonz_
I think you're over-analyzing the wording. "set" as in a struct of functions.

1568812538
alexander92
in a function you can say something like "this type should have this function defined , this field defined and its name should start with X"

1568812551
alexander92
what you're describing is simpler interfaces imho

1568812557
alexander92
i am more thinking of concepts

1568812560
gonz_
No, they accomplish the exact same thing.

1568812575
alexander92
not really

1568812577
gonz_
You're thinking of a clumsy way to write type classes, essentially.

1568812590
alexander92
well, can i describe every possible statement

1568812600
alexander92
about a type with a set

1568812614
gonz_
You can describe how to hash a type, how to get a certain piece of data from a type, etc.

1568812622
fengb
Type classes are Turing complete so yes probably

1568812651
alexander92
but not stuff like "it has such an operator"?

1568812670
gonz_
You would be passing an implementation of that operator in that case, probably.

1568812678
gonz_
That is an existence proof of the operator being available

1568812684
gonz_
with the correct types

1568812718
alexander92
so basically the solution is to write a special function for each of those statements

1568812721
gonz_
Now, could you have an issue in a language that can't refer to operators as functions? Yes.

1568812722
mq32
gonz_, please rewrite this example with your approach:

1568812724
alexander92
and then include that function

1568812731
alexander92
in the set

1568812746
fengb
Thereâ€™s an (oldish) proposal on constrained types

1568812750
alexander92
yeah, i meant something like that mq32

1568812753
gonz_
alexander92: A piece of that interface can refer to already existing things, if they do exist.

1568812813
alexander92
the point is that many things that are just a "function" of the type, which are not existing overloads of it

1568812830
companion_cube
D has checks on parameters, and its comptime is close to zig's

1568812836
alexander92
e.g. my extreme example of "the name of this type starts with i"

1568812852
mq32
also a type has more properties than "interface" and you want to restrict on those properties, too

1568812870
gonz_
I think this is mostly a question of unfamiliarity with this style than anything

1568812906
alexander92
not really, interface style just checks the existance of certain overloads

1568812915
alexander92
this is just one class of things you can check for in a type

1568812926
gonz_
You can effectively say things like "this field exists" by simply saying "a function that takes that thing and returns whatever that field is supposed to contain exists"

1568812947
mq32
yes

1568812951
alexander92
so, how would my exampel of "this type starts with I" work

1568812957
mq32
but you cannot make an interface that says "is this type an integer type"

1568812969
mq32
because there is more than object types

1568812975
mq32
(or: struct types)

1568812988
gonz_
mq32: If a function that takes that type and returns an integer exists, it's an integer type

1568813055
alexander92
but is this true

1568813067
alexander92
i can define a "function" for a string

1568813087
gonz_
I'm not saying we shouldn't ever inspect types or whatever, but that interfaces are a much better parameterization method than anything else.

1568813095
mq32
gonz_: still my question: can you make an example that has the exact same properties of my example posted above?

1568813105
mq32
i cannot imagine that your proposed style will work with that

1568813129
gonz_
Your example effectively does nothing.

1568813183
mq32
it does

1568813192
gonz_
This would effectively be one small part of an interface. Again, I'm not saying inspecting types is bad in itself, but if we're talking a library allowing you to change behavior, the things it exposes should probably not be relying on stuff like this.

1568813196
mq32
just imagine that struct { â€¦ } does something useful that requires the properties checked above

1568813255
gonz_
I think you'll have to illustrate your point a bit more because I'm not seeing anything useful here.

1568813261
mq32
okay

1568813272
mq32
my function Bitset creates a type that implements bitsets

1568813277
mq32
and you can specify an underlying type here

1568813282
mq32
(like u8, u16, u32, ...)

1568813296
mq32
but: you are not allowed to pass any other type than "unsigned integers of any size"

1568813306
gonz_
Sure, ok. This doesn't rely at all on any kind of additional type from the user?

1568813310
mq32
because that is illogical and the code wouldn't compile

1568813326
mq32
it relies on a type that must meet the requirement "unsigned integer"

1568813327
gonz_
This isn't applicable if it doesn't involve extending behavior of some kind.

1568813353
gonz_
You're querying a type for something it shouldn't ever extend, no?

1568813357
mq32
i can also make restrictions with "sizeof the type must not be larger than 32 bytes"

1568813381
alexander92
exactly

1568813384
mq32
sorry, i don't understand the question well

1568813411
gonz_
What we were discussing above is about parameterizing someone elses functions with your own types. You're querying a built-in that can only strictly be a built-in for type info.

1568813415
gonz_
I don't think these things are the same.

1568813437
alexander92
stuff like "sizeof of t should be in range X, other property of t should be y" require custom code

1568813483
mq32
yeah

1568813487
alexander92
maybe you can define a "myCustomSizeofRequirement" function for them and include it in your set? but that's just another way to do the same

1568813509
mq32
i can also make something like a special type structure where any user type may be embedded, but that user type must not exceed 8 bytes

1568813516
mq32
because it will be stored in a register

1568813517
mq32
or such

1568813529
mq32
this is also something i cannot solve with "interface specifications"

1568813536
gonz_
These `sizeof` checks could be in the plumbing, sure, but that's just one part of all of this.

1568813567
gonz_
I can agree with you that they have uses, but when you start extending it to "it has this field", etc., that's much better expressed by an actual function that pulls that information out.

1568813602
alexander92
but isn't this the if not customFunction(t): .. compile Error method

1568813605
gonz_
The proposed `fn f(T: HashableType, ...)` isn't at all a question of merely these `sizeof` checks, etc.

1568813613
alexander92
oh i don't propose that

1568813617
alexander92
i just wondered how it works

1568813620
gonz_
and to implement them like that would most likely be the wrong way to go about it

1568813621
alexander92
later i found out the mq32 way

1568813643
companion_cube
I haven't followed the whole thread, but is

1568813678
alexander92
also reminds me of

1568813688
alexander92
(the syntax might still change )

1568813696
gonz_
companion_cube: Presumably, yes. If they're compile-time constraints on generics.

1568813718
companion_cube
they are, yes

1568813727
companion_cube
using comptime function and comptime reflection, as in Zig

1568813736
companion_cube
(I mean, lots of ideas where borrowed from D, right?)

1568813787
gonz_
I don't know if andrewrk has talked exhaustively about his inspirations, but one would assume.

1568813789
andrewrk
more like independently discovered, but there's not really a difference

1568814048
gonz_
I like working with type classes / concepts / whatever you want to call them

1568814071
gonz_
But in reality they're just hiding a passed interface

1568814142
companion_cube
andrewrk: signs it's a good idea then :)

1568814167
gonz_
The Haskell implementation works exactly like that; at compile time the type class is discovered (this is done globally and unless otherwise stated multiple implementations are a compile time error) and implicitly passed at the call site, then usually optimized out later.

1568814273
companion_cube
but in haskell you can also have runtime dispatch

1568814295
companion_cube
like, if you have an existential type

1568814593
mq32
gonz_, i still don't agree, because type properties like size/alignment/... are also part of a type, but are not part of the interface itself

1568814707
gonz_
mq32: When it comes to the proposition of `fn f(T: HashableType, ...)`, for the most part this is about (sometimes implicitly) passed interfaces.

1568814737
mq32
yeah, but then i can use

1568814738
gonz_
I'm not saying you can't make type guided checks inside the plumbing that uses the interfaces

1568814765
mq32
also it may require that those interfaces are again generic and have the same checkups required as well

1568814772
mq32
or maybe also only require sometimes a function

1568814779
mq32
generic programming is a complicated thing

1568814787
gonz_
It's really not

1568814813
mq32
such like "if this property is existent, we also require this property" is bad to express with interfaces

1568814843
gonz_
Except that could be a function that returns null or a struct with both those things.

1568814865
gonz_
Et voila, "if one, both, if not, nothing"

1568814876
mq32
yeah and this will get complicated :D

1568814914
mq32
i have a ton of specializations in my C++ code just for type distinction (thus requiring a lot of comptime checks to not break things accidently)

1568814916
gonz_
And you don't think playing snakes and ladders with a bunch of `if`s and `@compileError` gets more complicated with all of your checks?

1568814933
mq32
it may be simpler

1568814944
gonz_
Somehow making something that is effectively "If you can provide me this function, you can use the function" is more complicated?

1568814947
mq32
your approach will break as soon as you have (a | b) â†’ c

1568814975
gonz_
Except it doesn't. If `a | b` is an actual union I can provide an implementation for it just as I could for the types alone.

1568815017
alexander92
gonz_ please .. ignore this proposition

1568815024
alexander92
i didn't propose that

1568815032
alexander92
i asked if that's an existing syntax

1568815049
alexander92
i fully agree with mq32 and the if compile Error

1568815054
alexander92
approach

1568815104
gonz_
Like I said, I think this is an issue of familiarity more than anything.

1568815120
mq32
and simplicity

1568815123
mq32


1568815126
alexander92
but sorry, you're right: this kind of syntax woudl be expected

1568815139
gonz_
I think doing a bunch of procedural type guided checks is valid for some cases, but I think it seems simpler only to people who don't know the alternatives.

1568815142
alexander92
and indeed, maybe providing this functions can work

1568815150
alexander92
but it seems to me the same amount of work

1568815185
gonz_
This discussion is probably more a product of different communities clashing than anything else.

1568815187
alexander92
maybe, having a set for most cases, and a comptime call for the most "edge" case

1568815188
alexander92
is best

1568815219
gonz_
alexander92: What do you mean by comptime call exactly? The type guided procedural checks?

1568815225
alexander92
somethign similar is being proposed for nim's "interfaces" vs more full "concepts" so that's why it felt similar as a discussion to me

1568815236
alexander92
the if not customFunction(t) .. checks

1568815254
gonz_
Mhm

1568815330
gonz_
alexander92: Interfaces are proposed, by the way. Maybe that got lost in the discussion.

1568815341
gonz_
People are working hard to occlude this already.

1568815374
gonz_
There's even talk about embedding structs and implicitly having the parent struct work with functions expecting the embedded type.

1568815554
alexander92
interesting: are there concrete "RFC-s" for interfaces

1568815560
alexander92
i will look thru issues later

1568815612
gonz_


1568815667
gonz_


1568815713
gonz_
Though there are probably tons, honestly.

1568815723
gonz_
Every time I search for a term I find some issue I hadn't seen before.

1568815727
scientes
ahh fn(type) bool is nice

1568815738
scientes
cause that is how you already have to write the function

1568815766
gonz_
alexander92: There's this one that I think stands as a collection issue, maybe:

1568815772
mq32
gonz_, i think those are the main approaches on interfaces right now

1568815831
andrewrk
I also reserve the right to reject all interface proposals if status quo is deemed "good enough"

1568815849
mq32
andrewrk, you are BDFL, you have the right to do that :D

1568815901
scientes
but yeah it is a little too OO-madness for me

1568815929
scientes
like C++ constructors, and other things that are just too complicated for people trying to get stuff done to want to have to care about

1568815942
andrewrk
if I'm able to make a nice widget API without introducing any interface language constructs, it'll be hard to convince me we need anything

1568815976
mq32
andrewrk, yeah i think that's a really good measurement as that is where inheritance really shines in its usefulness

1568815992
mq32
most other cases don't require inheritance

1568816838
gonz_
Small nitpick: Nothing "requires" inheritance.

1568816932
andrewrk
I tried doing a GUI in c++ without inheritance and I would go so far as to say the use case requires it

1568816944
companion_cube
what's the status quo for interfaces, actually? like, iterators?

1568816966
gonz_
Personally I'm probably just going to sit back and see what happens as it seems inevitable we're getting something crazy in the future. I'll either learn to like it or something else.

1568817009
andrewrk
companion_cube, there's a pattern with @fieldParentPtr you can observe with e.g. std.io.InStream. it has some issues regarding error sets

1568817044
andrewrk
std.mem.Allocator is one with a fixed error set, which is pretty reasonable as far as an interface goes, I think

1568817058
gonz_
andrewrk: A type class like `IsElement` that you would have to implement for your type to be used as an `Element`, does that qualify as inheritance?

1568817066
companion_cube
yeah, embedded structs, as in C, ok

1568817166
andrewrk
gonz_,

1568817182
gonz_
I think there's a class of languages that generally doesn't do GUI very much and I'm prepared to concede that it's because they don't have inheritance (it seems logical and rational), but I don't know that it's an empiric fact.

1568817226
companion_cube
there's also java-like interfaces (bunch of methods with default implementation, bunch of required methods, nothing remains after it's compiled)

1568817351
gonz_
companion_cube: `IsElement` would effectively be an interface of one function: `fn(T) Element`, that when provided allows you to obviously use things working with `Element`

1568817375
gonz_
I don't view this as inheritance, but it does the same thing

1568817394
companion_cube
it's like inheritance without subtyping

1568817398
gonz_
And can also be expressed either explicitly or if implicit interfaces were added you would just implement that trait or whatever

1568817410
companion_cube
if interfaces and types are separate things, you can get the code reuse without the type hierarchy

1568817492
gonz_
I'm curious if this is palatable to people arguing for inheritance

1568817554
companion_cube
I have no idea

1568817588
companion_cube
isn't this whole discussion a bit of an blow to the idea that a C-like language can palate to modern tastes?

1568817603
companion_cube
seems like you always want some level of abstraction and type safety C was never able to provideâ€¦

1568817608
companion_cube
(see: generics)

1568817632
gonz_
I think everyone accepts a certain level of additional stuff on top of C, the question is just how much you're willing to accept.

1568817662
companion_cube
ðŸ‘

1568817680
fgenesis
i'll just throw in the design philosophy of Lua, that doesn't even have OO, but with a bit of syntactic sugar and a bit of custom code you can even do multiple inheritance if you want

1568817709
fgenesis
so in any case i'd prefer a syntactic sugar solution over a language feature

1568817720
fgenesis
because that one was really done right, imo

1568817741
companion_cube
lua has a ton of dynamic dispatch though

1568817762
fgenesis
like function X:foo(y) being equal to function X.foo(self, y)

1568817778
fgenesis
yes, it's a different concept and all that, i know. but i like the idea

1568817799
fgenesis
keep the language KISS but the nice stuff comes with syntax sugar

1568817806
companion_cube
yeah, I like that too

1568817829
andrewrk
fgenesis, oh neat I didn't know lua had exactly the same zig "method" syntax as zig

1568817837
fgenesis
lolwhat

1568817852
fgenesis
i must admit i forgot/never knew how zig did methods

1568817863
fgenesis
but if it's done like this it makes so much sense

1568817871
fgenesis
because the lua syntax is awesome for that very purpose

1568817889
fgenesis
and given an optimizing compiler and loss of dynamic dispatch this is still a super powerful concept

1568817893
andrewrk
in zig X.foo(self, y) is equal to self.foo(y) when @typeOf(self) == X

1568817904
fengb
Lua is prototype based OO

1568817947
fgenesis
lua has . vs : to support the sugar but aside form this it's similar yea

1568817988
gonz_
andrewrk: Given a comptime known function taking a struct S and returning just a field from that struct, does the compiler optimize it to exactly a field access at the moment?

1568818011
fgenesis
godbolt it? :P

1568818130
andrewrk
scientes, today's the day, I'm merging your SIMD branch. 1/27 commits done so far

1568818140
companion_cube
ðŸŽ‰

1568818159
andrewrk
wow, emojis work after I upgraded to xfce 4.14. I'm truly living in the future now

1568818177
companion_cube
have you also installed noto or some similar font? :)

1568818188
companion_cube
welcome to the future andrewrk ðŸŒˆâœ¨

1568818197
fgenesis
i can see emojis but i wish i didn't

1568818202
tgschultz
^

1568818210
fgenesis
at least on my XP they are broken and i'm glad they are

1568818229
gonz_
What are you using that doesn't allow you to turn them off?

1568818236
companion_cube
I'm just having too much fun with them, sorry fgenesis

1568818240
fengb
ðŸ¤®ðŸ¤¯ðŸ’©

1568818254
fgenesis
fengb: first 2 are broken, last one is poop?

1568818270
gonz_
Puking, mind blown, poop

1568818271
fengb
First two are too new for your font :P

1568818271
fgenesis
yeah, still partially broken. all is well.

1568818292
fengb
You could hack your font files and remove all emojis

1568818296
companion_cube
LANG=C and you'll be alright

1568818302
fgenesis
honestly i prefer 8====D instead of (eggplant icon) :P

1568818305
companion_cube
or is it LC_ALL

1568818358
tgschultz
I have emotes off in my IRC client and they still show up because unicode has declared them officially something people should care about.

1568818373
fengb
I should use emojis for all of my zig variables

1568818406
companion_cube


1568818443
fengb
That's still more readable than APL

1568818451
companion_cube
ðŸ™ƒ

1568818451
fgenesis
companion_cube: thx i was looking for that one just now

1568818476
fengb
Needs more jpg

1568818480
tgschultz
Klingon, actual constructed language using characters: denied. Poop emoji: approved.

1568818511
fengb
People actually use poop

1568818581
fgenesis
now if only exploits like the just published

1568818597
tgschultz
There are probably more people using Klingon than cuneiform, or dozens of other things unicode accepted.

1568818603
companion_cube
tbh emojis are actually useful, just not that much in tech discussions

1568818613
tgschultz
I think unicode is a bad standard, is I guess what I'm expressing.

1568818645
fengb
Cuneiform is probably used to express historical context

1568818660
fengb
Klingon isn't used outside of very very niche circles

1568818674
fengb
The line is arbitrary, but it has to be arbitrary somewhere

1568818690
tgschultz
I'm sure, but how often does one need that represented by a universally unique identifier in a string?

1568818703
fgenesis
same as zig arbitrarily not nupporting XP? D:

1568818710
fgenesis
*supporting

1568818728
fengb
Microsoft doesn't support XP...

1568818746
fgenesis
i'm just starting to support 98

1568818798
fengb
Cuneiform can also be used as adhoc emoji so double win! ðŸ‘º

1568818803
fengb
There's no troll emoji

1568818813
companion_cube
ðŸ˜

1568818815
fengb
I should request one

1568818826
fengb
That's just smug

1568818851
fengb
I suppose upsidedown is often used for troll

1568818857
companion_cube
or ðŸ¤”

1568818875
fgenesis
(empty box)

1568818884
fgenesis
very troll

1568818886
fengb
I just want Kappa inducted into unicode >_>

1568818911
fengb
It's meta trolling

1568818917
fengb
I feel like I'm the source of all the tangents in this room >_>

1568818934
companion_cube
and I, me

1568818942
companion_cube
why isn't there a off? :D

1568818949
fgenesis
it's a sin, cos you're tan

1568818967
companion_cube
that's a bit hyperbolic, fgenesis

1568819083
donaldallen
Is there a way to create self-referential structs in zig?

1568819102
fgenesis
use @This() inside the struct?

1568819109
fgenesis
or @Self() or whatever that was

1568819127
fengb
Field pointers work. Non-pointers don't make sense because the memory layout would be literally infinite

1568819168
andrewrk
donaldallen, yes but until

1568819174
donaldallen
I want a struct that has a field that is a pointer to an instance of the same struct.

1568819199
andrewrk
but clearly you can do, e.g., node.next = node;

1568819239
donaldallen
Ok, I'll have a look at the issues to see if they pose a problem for me. Thanks.

1568819264
fengb


1568819280
mq32
<fengb> That's still more readable than APL

1568819290
mq32
that sentence is invariant. you can apply this to

1568819321
mq32
but APL is kinda awesome

1568819323
fengb
I'm sure we can make an APL++ :P

1568819521
mq32
andrewrk, scientes: i'm really excited for the vector/simd merge!

1568819557
fgenesis
so it's an autovectorizer, or..?

1568819585
fgenesis
simd vector types as bultins?

1568819629
waleee-cl
If you think APL is bad, wait till you see Agda

1568819646
donaldallen
@fengb Linked list example very helpful.

1568819647
waleee-cl
In APL you at least cannot define new unicode operators

1568819672
mq32
fgenesis: zig has support for @Vector(4, i32) SIMD types

1568819691
mq32
so you have native SIMD type support in the language that gets emulated on non-simd platforms

1568819700
fgenesis
noice

1568819728
andrewrk
it's a lot easier for the compiler to devectorize vectorized code than to vectorize non-vectorized code

1568819757
fgenesis
wait so you can @Vector(64, i32) for maximal wideness and it gets properly translated into AVX2 if you have that?

1568819764
andrewrk
yes

1568819797
fgenesis
andrewrk: saw that at a university project back in the day. the thing took DAYS to vectorize a recursive raytracer, and it did a horrible job

1568819840
fgenesis
very nice tho

1568820108
companion_cube
llvm does vectorize a bit

1568821716
gonz_
Does anyone else find that they're fiddling more with trying to get zig to not optimize everything away than discovering what they're trying to discover on godbolt?

1568821777
gonz_


1568821802
andrewrk
gonz_, you have to relate the input to the output. use an export function instead of main

1568821982
gonz_


1568821986
andrewrk
gonz_,

1568822297
gonz_
Using godbolt is an art form

1568822882
gonz_
Anyway, in contrast to other forms of embedding you don't have to own either the interface or the data type to provide a function in this case.

1568822909
gonz_
If there was an `Element` deeper in the hierarchy there would be no weird language rule that said it had to use a certain keyword or be in the top level of the struct

1568822992
gonz_
`hasField` could never replace it in terms of usefulness

1568823043
halosghost
waleee-cl: I love agda

1568823060
halosghost
waleee-cl: that functions and operators are the same thing is absolutely lovely and I wish more languages embraced it

1568823078
companion_cube
crystal does it too, woo

1568823085
halosghost
waleee-cl: it's the only language I know of where not only can you define your own operators, but you can define operators with higher arity than 2

1568823103
halosghost
companion_cube: really? can it define ternary operators?

1568823106
andrewrk
ya'll are lucky zig even has the + operator

1568823127
companion_cube
halosghost: I don't think so

1568823133
halosghost
andrewrk: lol

1568823143
companion_cube
andrewrk: did you mean "y'all" ? :p

1568823158
halosghost
companion_cube: yeah; that doesn't shock me. like I said, agda's the first language I've seen to support it

1568823165
halosghost
but I love it

1568823168
halosghost
:)

1568823170
companion_cube
it's basically only in proof assistants

1568823177
fengb
Dirty yank doesnâ€™t know how to spell yâ€™all

1568823179
companion_cube
(pretty Coq has something similar)

1568823195
companion_cube
fengb: exactly

1568823252
andrewrk
zig is not a DSL for math; it's a DSL for machine code

1568823270
halosghost
andrewrk: so I can't have my ðŸ¼ operator? ):

1568823283
halosghost
/sarcasm (mostly)

1568830744
Sahnvour
andrewrk: can I presently have a build step that produces a library, and another step building an executable that uses said library with its header ?

1568830776
andrewrk
Sahnvour, if I remember correctly that works and even has test coverage

1568830793
andrewrk
and using the build API will automatically set up the directories and such to make that work

1568831653
Sahnvour
ok so I just need to find the right function, cool

1568831684
Sahnvour
I find the build system is the hardest part of zig's library to grasp without doc

1568831686
andrewrk
I think foo.linkLibrary(bar) should do it

1568831705
andrewrk
agreed. the interface is a bit arbitrary and the declarative nature is not clear

1568831748
andrewrk
that function automatically sets up a step dependency, include directories, and inherits dependencies on system libraries

1568831776
Sahnvour
andrewrk: seems to work :) thanks

1568831800
andrewrk
there will be some breaking changes with the package manager as well

1568831838
Sahnvour
iirc someone also mentionned adding vcpkg support, do you know more ?

1568832164
andrewrk
detecting sytem packages is in scope. linkSystemLibrary should be improved to handle the use case

1568833624
DixiE76
Hi, I am new to Zig and was wondering if there's a common directory in which I can place libraries so that the build system will be able to link with them and locate headers when provided with a line like `exe.linkSystemLibrary("LibName")` in build.zig

1568833705
DixiE76
To clarify, this is on Windows

1568833735
andrewrk
DixiE76, you can give --library-path and -isystem args to zig so that it can find your system libraries

1568833748
andrewrk
there is no standard on windows

1568833764
andrewrk
the planned package manager will help with this

1568833879
DixiE76
That's a small shame. Is there an ongoing repo for the package manager or is it not quite at that stage yet?

1568833952
andrewrk
not quite at that stage yet. In this release cycle (0.5.0 is to be released sept 30) the groundwork is laid; in the next release cycle we'll have std lib networking, and then finally start on the package manager

1568833992
andrewrk
the good news is that the package manager can be almost entirely self-hosted

1568834100
DixiE76
That sounds quite exciting, I'm jumping it at an interesting time. Is the Master documentation on the website a decent reflection of current state leading up to 0.5.0?

1568834342
andrewrk
yes

1568834359
andrewrk
there will also be comprehensive release notes available when 0.5.0 is released. I've started typing those up already

1568834410
andrewrk
you can see there were quite a few release notes for 0.4.0:

1568834597
DixiE76
Very cool, thanks for your hard work. I appreciated the doc page very much as well and will no doubt refer back to it quite often

1568835174
mikdusan
heh I mounted a tiny ramdisk for building zig (cmake's build dir). all kinds of fast

1568835543
fengb
Builds are super snappy now that we use zig build for userland files

1568835572
fengb
Oh I've also been spoiled by NVME >_>

1568835583
scientes
only if you have butt-loads of ram

1568835862
andrewrk
scientes, I think I'm going to be able to merge 5 ish commits from your SIMD patch set today. I started with the first and have been working my way towards the last. Would you be willing to chop off the merged commits & rebase after today?

1568835888
andrewrk
(after they land in master)

1568835916
andrewrk
basically I'm treating the pull request as a priority queue of commits

1568835956
andrewrk
after each one I have a few fixups

1568836272
andrewrk
I think if we move std/ into lib/ then zig's feature where it looks for lib files will correctly find them directly from source with no install step necessary, if the build directory is a subfolder inside the source dir

1568836308
andrewrk
then this step can be removed from make. as long as `make install` does the right thing we will be good

1568836369
andrewrk
no PRs for that plz, the hard thing about that is only the timing of when to do it

1568837922
andrewrk
Sahnvour, question about hash.auto_hash.test "testHash vector" which is failing in my branch - why is [_]u32{ 1, 2, 3, 4 } not allowed to hash to the same value as [_]u31{ 1, 2, 3, 4 } ?

1568838034
andrewrk
it seems weird to make guarantees about what will or won't hash to the same value across different types

1568838405
andrewrk
this is the proposed diff which I will go with unless you have an objection:

1568839316
Sahnvour
andrewrk: I think it was expected to have different results because the u32 one has no padding bits in it and can be hashed as a []u8, whereas the u31 one has to use the iterative hash api, which (at some point) had different results

1568839334
Sahnvour
cf fn hash() for .Vector

1568839353
Sahnvour
maybe it's not relevant anymore since tiehuis improved our wyhash implementation

1568839383
andrewrk
I think the typical usage will be comparing hashes for the same type

1568839387
Sahnvour
I agree with your diff

1568839393
andrewrk
ok

1568839776
drasko
`in the next release cycle we'll have std lib networking, and then finally start on the package manager` - what will be actually available in stdlibs as networking primitives? Sockets, TCP server, UDP server, HTTP server?

1568839818
drasko
andrewrk, ^

1568839901
andrewrk
sockets / TCP/UDP server is low level enough to belong in std lib. HTTP client is needed by package manager, and will need to be tested... which menas we need an HTTP server

1568840099
companion_cube
do you really need the tests to be self hosted as well?

1568840336
andrewrk
not at first

1568840353
andrewrk
but it certainly makes them more likely to get run

1568840360
companion_cube
:D

1568840370
companion_cube
I guess it's a fair point

1568840418
companion_cube
even a basic http1.1 server can be useful, I imagine, if it's going to be behind nginx

1568840437
andrewrk
especially for tests

1568840476
andrewrk
mocking a server is a pretty good way to do integration tests

1568840676
companion_cube
I imagine it could also serve docs, then

1568840690
companion_cube
`zig serve docs` so you get them on localhost:8000 or something

1568840726
andrewrk
I don't think it's unreasonable to have an http server in the std lib

1568840752
andrewrk
whether or not it eventually gets moved to a package is also a fair consideration

1568840785
companion_cube
I guess a basic http  parser isn't actually that hard, yeah

1568840833
andrewrk
it's also a good demonstration of how to write such a thing such that it handles errors & allocation correctly

1568840846
andrewrk
and async

1568841868
_Vi
Is there such thing as Zig REPL?

1568841905
_Vi
(to navigate around available fields of something using tab completion)

1568841924
andrewrk
no:

1568842080
THFKA4
there's

1568842350
_Vi
There's `zig-clap`. Can there be `zig-structopt` (command-line interface definition by specially annotated struct, where doccomment automatically gets populated to --help message)?

1568842480
andrewrk
_Vi, here's the proposal for exposing doc comments to @typeInfo:

1568842495
andrewrk
there are also 2 proposals open for adding "labels" or "tags" to struct fields

1568842517
andrewrk
here is what is already available via @typeInfo:

1568842567
companion_cube
it's trendy to have some form of attributes on AST nodes, indeed

1568842579
companion_cube
(including one for the doc, for uniformity)

1568842586
companion_cube
but also, for serialization, etc.

1568842587
_Vi
No doccomment in metadata? What are they used for for now? Is there automatic html doc generator?

1568842651
_Vi
If there are not proper meta-attributes support, then doccomments would be used as ad-hoc attributes.

1568842680
andrewrk
_Vi, not yet but that's the plan:

1568842689
andrewrk
that issue is easy to find; it's the oldest open issue

1568842710
andrewrk
I don't want people using doc comments as ad hoc attributes

1568842714
_Vi
How much of Zig currently lives in Github Issues instead of the source code itself?

1568842730
andrewrk
are you asking how much of it is vaporware?

1568842749
andrewrk
or.. how much is left to do?

1568842785
_Vi
(Remembering asking about Tahoe-LAFS, where there are Trac issue for every idea that comes to mind, but most are multiple years unimplemented)

1568842793
andrewrk
the language reference is up to date and describes status quo, tested features

1568842832
andrewrk
every github issue is associated with some incomplete task

1568842871
andrewrk
so... decide for yourself. there's a table of contents in the lang ref, and labels & milestones to help navigate github issues

1568842877
_Vi
(about #21) Maybe exposing doccomments in TypeInfo can be the first step? Actual generator may be just a special comptime call from the source itself.

1568842888
andrewrk
you can get a sense of how fast things progress with the release notes from previous releases

1568842919
andrewrk
we've considered this approach at length. it's a dead end.

1568842950
andrewrk
did I do a writeup on

1568842989
andrewrk
sort of a bit here:

1568843283
_Vi
How "milestone" things are used on Github issues for Zig? I see a milestone attached to issues very often, but I also see milestone bumps often.

1568843365
andrewrk
milestones represent the current plan for when things will be done. however zig is currently released on a schedule, so the progress of time means things have to get postponed

1568843382
andrewrk
I'm currently a few days behind on postponing issues

1568843478
_Vi
So for now the thing to stuff with meta-things is `StructField.name`. Is having special trinkets at the end of identifier name for poor man's tags for metaprogramming "zen"?

1568843562
_Vi
[about milestones] Does all worthy things get a next version milestone, or some ideas explicitly milestoned e.g. 3 versions ahead, knowing it won't be done soon?

1568843620
andrewrk
milestones are: current release cycle. next release cycle. 1.0.0. 1.1.0

1568843651
_Vi
OK.

1568843804
_Vi
Documentation mentions for booleans: `warn("{}\n{}\n{}\n",  true and false,   true or false,  !true);`  What is `!true`? Just "not true" (i.e. false) or it is related to `!` error handling?

1568843854
_Vi
On one hand this place is logical place to introduce logical "not". On the other hand, it is queer that `and` and `or` is letters, but `not` is sigils.

1568843860
andrewrk
this table of operators is complete:

1568843887
Tetralux_
Also yes, it means false.

1568843934
Tetralux_
I find it especially useful for a constant that toggles special behavior (e.g. profiling); it's nicer to just put or remove the bang than it is to change the word 'false' to 'true', for instance.

1568843982
_Vi
What is rationale for using `!` instead of `not`?  Keep it congruent with `and` and `or` and leave `!` just for error processing things...

1568844020
_Vi
Like if somebody wants to get away from C legacy in operators, but still cannot overcome some inertia...

1568844045
andrewrk
`and` and `or` modify control flow

1568844078
andrewrk
all keyword operators modify control flow

1568844090
andrewrk
no control flow is modified without keywords

1568844114
scientes
which is why | and & have to work on bool (or at least vectors of bool)

1568844123
_Vi
OK, now understand. At first I though it's like Perl's `elsif` - just because of author wants so.

1568844140
scientes
because a() | b() is differn't from a() or b()

1568844172
andrewrk
scientes, I'm thinking that `and` and `or` will be compile errors with vectors, what about you?

1568844182
scientes
andrewrk, that's what I have

1568844187
andrewrk
sounds good

1568844206
scientes
but if a() and b() return bool, a() | b() and a() or b() are differn't

1568844211
andrewrk
I'm merging 76f53960778e84ab49730edb77b85490b07fbea2 (@byteSwap) now, that's probably all I'll have time for today

1568844213
scientes
the former always executes b()

1568844227
scientes
I read your fixups and was really happy with them

1568844238
andrewrk
oh good

1568844256
Tetralux_
What's that one about?>

1568844271
andrewrk
Tetralux_, SIMD

1568844286
Tetralux_
Hmm.

1568844354
_Vi
Is Zig's `unreachable` more like Rust's `panic!()` or like Rust's `std::hint::unreachable_unchecked()`? Does it depend on `--release-safe`/`--release-fast`?

1568844395
scientes
_Vi, it traps with debug safety

1568844425
scientes
which is how assert() is implemented

1568844429
_Vi
scientes, Is it guaranteed to trap with `--release-safe`?

1568844435
scientes
yes

1568844447
Tetralux_
Short version: It's kinda like noretyurn; it means "If you reach here in safe modes, abort.

1568844448
scientes
well, unless you use @setRuntimeSafety(false);

1568844454
Tetralux_
noreturn*

1568844480
andrewrk
scientes, I really like what you did with ~ for @shuffle

1568844488
_Vi
`@setRuntimeSafety(false)` -> Does it mean safety can be partially enabled - for some parts of the project yes, for other modules no?

1568844522
andrewrk


1568844534
scientes
_Vi, the point is that well-debugged performance critical code, like a hash table, can be compiled for performance

1568844550
andrewrk
_Vi, yep that's the idea

1568844581
Tetralux_
@setRuntimeSafety(false) means "Disable runtime safety (like bounds checks) for the current scope. (but only this scope - i.e: it won't propagate into function calls.)

1568844591
_Vi
Is three some special option like `--debug --force-safety` to temporarily disable that `@setRuntimeSafety(false)`? The reverse can also be useful.

1568844646
andrewrk
that's a good question and I've thought about that but not done anything about it so far

1568844658
_Vi
By the way, is language-level sandboxing in Zig (using it's safety features) a considered idea?

1568844671
Tetralux_
What does that mean?

1568844682
andrewrk
_Vi, that is not a feature that is available or planned

1568844720
_Vi
Tetralux_, It means compilation and running of untrusted user-contributed code with main security at API level - what imports are available and what is not.

1568844720
andrewrk
it means you could use the language to guarantee that, e.g. a function call and everything it calls is limited to a white list of things it can do (no wild pointer access, no inline assembly, etc)

1568844756
andrewrk
_Vi, I'm not sure that has been explicitly proposed so far. you are welcome to do that

1568844787
_Vi
Tetralux_, Examples: WebAssembly, Safe Haskell (maybe), some Java things (maybe?), JavaScript in browsers...

1568844796
Tetralux_
Sounds like a VM.

1568844807
andrewrk
zig does support web assembly

1568844810
Tetralux_
Or, in andrewrk's case, a builtin.

1568844820
Tetralux_
Or other related compiler analysis.

1568844844
Tetralux_
andrewrk's version is more like the opposite of 'unsafe' in Rust.

1568844851
Tetralux_
i.e: 'safe { ... }'

1568844869
_Vi
Tetralux_, There can be sandboxing without VM. But it's tricky, especially with all those spectral meltdowns...

1568844911
andrewrk
zig's safety features cannot guarantee memory safety completely

1568844915
Tetralux
I'm not sure anyone could have mitigated against spectre or meltdown, even with sandboxing. That's not very clear to me.

1568844954
Tetralux
But sure - I could see that being a use for being able to hook into the compiler

1568844985
Tetralux
"Please compile this file, but tell me about certain things so I can prevent certain behavior"

1568844986
_Vi
"Safe language" is juts a first step in language-level sandboxing.    Is there any LLVM-based programming language targeting native code that is designed around language-level sandboxing?

1568845001
Tetralux
One of the options that you could enable could be this.

1568845022
Tetralux
Those two things sound separate?

1568845049
Tetralux
Or well - no - I think I see what you mean .

1568845052
andrewrk
D has some of these features

1568845065
andrewrk
Rust is the most noteworthy contender

1568845078
Tetralux
You thinking of the 'return scope int x' func args?

1568845092
_Vi
andrewrk, I remember opening discussion about sandboxed Rust.

1568845105
andrewrk


1568845180
kristoff_it
hello everyone!

1568845190
andrewrk
o/

1568845218
Tetralux
o/

1568845252
companion_cube
\o

1568845276
kristoff_it
andrewrk: WRT async / await, I was able to get simple usage of the redis client work first shot. Once I moved into more complex stuff I got segfaults and a "non dominating instruction" error

1568845282
kuon
What do you think of the pipe operator? like foo |> bar |> joe being joe(bar(foo))

1568845296
andrewrk
kristoff_it, I'm aware of both those issues; working on it

1568845297
kuon
I have been working with elixir and elm lately, and I really like it.

1568845330
andrewrk
kristoff_it, was your experimentation before or after cf4bccf76566ac112f9142863c3e4dbf81e71d08 ?

1568845332
presiden
what does language-level sandboxing means?

1568845370
kristoff_it
andrewrk: yeah I remember you mentioned that stack traces were not working, I didn't push further also because of that, I remembered your recommendation to wait

1568845373
Tetralux
presiden: It means sandboxing, that the compiler enforces on Zig code.

1568845456
presiden
by limiting the feature that available?

1568845461
presiden
in sandbox mode?

1568845513
andrewrk
yes; for example one would probably disable @intToPtr

1568845526
_Vi
presiden, It means accept user code, compile it (guranteed not to crash or hang compiler), run it (guranteed not to access only allowed API) security, without any hardware or OS sandboxing.

1568845538
_Vi
*securely

1568845586
_Vi
presiden, Imagine Java's `SecurityManager`, but the one which actually works, and for native code.

1568845610
Tetralux
_Vi: You mean at runtime?

1568845618
kuon
isn't that kind of security feature best left to the OS?

1568845620
Tetralux
Like, compiler as a service, style thing?

1568845657
_Vi
Tetralux, What at runtime? Decisions to allow or forbid particular API? Not necessarily...

1568845688
Tetralux
It's not clear to me who the "user" is in your description.

1568845714
Tetralux
But I'm reading it as "Build a program which loads code at runtime and compiles it, but it runs sandboxed.

1568845724
Tetralux
i.e: Like what Lua is used for now.

1568845740
_Vi
Tetralux, Compiler as implementation detail... Imagine an embedded computer without operating system and without MMU. You need to run untrusted code on it, and the code must be fast and aggressively optimized (so no interpreted or VM). You need language-level sandboxing.

1568845834
kristoff_it
andrewrk: just checked, I did have that commit.

1568845873
andrewrk
kristoff_it, noted. yeah I experimented a bunch with the segfaults. I think there's some kind of thing going on with stack probing but I need to investigate further

1568845903
andrewrk
it's not normal for programs to access e.g. 7 MiB offset from the stack pointer, but with zig's async/await it makes perfect sense

1568845924
andrewrk
so we may need to ...negotiate... with the OS to make it work

1568846061
_Vi
What `type` type becomes at runtime? Some integer tag?

1568846066
Tetralux


1568846070
Tetralux
Like, nothing abstract about that xD

1568846081
andrewrk
_Vi, values of type `type` are only available at compile time

1568846129
_Vi
andrewrk, How to interpret this documentation snippet then: `const normal_bytes = "hello";   assert(@typeOf(normal_bytes) == [5]u8);`. This looks like a run-time assert.

1568846130
andrewrk
Tetralux, the use case divides the code into 2 components: a trusted component, and an untrusted one

1568846172
andrewrk
_Vi, indeed it is, although it would work just fine to put `comptime assert(...);` there. The code gets compiled down to assert(true);. See also

1568846198
Tetralux
andrewrk: Indeed; depending on exactly how it's set up, I'd essentially boil down to little more than a build option though.

1568846236
Tetralux
It'd

1568846256
Tetralux
.. And how one program just runs the compiler at runtime.

1568846260
Tetralux
"Let's get meta up in here!"

1568846350
_Vi
Does it collapse to `assert(true)` even in debug mode?

1568846372
kristoff_it
_Vi: types evaporate during compilation. At runtime you are left with a bunch of unptyped bytes, but you know that the operations on those bytes make sense because the compiler was able to confirm that at comptime (when types were still a thing).

1568846378
_Vi
Isn't replacing `x == x` with `true` an optimisation to be triggered not every time?

1568846389
kristoff_it
if that's what you were asking

1568846447
Tetralux
The expression runs at comptime because the expressions are both constants.

1568846455
kristoff_it
_Vi: in that specific case, those are both types, they have no runtime representation so it has to be solved at comptime

1568846457
Tetralux
And so it evals to the constant 'true' for runtime.

1568846468
_Vi
Can there be situations in which the code compiles in release mode because of optimiser removes code involving types, but fail to compile in debug mode because of types get retained?

1568846507
kristoff_it
yes

1568846522
Tetralux
kristoff_it: Can you name an example?

1568846555
andrewrk
if (builtin.mode == .Debug) @compileError("foo");

1568846567
kristoff_it
yeah andrew beat me to it

1568846595
Tetralux
That doesn't fail in debug

1568846598
kristoff_it
but if you have a "type that gets retained", you actually get a "this variable must be comptime" error

1568846635
andrewrk
debug mode is unrelated to types

1568846654
Tetralux
andrewrk: That's what makes it a bad example xD

1568846780
kristoff_it
_Vi: experiment with the language a bit more, you will start to get an idea of what you can do or not do. On paper what you're saying is reasonable, but once you write a few programs you'll get a better "gut feeling" of how types interact with the rest of the ecosystem

1568846847
_Vi
Types and values are closer to each other in Zig compared to other compiled languages I used...

1568846994
_Vi
Are there niche-filling layout optimisations in Zig besides optional pointers?

1568847005
andrewrk
_Vi, if you prefer video form to documentation, I go over the motivation and reasoning behind this in this talk:

1568847275
kristoff_it
So I just pulled from the master branch and now one more test passes, but I still get a segfault for the more "complex" stuff. This is the code

1568847323
kristoff_it
andrewrk: last time only tests 1 and 2 worked, 3+ caused various problems. Now 3 passes, but 4+ still have to be commented out in order for the program to run

1568847372
andrewrk
kristoff_it, I'll have a look at these after the test cases I'm working on pass

1568847474
kristoff_it
I suspect that I might have an error in 4 when defining FrameType, but I'm not sure.

1568847477
kristoff_it
andrewrk: thanks!

1568847877
andrewrk
scientes, this should be separate from your SIMD stuff, but I think @byteSwap should be defined to operate relative to the ABI size, not the size_in_bits

1568847961
andrewrk
I'll make a proposal later tonight, but a good example is u24. instead of @byteSwap(u24, 0x123456) -> 0x563412; I think it should be @byteSwap(u24, 0x123456) -> undefined

1568848182
Tetralux
Sounds like something that should be safetychecked.

1568848570
THFKA4
there are no guarantees on how an array of u4's is going to be packed, right? each element is still likely to use 8 bits?

1568848906
THFKA4
basically trying to do what the docs call "slice narrowing" with weird sizes

1568849250
scientes
andrewrk, LLVM packs the bits

1568849269
scientes
ooo, you mean zero fill?

1568849392
scientes
hmm, I'll read the proposal, cause llvm doesn't implement byteswap for u24 or u56

1568849407
scientes
i felt that was zig does was an improvement

1568850009
fengb
THFKA4: arrays are padded. There's a PackedArray in std

