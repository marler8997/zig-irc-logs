1613001631
andrewrk
yeah look at the orange dot on

1613001652
andrewrk
if you go to details on the azure one you'll see linux is still building

1613001671
andrewrk
or being tested rather

1613001675
marler8997
ok cool, so after CI is done it automatically deploys

1613001686
andrewrk
yes, only if all checks are green

1613001723
andrewrk
right now we need to update

1613001822
marler8997
andrewrk perfect!

1613001841
marler8997
let the propogation of {s} begin

1613001846
andrewrk
indeed :)

1613002156
ifreund
that will make updating my stuff from 0.7.1 to 0.8 much more plesant :)

1613002223
andrewrk
yeah it was a mistake to do the former change without the latter, IMO, sorry about that.

1613002458
ifreund
no worries here, I haven't hit any major enough issue on 0.7.1 yet to consider moving river and its deps back to master zig

1613002566
andrewrk
yeah hopefully river can stay on releases from now on :)

1613002579
fengb
How do I get the obj file path from build.zig?

1613002633
marler8997
andrewrk, hate to say "I told you so"...not really  though :)

1613002687
andrewrk
fengb, the path is not determined until the build starts happening (after the script finishes running). if you need it in other commands, there are special case ways to reference it, such as RunStep.addArtifactArg. otherwise you can use setOutputDir to force the output path to be something you know ahead of time

1613002880
andrewrk
fengb, if you use setOutputDir how this actually works is that it additionally copies the files from zig-cache/ to the output dir that you set

1613002884
ifreund
andrewrk: I'm off for the night so don't worry about conflicts for 792

1613002897
ifreund
7920, will see what you've left me in the morning

1613002897
andrewrk
ifreund, roger that. thanks!

1613004253
fengb
Ah cool, setOutputDir worked. Thanks!

1613007346
daurnimator
marler8997: looks great :)

1613007355
daurnimator
marler8997: I would do it only if

1613007376
daurnimator
marler8997: I remember windows have a couple of weird ones where there were enums mashed together weirdly

1613007400
marler8997
what kind of weird?

1613007431
daurnimator
like enum `FOO` has members FOO_A, FOO_B, FOO_C, BAR_D, FOO_E

1613007448
marler8997
eww

1613007461
marler8997
well luckily I didn't have any conflicts yet

1613007483
daurnimator
I don't think you'll have conflicts, but my point was to only strip if all enum members have the same prefix

1613007503
marler8997
right, I'm not sure what I like better yet

1613007526
marler8997
like, imagine they accidently included a bad value, now all the names are messed up

1613007565
marler8997
it's always easy to add corner case handling as well

1613007572
daurnimator
marler8997: ha. yeah they've done that too... see e.g. WinsockError in `lib/std/os/windows/ws2_32.zig`

1613007649
daurnimator
at first the prefix was WSA_, then they apparently dropped the underscore

1613007738
marler8997
yeah, they got some geniuses over there are Microsoft

1613007766
daurnimator
then some decades later they brought the underscore back again

1613008061
marler8997
interesting I don't see the error codes in the metadata

1613008110
marler8997
the win32metadata project is still pretty new, they'll probably get added in later

1613012594
v0idify
ugh i wish we had some kind of gui on zig

1613012596
v0idify
like fyne.io

1613014528
tdeo
marler8997: from what i can tell in zigwin32, you use ?*opaque{} where the bindings specify an unknown type pointer, have you considered using ?*c_void instead? from what i understand it's impossible to pass a pointer to a function taking an anonymous ?*opaque{} without some weird typeinfo hackery

1613014570
marler8997
tdeo yeah I actually already ran into that and changed it to ?*c_void for things like function parameters

1613014589
marler8997
but maybe there are some cases still using ?*opaque{}?  Can you point me to the one you're seeing?

1613014700
tdeo
marler8997: there are a lot, i'm looking in system_services.zig

1613014730
marler8997
I see it on types but I don't see any as function parmaeters

1613014742
tdeo
like FindResourceExW

1613014755
marler8997
ah

1613014777
marler8997
problem is here then:

1613014792
tdeo
imo it should be c_void everywhere

1613014796
tdeo
is there a reason otherwise?

1613014820
marler8997
I think *opaque{} might make sense for things like HANDLE and the like?

1613014832
tdeo
in c, handle is a typedef to void *

1613014837
tdeo
and hmodule is a typedef to handle

1613014873
tdeo
i mean, from my initial impression it'd cause many more problems than it'd help

1613014878
tdeo
but i might be wrong

1613014893
marler8997
what kind of problems do you forsee?

1613014919
tdeo
so many @ptrCast()s that seeing them becomes meaningless

1613014938
marler8997
right, that would have to happen in some cases, not sure how many

1613014979
marler8997
fixed

1613015000
tdeo
nice, will try out porting a thing i wrote in c to zig now

1613015215
marler8997
cool is it public? link?

1613015297
tdeo
haven't made it public because it's not cleaned up yet, but the c version is here

1613015302
tdeo
extracts text from games

1613015376
marler8997
like, the strings from a .exe file?

1613015478
tdeo
the text that is currently displayed on screen usually, by hooking a given function and collecting what text goes through it

1613015542
marler8997
oh interesting, what do you use that for?  Like making bots?

1613015576
marler8997
nice, I see some assembly written in hex :)

1613015683
tdeo
for looking up text in japanese games while playing, since unlike english it's hard to look up a word without knowing it already

1613015712
tdeo
it's not the first program of its kind, but i didn't like the others and wanted to make something simple

1613016855
tdeo
marler8997: i'm missing a constant, PROCESS_QUERY_LIMITED_INFORMATION, i'm not sure if that's win32metadata's fault or not

1613016861
tdeo
from winnt.h

1613016874
tdeo
let me know if it's too early to be asking about issues, though

1613023351
marler8997
nope not too early, that's great someone is exercising this code, let me look

1613023429
marler8997
yeah looks like its not in win32metadata

1613023530
marler8997
I don't see any of flags from

1613023661
marler8997
I've created an issue:

1613023686
marler8997
when there are things missing, I've been putting them in missing.zig

1613024253
marler8997
I've added them here:

1613024300
andrewrk
ifreund, I didn't make any progress today on the zig fmt stuff

1613037005
ifreund
andrewrk: no worries! I think I'll try my hand at line comments today

1613050460
ismaell
hello

1613050520
ifreund
o7

1613050549
tane
hello

1613050557
tane
ifreund, seen your talk at fosdem (if it was you), nice one :)

1613050577
ifreund
tane: yep, the wayland one was me :) Thanks!

1613050599
tane
\o/

1613050620
ismaell
can I prevent you guys from implementing a package manager? :P

1613050643
ismaell
the language is neat, but it feels to me that every new language gets into these areas that IMO make them into a mess

1613050648
dutchie
are the fosdem talks posted anywhere yet? I don't see anything on

1613050648
ifreund
heh, people have already written a couple

1613050656
ifreund
dutchie: no, not to my knowledge

1613050673
ismaell
soon you need internet for everything, and the package manager ecosystem has no incentive to support niche operating systems, etc.

1613050709
ismaell
so it becomes an unusable mess of bloat except for big OSes where, well, you get it at least usable but no better otherwise

1613050725
ismaell
(I mean making these official, nobody cares if a package manager exists until it's mandatory)

1613050790
ismaell
we're having a conversation about languages that didn't went south at #sourcemage (linux distro)

1613050818
ifreund
if everyone was on linux then I think leaving packaging up to distros is a pretty OK way to go

1613050837
ifreund
s/linux/unix-like systems/

1613050852
ismaell
doesn't really matter

1613050859
ifreund
I totally agree that cargo, npm, etc. are horrible though

1613050869
ismaell
also, nice talk, I was there too

1613050884
ismaell
I'm considering switching away from sway now

1613050933
ifreund
that's cool to hear :)

1613050991
ifreund
ismaell: I have some degree of faith that zig will get package management "right" enough that it's not a massive PITA for distros

1613051002
ikskuh
^= this here

1613051003
ismaell
I'm not optimistic about that

1613051013
ifreund
the desire is definitely there from me and other members of the community

1613051017
DarkUranium
I don't see many alternatives to custom package managers.

1613051022
ikskuh
if so, please write down all your concerns in the github issue for the package manager

1613051025
DarkUranium
Problem is, distro versions don't match across distros (let alone OSes).

1613051028
ikskuh
also what DarkUranium says

1613051030
ifreund


1613051040
ismaell
DarkUranium: not having one at all is a better alternative than having a bad one

1613051048
ifreund
agreed

1613051061
ikskuh
ismaell: me looking at C/C++, i don't really agree. it's a horrible mess

1613051064
ismaell
DarkUranium: APIs don't match either

1613051065
DarkUranium
Debian and such, for example, might have an ancient version of some package you require, too ancient to be useful.

1613051072
ikskuh
i started just vendoring all libraries and donÄ't have any proper upgrade path at all

1613051080
ikskuh
because it's the way of the least resistance

1613051091
ismaell
DarkUranium: you can't rely on anything just working, you have to test, that's the first thing chustom package managers fail at

1613051100
DarkUranium
ismaell, that's a naive POV.

1613051105
ifreund
ikskuh: if you stick to unix like systems and rely on the system package manager, C is fine

1613051114
ikskuh
ifreund: it's not :(

1613051122
ikskuh
sadly

1613051125
DarkUranium
ismaell, your software, if successful, will be used in hundreds of different OSes and configurations. There is literally no way for you to conclusively test everything.

1613051136
DarkUranium
Best you can hope for is for the dependencies to be available. A language-specific package manager helps here.

1613051158
DarkUranium
ifreund, yeah, ikskuh is right, it's really not.

1613051162
DarkUranium
ALSO. Consider incompatible versions.

1613051181
ismaell
yeah, C makes it easy to shoot your own foot

1613051189
DarkUranium
Software A needs 2.1, software B needs 2.2. OS package managers don't typically allow installing both (except for a handful of packages where maintainers foresaw problems)

1613051192
ikskuh
that's not the problem ;)

1613051207
ismaell
the problem is you can't rely on versions

1613051216
ismaell
you need to test the ABI

1613051218
DarkUranium
ismaell, then ... what, exactly?

1613051221
ikskuh
it's the only thoing you need to rely on

1613051227
ikskuh
if you ever tried shipping a program from source for both arch and debian, you see horrors

1613051233
DarkUranium
A compatible ABI does not imply a compatible library.

1613051239
DarkUranium
Behaviour can change without ABI changes.

1613051246
ismaell
behavior is part of the ABI

1613051252
ismaell
semantics must be encoded too

1613051257
ismaell
we don't have a thing yet, but we should

1613051279
ikskuh
zig doesn't have an ABI ;)

1613051284
DarkUranium
The only way to encode all semantics is to store them all before you load the library.

1613051287
ikskuh
which will kinda solve all abi-related problems :D

1613051293
DarkUranium
... at which point, you don't need the library at runtime. It's called static linking.

1613051313
DarkUranium
You still need it at compile-time, though. So this doesn't help OS-wise (static linking helps with distribution, but not development)

1613051333
DarkUranium
(also, behaviour is not part of an ABI)

1613051348
ikskuh
ismaell: things where zig is different: you cannot distribute binary libraries/packages

1613051356
ismaell
DarkUranium: behaviour isn't implementation, and it doesn't need to be perfect, you just need some mechanism to avoid the programmer to do stupid things like name a function the same if it does a different thing

1613051356
ikskuh
except for C abi stuff (which is pretty well defined)

1613051373
DarkUranium
ismaell, yeah, you won't win on that one.

1613051386
DarkUranium
In a perfect world, sure. But in

1613051392
ikskuh
ismaell: renaming functions will break the source, except they have exactly the same API

1613051407
DarkUranium
ikskuh, eh? A rename is a change of API (also ABI, for that matter)

1613051415
ismaell
ikskuh: no, they won't, that's the point, different name different ABI

1613051428
DarkUranium
ismaell, you're missing my point.

1613051430
ismaell
and you can support more than one

1613051438
ismaell
like GLIBC's versioned mess, it works

1613051457
DarkUranium
ismaell, you need to depend on some shitty lib where behavior changed between 2.1 and 2.2. Who knows why, it could be a good reason. The "why" is irrelevant.

1613051459
ikskuh
it still only affects external dependencies

1613051463
ikskuh
which aren't build with zig

1613051474
DarkUranium
You

1613051476
pixelherodev
ismaell: most of the time, you

1613051479
pixelherodev
See: security fixes.

1613051487
ismaell
DarkUranium: but the problem arises when things compile but fail at runtime, if they fail to build that's fine

1613051503
DarkUranium
ismaell, this can be either one. You're missing the point.

1613051512
DarkUranium
ismaell, the point is: Most OSes won't provide you with both versions.

1613051513
ismaell
pixelherodev: true, there's corner cases, but that's probably on a grey area most of the time

1613051520
DarkUranium
With a very few exceptions (libpython, for example)

1613051526
pixelherodev
ismaell: not really?

1613051532
pixelherodev
90% of the time, you want the new ABI

1613051547
pixelherodev
honestly, either just statically link or ship the source

1613051555
pixelherodev
Both options are good enough

1613051558
ismaell
pixelherodev: behavior that was explicitly promised can't really change

1613051565
DarkUranium
ismaell, the ultimate point is: you cannot rely on the OS's package management. It'll be different OS to OS, and your dependencies might not exist on it.

1613051594
ismaell
DarkUranium: that's better than a package manager that simply doesn't work at all and which upstream has no incentive to support

1613051598
DarkUranium
If they do exist, it might be the wrong version.

1613051599
ismaell
(your OS)

1613051617
ismaell
DarkUranium: wrong version results in build failure, so that's equivalent to non-existence

1613051630
DarkUranium
That's a patently false assumption.

1613051640
ismaell
you need to ensure that

1613051651
DarkUranium
How do

1613051656
pixelherodev
This still breaks security.

1613051659
DarkUranium
(other than with version checks)

1613051680
pixelherodev
ismaell: your entire

1613051693
ismaell
DarkUranium: you can't test versions, you can't rely on that because the OS/user might have patched your depedency

1613051700
pixelherodev
That goal is

1613051704
DarkUranium
ismaell, so what

1613051707
ismaell
or they might be providing an alterantive implementation

1613051717
ismaell
alternative implementations must be permissible

1613051730
DarkUranium
What if the alternative implementation is incompatible?

1613051731
ismaell
pixelherodev: why?

1613051744
pixelherodev
updates are typically bug or security fixes.

1613051745
ismaell
DarkUranium: then it's not "alternative" it's something else completely

1613051748
DarkUranium
ismaell, you speak of testing. What would you rather use:

1613051757
pixelherodev
If they can't be deliveered in a timely manner, that's a fatal flaw of your package manager

1613051773
DarkUranium
ismaell: A dependency that a software package was well-tested with, and thoroughly ... or your OS's mismatched package?

1613051792
DarkUranium
ismaell, alternative implementations are just about never 100% compatible.

1613051800
ismaell
think autoconf, why do they test? because you can't possibly encode all possible versions that might work across the entirety of options available

1613051806
DarkUranium
They

1613051818
ikskuh
ismaell: when you can compile zig for your os, the official package manager will also compile ;)

1613051853
pixelherodev
honestly, the problems your discussing can be solved by just finding 1(one) person who uses a given OS to keep your package up to date.

1613051869
DarkUranium
ismaell, generally speaking, two different libraries will have different behavior even if they implement the same spec.

1613051879
pixelherodev
"OSes don't have enough manpower, so there's packaging problems" is a social problem, not a technical one

1613051880
DarkUranium
pixelherodev, you mean the dependency? Have them be a package maintainer?

1613051885
pixelherodev
The technical aspects are symtomatic

1613051890
pixelherodev
symptomatic*

1613051897
pixelherodev
DarkUranium: in large part? Yes.

1613051899
DarkUranium
pixelherodev, you're making a number of assumptions there:

1613051903
ismaell
DarkUranium: yes, but they shouldn't diverge on the defined ABI, as long as it's undefinded you can't rely on it

1613051906
DarkUranium
1) That the OS has a package manager.

1613051915
pixelherodev
If it doesn't then the point is moot.

1613051926
ismaell
also, it would be possible to provide meta-data that compiles to the OS package manager's spec

1613051928
DarkUranium
2) That the OS would even be interested in having your package in it (<-- this is a big one).

1613051934
DarkUranium
3) That all the dependencies are, and stay, compatible.

1613051934
pixelherodev
see e.g. oasis + nix

1613051941
DarkUranium
pixelherodev, see #2 & #3.

1613051948
DarkUranium
ismaell, so?

1613051956
DarkUranium
ismaell, *there are other compatibility issues than just ABI*.

1613051964
DarkUranium
How many times do I have to reiterate that point?

1613052006
ismaell
DarkUranium: right, but then you make your whole ecosystem unusable for a lot of corner cases

1613052007
DarkUranium
pixelherodev, also, good luck finding anyone for a less popular OS.

1613052033
pixelherodev
DarkUranium: then good luck finding someone using it.

1613052052
DarkUranium
pixelherodev, that's an absurdly shitty stance to have :|

1613052061
pixelherodev
but consistent!

1613052070
ismaell
the problem is when the compiler starts to rely on the packaged stuff

1613052075
pixelherodev
also, I disagree

1613052078
ismaell
if that is not done, it isn't an issue

1613052099
pixelherodev
DarkUranium: I meant that users of unpopular systems should understand that if they want more things packaged,

1613052120
pixelherodev
Not "You're using an unpopular system so screw you," but "you're using a system without many other people, so

1613052138
DarkUranium
ismaell, I mean, there's a reason versioning is a thing. The core issue, for the umpteenth time, is that OS packages: 1) are untested with your software (the particular version); 2) might be incompatible (see #1); 3) if incompatible (see #2), will typically not have compatible versions installable (be it earlier or later), because only 1 version is provided

1613052164
DarkUranium
pixelherodev, okay. But suppose I'm a user and I want to use something on my OS.

1613052178
DarkUranium
With a lang-specific package manager, I can install the deps easily, and get running in minutes (+ compilation time, I guess).

1613052180
pixelherodev
and the OS has noone else working on it? Package it yourself

1613052191
DarkUranium
With what you're saying, I have to run through hoops to get it done.

1613052219
pixelherodev
Or, if all the people contributing to the language package managers contributed to their own OSes instead, it wouldn't be an issue.

1613052221
DarkUranium
Which can be mountains of bureucracy depending on OS (and all ending with "no, the package is too new/too unknown/too unstable/wrong license/...")

1613052225
pixelherodev
What if something isn't in the language repos?

1613052227
pixelherodev
You package it.

1613052242
pixelherodev
All that language-specific package managers do is add a level of indirection

1613052246
pixelherodev
and a very poort one

1613052248
pixelherodev
poor*

1613052250
DarkUranium
The difference is that the language repo, you package it once. And as someone using the language, you know it'll be available on a myriad of OSes.

1613052260
pixelherodev
and, again, be untested on most.

1613052263
pixelherodev
That's *worse*.

1613052274
pixelherodev
the point of os repos is that packages are

1613052284
DarkUranium
pixelherodev, but your package isn't tested with the OS package.

1613052287
pixelherodev
If I install something from Debian, I know it's been tested against its dependenies *on Debian*.

1613052291
DarkUranium
pixelherodev, and what if version does mismatch? WHAT DO YOU DO?

1613052295
DarkUranium
You still haven't answered that.

1613052298
pixelherodev
Package it myself

1613052309
DarkUranium
Okay. OS says "fuck you, we won't add another version just for you".

1613052311
DarkUranium
Now what?

1613052314
pixelherodev
Use a third party repo

1613052322
pixelherodev
Like literally every reasonable OS supports

1613052330
DarkUranium
Okay, now you need to add a third-party repo for every single OS you want to support.

1613052338
DarkUranium
You need to add

1613052339
pixelherodev
No, only those refusing to suppport it

1613052341
DarkUranium
For all live versions of the OS.

1613052341
ismaell
DarkUranium: we can't fix the divergence, but at least make it work at ABI level instead, so only the subset you actually use matters, instead of relying on version checks that are most likely not carefully tailored to the requirements but just bumped for whatever is installed on the developer's machine

1613052347
pixelherodev
and in my experience, if an OS rejects somethingt, there's good reason

1613052364
DarkUranium
ismaell, ABI compat != drop-in compat.

1613052376
ismaell
DarkUranium: if you have enough information, it is

1613052383
pixelherodev
no

1613052387
pixelherodev
because then it's not the ABI.

1613052412
ismaell
pixelherodev: important behavior should be

1613052413
DarkUranium
Also, with the amount of information you're implying, you're basically talking about in-tree dependencies.

1613052418
pixelherodev
That's meaningless.

1613052431
DarkUranium
ismaell, you keep using that word. I do not think it means what you think it means.

1613052440
pixelherodev
The only thing that "should" be part of an application's

1613052442
DarkUranium
And also, yes.

1613052443
pixelherodev
Hence, ABI.

1613052457
DarkUranium
Also literally impossible. Even if you define an "ABI+".

1613052463
DarkUranium
It's only possible if you can prove no bugs.

1613052471
DarkUranium
You cannot prove no bugs (c.f. halting problem). Thus, impossible.

1613052486
ismaell
run-time behavior is inherently part of the ABI

1613052492
DarkUranium
Remember, dependencies could be incompatible due to bugs.

1613052506
ismaell
it doesn't need to be perfect

1613052508
pixelherodev
No, it's not

1613052512
DarkUranium
ismaell, no it's not.

1613052514
pixelherodev
Behavior == semantics.

1613052518
ismaell
yes...

1613052519
ismaell
so?

1613052525
pixelherodev
If behavior was encoded in the ABI, you wouldn't need machine code.

1613052528
DarkUranium
ismaell, if you're replacing a package manager, it

1613052541
DarkUranium
<pixelherodev> If behavior was encoded in the ABI, you wouldn't need machine code.

1613052544
DarkUranium
^ hence me saying: DarkUranium> Also, with the amount of information you're implying, you're basically talking about in-tree dependencies.

1613052556
ismaell
behavior is what you intend to do, not how

1613052562
ismaell
so no, it's not at all machine code

1613052567
pixelherodev
No, behavior is what you

1613052571
pixelherodev
INtention is utterly irrelevant.

1613052582
DarkUranium
A computer is not magical, ismaell, it cannot derive intention.

1613052584
ismaell
yes, "what", not "how"

1613052612
ismaell
also, it doesn't need to be complete

1613052613
pixelherodev
machine code is what you do.

1613052619
DarkUranium
(there's entire fields dedicated to trying to make computers do exactly that; but it's both an open field

1613052621
ismaell
and bugs don't matter as long as it works

1613052627
pixelherodev
ABI is just how you get to doing it

1613052633
pixelherodev
Bugs matter.

1613052644
pixelherodev
I've literally never run into a bug with an OS package manger on any OS.

1613052651
pixelherodev
Not even Debian's, to my surprise

1613052652
DarkUranium
Bugs

1613052665
DarkUranium
Sometimes, the fix will break compatibility yet again.

1613052666
pixelherodev
apt, apk, portage, pacman, etc have

1613052667
ismaell
separation of concerns, bugs don't matter to building stuff, bugs matter for integrity, for the OS, for the user, generally not for building unless they actually affect the build result

1613052672
pixelherodev
If your solution is buggy, nobody will use it

1613052687
DarkUranium
pixelherodev, er, that's very false.

1613052690
pixelherodev
also, again, even if what you want is possible, it's

1613052706
DarkUranium
There's SO MANY horrendeously buggy programs used in various industries.

1613052711
pixelherodev
DarkUranium: true, people are idiots^Wstimuli reaction devices, I keep forgetting that

1613052747
ismaell
you can't avoid bugs, and the OS will try it's best to provide up to date libraries

1613052768
ismaell
and upstream can help by providing metadata in a neutral format

1613052777
pixelherodev
Am I the only one who thinks OS package managers are actually good enough that there's zero need for a replacement?

1613052787
ismaell
but a language-specific package manager is going to do more harm than good

1613052800
pixelherodev
This might be my first unpopular positive opinion shared here :P

1613052826
pixelherodev
DarkUranium: I'd contend that your issues with OS repos are correct

1613052829
ismaell
pixelherodev: haha, I think it's not that simple, but yes, overall I agree with you

1613052829
pixelherodev
So let me ask you something

1613052838
pixelherodev
You write a new package manager to solve it, and give it new repos!

1613052842
pixelherodev
Okay, sounds reasonable

1613052847
pixelherodev
Why on earth would you limit it by language?!

1613052882
ismaell
pixelherodev: +1, and also, why not help fix existing ones instead?

1613052886
pixelherodev
See Nix, and Hermes.

1613052895
pixelherodev
OS-indepedent

1613052898
pixelherodev
Hermes is particularly neat

1613052901
DarkUranium
pixelherodev, that's a fair point. It's usually about control (a weaker argument, but).

1613052916
pixelherodev
Hermes is the only Linux package manager I actually intend to be running long term

1613052937
DarkUranium
pixelherodev, basically, it's for the same reason as to why you make your own syntax instead of inventing something else. Etc.

1613052950
pixelherodev
I'm setting up Alpine in a VM, then using it to set up Oasis in a VM, then nuking Alpine, setting up Hermes, and that Oasis image will be the final Linux disatro I ever use :)

1613052981
DarkUranium
pixelherodev, also, the language is in some cases tied to the package manager (there are both advantages and disadvantages to this).

1613052999
pixelherodev
I mean, to be fair, if npm, pip, and cargo were one thing, it'd probably be so horrendously stupid it would implode into a black hole and end human existence

1613053003
pixelherodev
So maybe it's a good thing

1613053019
DarkUranium
pixelherodev, it's also simpler when it's single-language.

1613053028
pixelherodev
Then that's a bug with the languages.

1613053033
DarkUranium
("do one thing and do it well" applies here, to some extent)

1613053034
DarkUranium
No.

1613053047
DarkUranium
What I mean is, two arbitrarily-chosen languages will, in general, not be able to interoperate.

1613053060
DarkUranium
And when they can, they will not have ready-made or automatic bindings available.

1613053065
pixelherodev
So? Many libraries cannot be used as dependencies of others.

1613053071
DarkUranium
Package managers aren't typically per-language, they're really per-ABI.

1613053072
pixelherodev
There's a very simple solution to that used in OS package managers.

1613053078
pixelherodev
*Not listing them as deps*.

1613053088
DarkUranium
pixelherodev, well, here's the thing.

1613053095
pixelherodev
Technical solutions are not needed for human problems.

1613053099
pixelherodev
Only for technical problems.

1613053100
DarkUranium
Suppose I'm writing a piece of software and I need a JSON parser.

1613053110
pixelherodev
Then you pick one you can use.

1613053114
pixelherodev
That's pretty obvious.

1613053133
pixelherodev
`bespoke search json --tags=c`

1613053138
DarkUranium
Sure. But you've just changed the selectivity of the index, so to speak (in DB terms).

1613053153
pixelherodev
not seeing the issue

1613053158
DarkUranium
That's 8 characters to both remember to type and actually type, for every. Single. Operation.

1613053162
DarkUranium
Here's the issue.

1613053176
pixelherodev
It's not eight characters lol

1613053177
DarkUranium
I don't give a fuck about Rust libraries if I need a Python one. And vice-versa.

1613053183
pixelherodev
It's one flag and the language you're using.

1613053200
DarkUranium
So

1613053207
DarkUranium
But granted, such a pkg manager would be useful.

1613053214
DarkUranium
I'm just saying there are good reasons to specialize, too.

1613053231
pixelherodev
alias definitelyacolypkgman='bespoke --tags=c`

1613053236
DarkUranium
No need to prefix everything with coyote-, for example.

1613053248
DarkUranium
(or python-/py- or c- or ...)

1613053254
pixelherodev
alias `definitelyacoyonlypkgman='bespoke --tags=coyote`

1613053285
pixelherodev
You could use UUIDs and metadata

1613053289
pixelherodev
instead of traditional categories

1613053292
DarkUranium
I suppose.

1613053300
DarkUranium
Categories will also be different from language to language.

1613053312
pixelherodev
`install json` "There are three packages available by that name. Do you want C, Java, or Rust?"`

1613053313
DarkUranium
For example, C, Rust, and Python would have your generic collection (graphics, net, .......)

1613053332
pixelherodev
UUIDs + metadata would still work to replace that easily

1613053342
DarkUranium
R will instead have fine-grained categories relating to statistics.

1613053346
pixelherodev
The user doesn't care about the UUID and will never see it

1613053356
DarkUranium
But the user

1613053359
pixelherodev
Tags can be entirely arbitrary, and the package manager would just show where they diverge, for instance

1613053361
pixelherodev
Sure

1613053364
pixelherodev
but they can filter them

1613053365
DarkUranium
And if you try to list all categories in such a system, you'll have literal thousands.

1613053367
pixelherodev
`c.foo`

1613053370
pixelherodev
`rust.bar`

1613053376
pixelherodev
the package manager hides the first part

1613053381
DarkUranium
Right.

1613053388
pixelherodev
This is all fully solvable

1613053390
pixelherodev
Trivial? NO

1613053392
pixelherodev
No*

1613053398
pixelherodev
Both feasible and reasonable? Yes

1613053405
DarkUranium
What if you need something the package manager doesn't provide?

1613053409
pixelherodev
Better than a language-specific package manager in jusst about every possible way? Yes

1613053415
pixelherodev
What if you need something not in pip?

1613053417
pixelherodev
Not in npm?

1613053422
DarkUranium
I don't mean a software package.

1613053425
pixelherodev
You

1613053427
DarkUranium
I mean a feature of the package manager *itself*.

1613053434
pixelherodev
See above.

1613053439
DarkUranium
100% false equivalence.

1613053441
pixelherodev
You're never going to have everything for everyone.

1613053449
pixelherodev
There will always be something people don't want

1613053453
pixelherodev
and things they do

1613053456
pixelherodev
Make it a library

1613053458
DarkUranium
If Python needs something pip doesn't provide, then Python can have it added to pip.

1613053461
DarkUranium
This is NOT true with a generic one.

1613053478
DarkUranium
"What, you need this feature that'll affect our entire codebase for your small toy-looking language? No."

1613053478
pixelherodev
Sure, but languages should never need pkgmanager specific features

1613053497
DarkUranium
That's not true at all. I can easily think of 2 languages that would benefit.

1613053502
pixelherodev
Examples?

1613053556
DarkUranium
One is a real one: R. Integrating a package manager can seriously ease machine learning and such. Could even be extra clever and pull new algorithms fastish.

1613053581
DarkUranium
The other is hypothetical: A provable programming language, where dependencies are found by their properties (e.g. "I need a set with O(log n) insertion and O(1) lookup").

1613053624
DarkUranium
Can go further with IDE integration (think pulling various samples for a graphics-programming-oriented language).

1613053629
DarkUranium
(or GPU kernels)

1613053679
DarkUranium
The core issue of generic software is that innovation is harder with it. Innovation is not always good (not all ideas are good), but it's nevertheless important.

1613053714
DarkUranium
This holds for protocols (it's more limiting to extend than to make your own), libraries (ditto), etc. Package managers are no exception.

1613053725
DarkUranium
This is not necessarily a major downside, mind you. It depends.

1613053727
DarkUranium
But it

1613053794
pixelherodev
I disagree - I consider that a feature :P

1613053803
pixelherodev
I don't

1613053806
DarkUranium
For example, maybe I want my package manager to have builtin support for software licenses, so that it can generate a that blob of copyright text for me

1613053809
pixelherodev
If you want them, you can build them

1613053829
DarkUranium
And how is this different from them just making their own package manager?

1613053840
DarkUranium
It's an incompatible piece of software that lives in its own walled garden.

1613053841
pixelherodev
They don't need to implement dependency resolution ;P

1613053844
pixelherodev
or build scripts

1613053861
DarkUranium
Well, now you're no longer talking about a generic, cross-language, package manager.

1613053865
DarkUranium
But rather a package manager library.

1613053870
DarkUranium
Which, BTW, is something I've been wanting to make.

1613053870
pixelherodev
but more importantly, they're not trying to get their awful ideas into real world programs

1613053883
DarkUranium
Not all ideas are awful.

1613053891
pixelherodev
Agree to disagree.

1613053895
DarkUranium
Really?

1613053899
pixelherodev
My idea that all ideas are awful? Awful.

1613053903
DarkUranium
lol

1613053906
pixelherodev
Your idea that there are good ideas? Awful.

1613053907
pixelherodev
:P

1613053919
DarkUranium
But seriously. It's sometimes important to throw things onto a wall, and see what sticks.

1613053929
DarkUranium
It's how we got away from CVS for revision management.

1613053944
DarkUranium
git ... leaves something to be desired. But I'll take it anyday over CVS or even SVN.

1613053977
DarkUranium
Zig & Coyote both are this. They're trying something new.

1613053983
DarkUranium
(every new programming language is, by definition)

1613054000
pixelherodev
git is absolutely perfect.

1613054007
DarkUranium
Ha.

1613054008
pixelherodev
The official client, thoguh? hahahaahhaa no.

1613054025
DarkUranium
Actually, even git itself has a problem --- huge repos.

1613054029
pixelherodev
With git9, there is literally no feature I miss and nothing I dislike about git itself

1613054032
DarkUranium
It slows down to a CRAAAAAAAAAWL.

1613054038
pixelherodev
--shallow

1613054040
pixelherodev
.

1613054042
pixelherodev
:p

1613054047
DarkUranium
I need to check that out. git9, I mean.

1613054060
DarkUranium
Nah, the issue is that pushing will stop then.

1613054063
pixelherodev
If you're not running plan9, it'll be useless to you ;P

1613054081
DarkUranium
Well, plan9 itself is an example, actually. Lots of innovation.

1613054090
DarkUranium
Well, more like iteration for the most part.

1613054096
DarkUranium
But also some innovation.

1613054174
DarkUranium
pixelherodev, my point is, a package manager, just like any big piece of software, is a framework.

1613054175
pixelherodev
Sure, and as I've mentioned elsewhere, one of the key reasons I like p9 is that people

1613054203
DarkUranium
Frameworks are

1613054213
pixelherodev
That's why I don't use one ;)

1613054224
pixelherodev
Half-kidding - I'm actually working on one for 9

1613054229
DarkUranium
But such a generic package manager

1613054239
pixelherodev
But all it does is find a repo you point it at, figure out deps, and invoke the mkfile

1613054249
DarkUranium
What I'm getting at is, there are reasons, good ones, to roll a custom one --- even in the presence of a generic one.

1613054253
pixelherodev
Package managers are only frameworks because people toss

1613054268
pixelherodev
If all you do is "clone, resolve deps, invoke makefile - which can invoke language-specific stuff if needed"

1613054269
DarkUranium
I'll likely do this for Coyote, because I need something lightweight (Nix & such are huge), and portable to more OSes than those two will allow.

1613054280
pixelherodev
Congrats, you've solved just about every problem real people have

1613054300
DarkUranium
pixelherodev, but what about versioning and such?

1613054301
pixelherodev
Hermes?

1613054305
pixelherodev
DarkUranium: git.

1613054306
DarkUranium
Package managers have to figure that out, too.

1613054311
DarkUranium
No, of packages.

1613054312
pixelherodev
This is for 9

1613054322
DarkUranium
Talking generally.

1613054323
pixelherodev
That's not generally an issue we face ;)

1613054330
pixelherodev
"Write better software."

1613054344
pixelherodev
Literally, you mentioned earlier that it's an issue because people will make changes without bumping version properly

1613054348
DarkUranium
My point is, they have to start assuming things about versioning & dependency compatibility (a provable language might have completely different constraints than, say, C). So now we're moving firmly towards a framework.

1613054357
DarkUranium
Yes.

1613054365
pixelherodev
I literally just use HEAD of every repo cloned.

1613054368
DarkUranium
Which might be a decent idea if it's a security fix that

1613054378
DarkUranium
lol

1613054386
DarkUranium
That's not gonna be stable, so no. You can't do that versioning in a package manager.

1613054388
pixelherodev
It's only a problem if people break their software

1613054394
pixelherodev
YOu can if all of the users are sane

1613054395
pixelherodev
:P

1613054398
DarkUranium
Right :P

1613054406
pixelherodev
Which does exempt most linux software

1613054409
DarkUranium
But I'm talking generally. I'm still on the topic of a generic package manager, vs custom.

1613054414
pixelherodev
Note that this is part of why I use 9

1613054424
pixelherodev
to avoid Linux's generall.... linuxness

1613054429
DarkUranium
My #1 concern, BTW --- and a generic package manager does

1613054439
pixelherodev
GNU ideas have infected too much of the linux world

1613054447
DarkUranium
Yes =\

1613054451
pixelherodev
I'm happy to call it GNU/Linux for them.

1613054453
pixelherodev
As a condemnation,

1613054469
pixelherodev
And yes, culture is absolutely the point

1613054478
pixelherodev
My main advantage with nine isn't technical at all

1613054480
DarkUranium
Anyways: consider pip, with relatively reasonable packages, each of them being a library or a tool, generally speaking.

1613054497
DarkUranium
Now compare: npm with a shit-ton of single-line packages, 40000-package-deep trees, and whatnot.

1613054502
pixelherodev
It's cultural :O

1613054505
DarkUranium
I'm not sure what the root cause is, but I suspect it's cultural.

1613054511
DarkUranium
Yes. And that's what scares me more than anything else.

1613054518
pixelherodev
Oh for sure

1613054531
pixelherodev
Here's the thing: you can't make a fully inclusive solution and not have to deal with people thinking that's reasonable.

1613054532
DarkUranium
How the hell do I prevent this problem? A generic package manager (such as Nix) does

1613054535
ismaell
pixelherodev: GNU has mutated over the years, it's worse now than it used to be

1613054541
pixelherodev
ismaell: I don't doubt i

1613054543
pixelherodev
t

1613054561
pixelherodev
DarkUranium: this is why my solution is "find an obscure group which has yet to be infected in such a manner"

1613054562
DarkUranium
pixelherodev: it's a tradeoff, though. You want to be inclusive from a marketing standpoint.

1613054567
tane
pixelherodev, the problem is centralization

1613054568
pixelherodev
Disagree

1613054574
ismaell
DarkUranium, pixelherodev: my concerns are more about having interdependecies between the language and the package manager, etc. I want to be able to decouple the language from everything else in a simple way, so I can build just the compiler and live with that, maybe and probably I don't need the rest

1613054593
DarkUranium
ismaell, Coyote won't depend on the package manager, if that helps you.

1613054597
ikskuh
that will always be the case i think

1613054598
pixelherodev
I'd rather deal with lower software support if it means getting a signfiicantly better culture

1613054614
pixelherodev
DarkUranium: there's one fact you

1613054622
DarkUranium
ikskuh, there are some langs that do depend on it. Isn't node one? (at least partially)

1613054623
pixelherodev
You

1613054623
ikskuh
ismaell: zig is meant to be used in a similar fashion as C, but with the fact that zig actually needs no standard library

1613054638
DarkUranium
pixelherodev, excuse me, but yes you can.

1613054639
ikskuh
DarkUranium: only talking for zig here ;)

1613054644
ikskuh
i don't care for most other langs anymore

1613054655
pixelherodev
Agree to disagree, then

1613054660
pixelherodev
ikskuh: monster!

1613054662
pixelherodev
:P

1613054665
ikskuh
seriously.

1613054668
pixelherodev
Not even... not even shell?!

1613054673
DarkUranium
pixelherodev, in 1945, we figured out how to make an atomic bomb. You get a big enough one, and

1613054673
ismaell
DarkUranium: what's coyote?

1613054673
tane
ikskuh, but your hostname tells me otherwise :)

1613054684
ikskuh
which is?

1613054688
tane
php-friends.de

1613054689
pixelherodev
DarkUranium: thank you.

1613054691
pixelherodev
For proving my point,.

1613054696
DarkUranium
pixelherodev,

1613054699
ikskuh
tane: that's actually just a damn nice hosting service ;)

1613054701
DarkUranium
Suddenly: 0 issues!

1613054706
ikskuh
it has nothing to do with php

1613054710
tane
ikskuh, just kidding anyway :)

1613054712
ikskuh
it's not even my own domain

1613054725
DarkUranium
ismaell, my own lang.

1613054727
ikskuh
<pixelherodev> Not even... not even shell?!

1613054733
pixelherodev
Or LOST?!

1613054734
ismaell
DarkUranium: link?

1613054735
ikskuh
when i can, i try to prevent shell scripts at all cost

1613054735
pixelherodev
Or asm?

1613054741
DarkUranium
ismaell, completely different goals from Zig, so.

1613054745
pixelherodev
Not even... not even SPU?!

1613054756
pixelherodev
that's a language!

1613054758
ikskuh
pixelherodev: spu is an ISA, not a programming language

1613054763
pixelherodev
Agree to disagree.

1613054770
ikskuh
nah

1613054776
ikskuh
i don't consider machine code a programming language

1613054779
ikskuh
and even then:

1613054785
ikskuh
it's an ISA; not its machine code representation :D

1613054795
ikskuh
i can get -pedantic too

1613054800
ismaell
pixelherodev: I struggle with the "new linux" culture more than the GNU culture

1613054829
ismaell
#sourcemage is nice in that we've got musl support and you don't really have to use GNU stuff if you don't want to

1613054832
ikskuh
what is the "new linux" culture?

1613054921
DarkUranium
pixelherodev, anyways, you can't resolve such issues with technology (well, you can to some extent), but what you

1613054929
companion_cube
Everything that is not Gnu, ikskuh

1613054932
DarkUranium
For example, strongly discourage people from making 3-line libraries.

1613054966
DarkUranium
And also providing a collection of vetted packages.

1613054970
ikskuh
companion_cube: thanks

1613054978
ikskuh
i want to make a "new linux" myself then, too :D

1613054978
DarkUranium
(think core packages vs -contrib, in OSes)

1613054983
ismaell
ikskuh: hard to define, but the bloat-loving kids running software they don't understand, and wrtiting more software on top of it and whatnot

1613055015
DarkUranium
ismaell, like piling 50 things on top of Docker, systemd, etc?

1613055031
DarkUranium
I've noticed Linux has been doing a rather heavy embrace/extend/extinguish lately.

1613055035
DarkUranium
Mostly Red Hat.

1613055043
DarkUranium
But others don't realize RH is doing that, so ...

1613055046
companion_cube
ismaell: I sure understand all Gnu code I run

1613055094
tane
DarkUranium, there are many issues at play that increase the likelihood of something like NPM: (1) make it easy to add packages, (ii) make it easy to include packages and (iii) have a bad and inconsistent standard library, JS+NPM satisfies (i)-(iii), rust+cargo satisfy (i)-(ii), thus resulting in wide and deep dependency trees, where you just wanted to try a small lib and got 100 small libs instead.

1613055123
DarkUranium
tane, aren't 1&2 generally good things, though?

1613055129
ikskuh
it depends

1613055130
tane
they are, but have a bad side as well

1613055137
ikskuh
zig will have 1&2 as well

1613055142
tane
I don't think it's sooo easy to add a package to PIP

1613055148
ikskuh
but: there won't be a central index

1613055164
tane
ikskuh, not having a central index will make (ii) harder already

1613055170
ikskuh
which is what most people associate with a package manager nowadays

1613055180
ikskuh
tane: true, but it will be still simple

1613055188
tane
yes, I think nuances are enough

1613055189
ikskuh
assuming the package is available via git, you can just use github :D

1613055263
DarkUranium
tane, I figured I'd have a central index (but optionally others, mind you), but split the repo into 3 parts.

1613055269
DarkUranium
I'm hoping that'd help.

1613055288
DarkUranium
Basically: official, vetted, others

1613055314
DarkUranium
(official are 100% official packages that have certain guarantees; but aren't part of core distribution for one reason or another [usually size or dependencies])

1613055326
tane
well, I wonder whether vetting could be done via signing, using established public-key technologies, building a web of trust

1613055361
DarkUranium
Not that not all packages I make will be official.

1613055373
DarkUranium
... most won't, in fact.

1613055444
ismaell
DarkUranium: yeah, that matryoshka deployment style too

1613055456
DarkUranium
ismaell, hm? What do you mean by that?

1613055486
DarkUranium
To be clear, a rule of thumb for official packages is that they'll all essentially be "extended stdlib" features.

1613055494
DarkUranium
Coyote stdlib will be minimal by design (remember: embeddable)

1613055519
ismaell
companion_cube: I didn't mean GNU with that, GNU has other problems, like ego issues, the FSF owning everything, RMS in the past dictating what projects should do on the technical side, etc.

1613055523
DarkUranium
Official packages will provide stuff for stand-alone use, though. Think a library to do HTTP requests, async I/O, that sort of stuff.

1613055525
DarkUranium
Sockets.

1613055539
DarkUranium
gtg for ~20 mins.

1613055545
tane
just a personal issue: I dislike the term "official" :D

1613055549
ismaell
DarkUranium: I meant your comment on docker, systemd, etc.

1613055587
ismaell
DarkUranium: each enviroment/library/supervisor being more complex than the thing running on top of it

1613055589
ikskuh
luckily, we only have an official source repo :D

1613055600
tane
indeed

1613055610
tane
I find the decentralized community approach good as well

1613055656
tane
this focus in the rust world on "the Rust community" is a really nice marketing scheme - and it works too, creates identity etc etc - personally I find it off-putting, but a lot of people disagree on that

1613055924
pixelherodev
I find it horrendous

1613055992
pixelherodev
well

1613056002
pixelherodev
More their particular implementation than the concept

1613056009
pixelherodev
Topic-based community, sure

1613056058
companion_cube
there's a community anyway, whether it's official or not

1613056070
companion_cube
people reading the same newsletters, watching the same projects, asking questions with the same topics

1613056078
pixelherodev
The issue isn't that there is a "rust community"

1613056083
pixelherodev
it's

1613056093
pixelherodev
pretty toxic from what I've seen

1613056152
tane
from the Rust foundation website: "As a flurry of blog posts from community leaders discussed in 2016: Rust’s product is not a programming language or a compiler. Rust’s product is the experience of being a Rust developer and it follows that Rust’s website declares its official slogan"

1613056191
pixelherodev
^

1613056193
pixelherodev
Yeah, that.

1613056194
tane
I don't need community leaders, nor do I need a new identity - I always wondered what people actually refer to themselves as "gophers" or "rustceans", but then, everyone is different :)

1613056206
ismaell
anyway, zig looks very promising, that's why I brought my concern about package management here :)

1613056218
pixelherodev
tane: fully agree.

1613056218
tane
so I'm not going spew more - I wanted to keep a more positive vibe in 2021 :D

1613056221
pixelherodev
:)

1613057781
DarkUranium
back

1613057802
DarkUranium
ismaell, ah, right.

1613057821
DarkUranium
ismaell, what really pisses me off is when projects use Docker as the only distribution method.

1613057848
DarkUranium
"Using $THING" -> "Here's how you start it with Docker ..."

1613057982
ismaell
DarkUranium: worse, they make the build depend on docker too

1613058001
ismaell
DarkUranium: so you download ubuntu + compiler + ecosystem + the code then build inside docker

1613058005
ismaell
pretty standard nowadays

1613058044
ismaell
DarkUranium: plus they make it very convenient by "curl $URL/myscript.sh | bash"

1613058050
DarkUranium
Ha.

1613058052
DarkUranium
I love that one.

1613058065
tane
docker is nice though :D

1613058091
ismaell
tane: is it?

1613058103
DarkUranium
I know other approaches are technically the same as `curl | bash` (because do you really inspect all the build scripts?), but the sheer audacity of running something in a shell straight out of the socket ...

1613058109
tane
to play around with stuff, before littering its stuff all over the system, sure

1613058131
tane
or if you want a full LAMP stack (for whatever reason)

1613058131
ismaell
DarkUranium: it would be better if the .sh came with a signature...

1613058141
ismaell
DarkUranium: but no, and in turn it downloads and runs more stuff

1613058266
ismaell
tane: you don't need docker for that; we've been doing it with tarballs and jails/chroot/VMs for ages, it does add the composability automation, but still, that hardly enough to justify the complexity

1613058297
DarkUranium
I've been using FreeBSD jails :D

1613058320
ismaell
BSDs rock, but they were too heavy in the early days, that's mainly why linux got so much traction

1613058325
ismaell
now linux is the bloated one

1613058359
companion_cube
I always heard that chroot wasn't that safe

1613058369
companion_cube
but maybe these days with linux containers it'd work

1613058376
pixelherodev
Actually, I heard there was a licensing thing that kiilled the BSDs :P

1613058384
tane
ismaell, well, you're right I guess and I'm lazy. So a student gave a presentation on how to docker, so now I can do it too :P

1613058387
ismaell
and the BSD licensing style means companies often shoot themselves in the foot with their choices when they go BSD, so a lot of us prefer GPL so they don't make stupid choices, even so they still do manage to ruin it

1613058446
ismaell
companion_cube: chroot isn't about safety, you need namespacing for that, and that's what containers actually are, but jails are namespaced so are containers :)

1613058448
pixelherodev
queue DarkUranium's "GPL is awful" rant which successfully swayed me to using MPL for my copyleft stuff :P

1613058472
ismaell
yeah, GPL has it's problems, I wouldn't deny it, but it does a good job anyway

1613058485
ismaell
I don't want another rant at it, I have even my own

1613058518
ismaell
MPL is weak, so doesn't do what I need it to do

1613058531
ismaell
GPL is the only reasonable option, sadly :(

1613058645
ifreund
pixelherodev: tldr? I like the GPL for my non-library programs

1613058651
ifreund
s/programs/projects/

1613058666
ismaell
pixelherodev: not sure about that, you mean the berkeley vs bell labs dispute? or SCO trying to sue everyone?

1613058757
ugla
There's the EUPL too, which is much like AGPL, but is available in many translations that are all "of equal value." Comes with a license compatibility matrix which is pretty handy too.

1613059431
marler8997
andrewrk, so what's holding up the new commits from getting to ziglang.org?

1613059455
marler8997
is it the ziglang.org CI issue you mentioned the other day?

1613063261
marler8997
I seem to be getting 64-bit executables with: zig build -Dtarget=i386-windows  ??

1613063288
marler8997
build.zig is using b.standardTargetOptions(.{})....so not sure what's wrong

1613063378
marler8997
oh you know what, I'm an idiot, I was calling setTarget somewhere else with .{ .os_tag = .windows }

1613068636
voldial
first time using zig, I figured I'd compile some C, it went perfectly:

1613068680
ikskuh
-fPIC afaik

1613068688
voldial
aah.

1613068818
voldial
ikskuh: I'm still doing something wrong:

1613068850
ikskuh
ask readelf if it's a pie

1613068957
ifreund
yeah don't trust file on stuff like this

1613069030
marler8997
-fPIE?

1613069167
voldial
zig: "Type: EXEC (Executable file)" gcc: "Type: DYN (Shared object file)"

1613069176
voldial
marler8997: I did:

1613069191
voldial
readelf:

1613069208
marler8997
you sent the -fPIC example, not -fPIE

1613069213
voldial
marler8997: oooo. sorry

1613069418
voldial
marler8997: no luck, tried -fPIE with and without -fPIC:

1613069453
voldial
I suppose this is a llvm thing, I'll go ask there

1613070371
andrewrk
marler8997, these failures:

1613070393
andrewrk
I'll fix it now

1613070409
marler8997
hmm, still not sure how things get deployed :)

1613070431
andrewrk
main zig CI makes a commit to

1613070467
marler8997
ah

1613070538
marler8997
I dub this new version of Zig as holy water, cleansing all it touches, starting with the ziglang.org gatekeeper

1613070612
andrewrk
lol

1613070622
ifreund
andrewrk: I think I've found a good aproach for line comments in zig fmt, still working through test cases to make sure it doesn't break down somewhere

1613070627
voldial
Is this the reasonable option parser to use?

1613070638
ifreund
it also gets rid of the renderExtraNewline() stuff :)

1613070642
andrewrk
ifreund, nice!

1613070653
andrewrk
marler8997, I'll poke Loris to update the doctest repo

1613070658
marler8997
I haven't used an option parser in years

1613070706
voldial
marler8997: "does exactly one thing" style then?

1613070724
ifreund
just poke at argv manually :D

1613070744
zags
var x = arena.allocator.create(MakeMyUniontype(T));  x.myfield = somevalue;

1613070745
zags
^ panic: access of inactive union field

1613070745
voldial
I make too many mistakes;/

1613070746
zags
So if I allocate my union, how do I activate a field?

1613070765
ifreund
actually I did end up writing a minimal/opinionated arg parser for river recently:

1613070785
ifreund
zags: x = .{ .myfield = somevalue };

1613070801
marler8997
I pretty much do the same thing to parse arguments in all language now, here's an example:

1613070816
zags
ifreund: isn't that an extra copy? Or does it place it into my allocate area?

1613070834
andrewrk
marler8997, same. I don't really see the value in an abstraction for this

1613070846
voldial
ifreund: thanks. readin'

1613070926
ifreund
zags: oh I didn't read well, you'd need x.* = .{ .myfield = somevalue }; since x is a pointer (you could make it const by the way)

1613070935
voldial
marler8997: cool

1613070981
marler8997
yeah, it seems like every time I see a cmdline parsing library, there's always corner cases to handle which eventually makes the library bloated/complex or using the library ugly

1613070986
ifreund
andrewrk, marler8997: My reason for an abstraction here was to avoid code duplication between (eventually many) sub commands

1613071009
zags
ifreund: question remains, do I allocate and then immediately copy here?

1613071018
zags
which would be wasteful

1613071031
ifreund
zags: there is no other way to initialize allocated memory

1613071032
andrewrk
ifreund, ah that makes sense

1613071069
marler8997
an application specific parser that's used in multiple places makes sense.  It's the general case that seems to be hard

1613071070
ifreund
and my arg abstraction is quite primitive tbh, but still nice to use

1613071071
zags
ifreund: yeah, stack allocated does it immediately, feels like heap allocated memory should have a way to do it as well, but I guess we'll rely on elision in the future

1613071071
voldial
marler8997: you prob know, but portage does something similar, we have slots, so parallel installed versions of stuff is easy

1613071081
andrewrk
I wouldn't worry about allocating memory for args, you do it once and it's not going to be noteworthy when compared with mem & cpu usage of the rest of your app

1613071106
ifreund
zags: you get uninitialized memory from the OS, there is no way to initialize it without copying something into it

1613071171
zags
sure, i mean if the literal is a temporary here, but I'm thinking in C++ terms haha

1613071181
ifreund
andrewrk: yeah, but allocation is annoying cause then there are errors to handle. my abstraction is allocation-free and, like river, does not support windows :)

1613071225
andrewrk
nice :)

1613071246
marler8997
voldial are you saying portage's cmdline parsing is similar to the example I sent you?

1613071274
ifreund
and it only trigger one stage1 comptime bug, for which I found a workaround :P

1613071293
ifreund
anyhow, I'm going to get back to zig fmt fun

1613071302
voldial
marler8997: no sorry, I was saying that portage has someting similar to zigup, in a ebuild (the install instructions portage parses) you can specify which version of something to use or depend on. it's very mature and nice.

1613071323
marler8997
oh cool

1613071367
andrewrk
ifreund, so you're doing comments? I'll work on some of those recovery cases then

1613071419
voldial
marler8997: here is the pull to convert the git-head zig ebuild to work with the latest code for example, the :9 to :11 is specifying the llvm "slot" to use.

1613071457
voldial
so I could have any zig versions installed in parallel

1613071491
ifreund
andrewrk: I have something that passes a bunch more test cases already, but is pretty wide-reaching so It might conflict

1613071492
marler8997
oh wow, this file looks alot like yocto recipe files

1613071523
voldial
the "default" one can be selected with the eselect tool:

1613071523
ifreund
I can push a commit now so you can take a look and maybe pull it in if you think the approach makes sense

1613071545
marler8997
how does the mechanism work to change versions?  symlink?

1613071560
voldial
marler8997: exactly.

1613071566
marler8997
good ol' symlink

1613071567
andrewrk
ifreund, alright, I'll start poking at astgen then :)

1613071621
ifreund
sounds good :) I'll keep working through the rest of the comment test cases

1613071631
voldial
marler8997: symlink layout for gcc:

1613071675
marler8997
nice, it's like dipping your toes in the NixOS water :)

1613071715
voldial
marler8997: heha. gentoo, but Nix is sweet... it's just missing the compile flags we love (called USE flags)

1613071731
marler8997
USE flags?

1613071765
g-w1
tells gentoo which features to compile in

1613071774
voldial
marler8997: yea, they let you decide ./configure opyions globally or per-package. so I can say (for example) disable X support on everything)

1613071775
g-w1
supposedly makes ur binary faster since it is customized to ur machine

1613071780
marler8997
well, nixos has that in it's configuration file

1613071814
marler8997
here's my nixos config:

1613071833
voldial
marler8997: gcc USE flags:

1613071835
voldial


1613071846
voldial
neet. thx.

1613071915
voldial
of curse, there is no ANSI color supporting bpaste :( but I assure ya, it looks nice here

1613072719
voldial
g-w1: I find them useful to disable features I dont want. for example, globally disable ipv6, or suport for a particular init system (gentoo supports multiple)

1613072736
voldial
ok. back to learning zig

1613073140
tane
does the compiler elide error checks if the error union is provably empty?

1613073878
ifreund
aahh found another lastToken() bug :D

1613073908
ifreund
I'm not a fan of how they cause spooky action elsewhere

1613073923
ifreund
tane: I'd assume llvm is smart enough to do that yeah

1613073949
tane
ok, nice

1613074119
ugla
tane:

1613074449
ugla
maybe this is better

1613074584
tane
hm

1613074588
tane
I have to experiment a bit

1613079707
ifreund
andrewrk: put up the pull request for line comments. I've realized there's an issue with my bright idea to get rid of renderExtraNewline() though as it's currently too permissive

1613079766
ifreund
I'm pretty sure we need to solve this differently than what renderExtraNewline() was doing as it wasn't aware of comments

1613079793
ifreund
so overall a good step in the right direction, but not yet all the way there

1613079881
ifreund
I also haven't taken a good look at multiline strings yet... I'm done writing code for the day though

1613080092
ifreund
(of course if you think the approach is totally wrong that's fine too, I undestand the problem a lot better now at the very least)

1613081313
andrewrk
thanks ifreund! I'll keep pushing on astgen stuff for now, there's a good chunk of work to be done here

1613081352
andrewrk
who would have thought that completely redoing memory layout for the first 2 stages of the compiler pipeline would involve so much code rewriting?

1613081386
tane
;)

1613081903
ifreund
andrewrk: also, I think we might need to add ContainerDeclSemicolon variants or use the *Comma ones for semicolons as well :/

1613081961
ifreund
I'm not entirely convinced this approach is cleaner than recursion in the end tbh

1613081976
andrewrk
oh recursion would certainly be cleaner

1613082016
andrewrk
the idea here is to avoid having to make lastToken have to heap allocate once

1613082119
ifreund
heh, forgot about that one

1613082152
ifreund
at least this stuff stays mostly isolated to zig fmt

1613082269
tdeo
my pr #7749 is passing ci, friendly request for a review on the stage2 part

1613082769
andrewrk
thanks tdeo

1613082973
andrewrk
ah I see, you had to implement callconv() because we actually do have inline support in stage2 already

1613083185
zags
hey, thoughts on this piece of zig fmt?

1613083227
tdeo
zig fmt will keep line breaks after the operator, but not before

1613083236
tdeo
so you can put the dot at the end of the line instead

1613083243
zags
i don't want to

1613083243
tdeo
looks pretty bad to me though

1613083245
tdeo
yeah

1613083254
zags
yeah, that's a no-go

1613083265
zags
i'd rather turn off formatting on that piece, but that has other problems

1613083293
zags
seems like if a line starts with a dot (WS aside) it should honor the indentation

1613083761
ifreund
zags: you should be able to force that with empty trailing line comments

1613083831
ifreund


1613083855
ifreund
not that I actually recommend doing that, just to demonstrate that you can :P

1613084100
andrewrk
why not just put the dots at the end?

1613084135
andrewrk
also I'm not a fan of this thing where you use a return value to structure your syntax differently

1613084168
andrewrk
I am skeptical those functions chain like that without forcing them to redundantly return one of the parameters as the return value

1613084200
g-w1
will zig fmt ever change the ast?

1613084244
zags
andrewrk: this is for a streams api (which I've heard you dislike, but I like them so I make them :) and putting the dot at the beginning is what everyone do. But I'll try to adapt.

1613084316
andrewrk
I don't see any error handling here

1613084323
zags
it's now able to filter, reduce, fmap, zip, skip

1613084328
zags
the error is propagated

1613084342
zags
the example is not from my api, that was just a formatting test

1613084411
zags


1613084416
zags
^ example doing try

1613084458
zags
presumably #1717 will clean up the latter one

1613084553
andrewrk
ah yes, some people are fond of programming like this

1613084574
zags
I don't use it as a style in general, but it's immensely powerful when you need it

1613084587
zags
Streams, that is

1613084684
andrewrk
fair enough :)

1613084696
zags
will add skip, limit, distinct, sort, flat-map, searching, stats, and collecting into arrays, then push it up so people can ignore it.

1613084715
zags
It's mainly to learn zig anyway (and it's awesome)

1613084716
andrewrk
I'm sure you'll find plenty of folks who enjoy that style of coding

1613084732
zags
I'm not advocating a style of programming though

1613084759
zags
It's for when you actually need to compose lots of operations on a dataset and use little memory while at it

1613084803
zags
Not sure how it's possible to be against it :) It's just a list of things that needs to be done, quite expressive and error propagation works, so :)

1613084966
zags
Here's the important part: Zig is a side language and it'll be days between I look at it. But the language is so small and things compose so well it's a no-brainer to pick it up again. That's not the experience I had with Nim, Rust or Swift this year. So huge kudos on the language.

1613086107
andrewrk
:)

1613086879
andrewrk
tdeo, looks like this does not make zig fmt auto fix code, right?

1613087932
tdeo
andrewrk: it does, that's the first commit

1613087970
andrewrk
ahh my mistake. nice work on this!

1613087991
andrewrk
I'm going to have to rework some of it for the ast-memory-layout branch but I think this is good to land in master branch in the meantime :)

