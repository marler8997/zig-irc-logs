1622987689
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
i see

1622987807
daurnimator!~daurnimat@vultr.daurnimator.com
g-w1: http://sprunge.us/jSFRln <-- can you try with this?

1622987852
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
sure

1622987988
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
https://clbin.com/6zO8N

1622988026
marler8997!~marler899@204.229.3.4
I needed the logic to convert a unix epoch timestamp into the year/month/time/etc. Zig seemed to be missing this logic in std, and I didn't want to use libc (i.e. gmtime function).  So I implemented the logic here.  Take a look and let me know if the API could be improved, I'll create a PR if people think this implementation works well: https://github.com/marler8997/zig-irc-logger/blob/master/epoch.zig

1622988089
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: its always trickier than you think

1622988111
marler8997!~marler899@204.229.3.4
what do you mean?

1622988164
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: you might find https://github.com/daurnimator/luatz/blob/master/luatz/timetable.lua helpful

1622988175
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: in particular see the sakamoto algorithem for day-of-month

1622988204
marler8997!~marler899@204.229.3.4
I don't have day of week

1622988222
daurnimator!~daurnimat@vultr.daurnimator.com
oh oops I confused day of week and day of month

1622988370
marler8997!~marler899@204.229.3.4
interesting though, the C implementation I looked at just did (4 + dayno) % 7

1622988404
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: so first I'll ask... why do you need to convert to year/month/time/etc? usually that should be done by the end-user in their local timezone

1622988424
marler8997!~marler899@204.229.3.4
to know which file to store irc messages

1622988445
marler8997!~marler899@204.229.3.4
see https://github.com/marler8997/zig-irc-logs

1622988463
marler8997!~marler899@204.229.3.4
logs are stored in year/month-day.txt

1622988472
daurnimator!~daurnimat@vultr.daurnimator.com
ah okay

1622988656
daurnimator!~daurnimat@vultr.daurnimator.com
g-w1: oh, change the @as to @intCast ?

1622988673
marler8997!~marler899@204.229.3.4
daurnimator, do you think this API is good for std?

1622988732
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: I know it gets very tricky with timezones, leap seconds, expectations about out-of-range values, etc. With zig I can imagine a lot of figuring out the right data types to use

1622988748
marler8997!~marler899@204.229.3.4
timezone is orthogonal to this

1622988782
marler8997!~marler899@204.229.3.4
all this does is convert an epoch timestamp into the year/month and the time of day

1622988869
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: but you still have things like `DaySeconds.secs` with a comment `max is 24*60*60 = 86400` => that is only really true for UTC

1622988901
daurnimator!~daurnimat@vultr.daurnimator.com
==> most of the helpers/data type choices you've made are only valid for UTC

1622988903
marler8997!~marler899@204.229.3.4
it's true for an epoch timestamp

1622988939
marler8997!~marler899@204.229.3.4
like I said, the only purpose of this is to extract information about an epoch timestamp

1622988946
daurnimator!~daurnimat@vultr.daurnimator.com
speaking of... why did you select `u64` for epoch timestamp?

1622988953
marler8997!~marler899@204.229.3.4
intead of what?

1622988979
daurnimator!~daurnimat@vultr.daurnimator.com
well e.g. linux uses `struct timespec` which has up to nanosecond granularity

1622989024
marler8997!~marler899@204.229.3.4
you could add EpochNanoseconds if that's something people want

1622989038
daurnimator!~daurnimat@vultr.daurnimator.com
why should that not be the default/norm?

1622989044
marler8997!~marler899@204.229.3.4
there is no default

1622989055
marler8997!~marler899@204.229.3.4
EpochSeconds vs EpochNanoseconds, use what you want to use

1622989113
marler8997!~marler899@204.229.3.4
maybe EpochSecs and EpochNsecs?

1622989214
daurnimator!~daurnimat@vultr.daurnimator.com
then an odd thing is that struct timespec doesn't store it as nanoseconds since 1970; but as seconds and nanosecond components... which gets you into a 'fun' piece of maths when you want to modify nanoseconds... and opens questions for *every* api that takes it about if it can keep out-of-range nanoseconds :/

1622989276
marler8997!~marler899@204.229.3.4
the nice thing is Zig can break away from that design

1622989291
marler8997!~marler899@204.229.3.4
I've used a "composable" interface here

1622989301
marler8997!~marler899@204.229.3.4
all the logic has access only to the info it needs

1622989413
marler8997!~marler899@204.229.3.4
should I use something besides u64 for EpochSeconds?

1622989468
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
daurnimator: that patch works!

1622989549
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: I'm not sure. but it is definitely *a* choice. I think we can agree i32 would be wrong in 2021.... but you might find people arguing for anything from u32 to u48 to u64 or even u128

1622989580
marler8997!~marler899@204.229.3.4
gotcha, well I'm not particular

1622989592
daurnimator!~daurnimat@vultr.daurnimator.com
of course then you get people who have a different epoch :P (e.g. windows :/ )

1622989620
marler8997!~marler899@204.229.3.4
not sure what that means?

1622989638
marler8997!~marler899@204.229.3.4
windows has some sort of timestamp based on another start time?

1622989644
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: windows apis count from jan 1 1601; not jan 1 1970

1622989690
daurnimator!~daurnimat@vultr.daurnimator.com
https://en.wikipedia.org/wiki/Epoch_(computing)#Notable_epoch_dates_in_computing

1622989701
daurnimator!~daurnimat@vultr.daurnimator.com
apparently wikipedia has a list :P

1622989708
marler8997!~marler899@204.229.3.4
interesting, I wonder if it works the same way as the unix epoch timestamp, just with a different start time

1622989754
daurnimator!~daurnimat@vultr.daurnimator.com
marler8997: mostly; though pre even WW2 even the concept of dates get... funny

1622990753
daurnimator!~daurnimat@vultr.daurnimator.com
g-w1: great; we should probably add something like that to the std lib. need to do research to find out IOV_MAX for each os...

1622990811
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
cool

1622990841
daurnimator!~daurnimat@vultr.daurnimator.com
I'll put up a draft PR now I guess.... but I don't have the time to do that research now

1622990852
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
ok

1622990985
daurnimator!~daurnimat@vultr.daurnimator.com
g-w1: https://github.com/ziglang/zig/pull/9015

1622991007
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
thanks!

1622992049
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
hmm, seems like the elf linker does not handle bss yet

1622992632
oats!~thomas@user/oats
at one point I came across a neat blog post describing how to do dynamic dispatch with a neat @fieldParentPtr() trick, but I can't find it anymore

1622992647
oats!~thomas@user/oats
anybody know what I'm talking about?

1622992689
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
i do know what you are talking about, you can just check the compiler as it uses it a lot

1622992734
g-w1!~g-w1@pool-96-232-174-225.nycmny.fios.verizon.net
heres an example https://github.com/ziglang/zig/blob/master/src/AstGen.zig#L7989-L8070

1622992738
oats!~thomas@user/oats
oh sweet

1622993961
oats!~thomas@user/oats
ah, found it https://www.nmichaels.org/zig/interfaces.html

1622993987
oats!~thomas@user/oats
I'm actually not 100% sure this is dynamic dispatch

1622993987
oats!~thomas@user/oats
ACTION does some reading

1622994262
oats!~thomas@user/oats
oh yeah, this is dynamic dispatch

1622994265
oats!~thomas@user/oats
runtime polymorphism

1623007373
kiedtl!~kiedtl@kisslinux/kiedtl
Is it possible to get the underlying type of a slice?

1623007391
luuk!~luuk@user/luuk
std.meta.Child

1623007392
kiedtl!~kiedtl@kisslinux/kiedtl
i.e. something like `@SliceType([]const T) => T`

1623007412
luuk!~luuk@user/luuk
Or look at what std.meta.Child does :)

1623007490
kiedtl!~kiedtl@kisslinux/kiedtl
...huh, I see.

1623007535
ifreund!~ifreund@user/ifreund
std.meta.Elem() would be more appropriate here probably

1623007545
luuk!~luuk@user/luuk
Yeah I agree

1623007554
luuk!~luuk@user/luuk
(Only just found it now haha)

1623007598
kiedtl!~kiedtl@kisslinux/kiedtl
but why do std functions like mem.copy defined as 'fn (comptime T: type, dest: []T, src: []const T) void' when it could be 'fn (dest: []anytype, source: []const @TypeOf(dest))' ?

1623007607
kiedtl!~kiedtl@kisslinux/kiedtl
s/why do/why are/

1623007618
ifreund!~ifreund@user/ifreund
because []anytype is invalid

1623007653
kiedtl!~kiedtl@kisslinux/kiedtl
oh damnit

1623007670
marler8997!~marler899@204.229.3.4
keidtl, that's a good question, I have an open issue asking about that

1623007720
marler8997!~marler899@204.229.3.4
https://github.com/ziglang/zig/issues/2904

1623008014
ifreund!~ifreund@user/ifreund
for reference, the signature you'd want here would be `fn (dest: anytype, source: []const std.meta.Elem(dest)) void`

1623008837
kiedtl!~kiedtl@kisslinux/kiedtl
oh damn, I see.

1623008862
kiedtl!~kiedtl@kisslinux/kiedtl
I misunderstood your statememnt to mean that you couldn't have an 'anytype' that was a slice type

1623015603
kiedtl!~kiedtl@kisslinux/kiedtl
is there a data structure in the stdlib which is essentially ArrayList but with a fixed-width buffer underneath?

1623015721
ugla!~ugla@2001:470:69fc:105::2b5
you could use a FixedBufferAllocator with ArrayList

1623015760
kiedtl!~kiedtl@kisslinux/kiedtl
Yes, but I'd like to store this data structure in a struct without storing an allocator with it

1623015779
kiedtl!~kiedtl@kisslinux/kiedtl
Well, guess I'll just create a wrapper or something

1623015860
ifreund!~ifreund@user/ifreund
I'd probably just write your own real quick, a wrapper using ArrayList will have overhead

1623015912
ifreund!~ifreund@user/ifreund
might be irrelevant though

1623015937
kiedtl!~kiedtl@kisslinux/kiedtl
Yeah, but speed isn't really a consideration here at all

1623015947
kiedtl!~kiedtl@kisslinux/kiedtl
s/here/in my case/

1623015950
kiedtl!~kiedtl@kisslinux/kiedtl
=)

1623015998
mla!~mla@162.253.176.229
is there a unique-set like datatype in std lib?

1623016039
ifreund!~ifreund@user/ifreund
you mean a hash map?

1623016051
ifreund!~ifreund@user/ifreund
you might be looking for std.HashMap(Foo, void)

1623016084
mla!~mla@162.253.176.229
is that bad practice, i had that idea

1623016095
ifreund!~ifreund@user/ifreund
no, not at all

1623016119
mla!~mla@162.253.176.229
intresting, cool will use void value then

