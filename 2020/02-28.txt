1582875555
andrewrk
this is a happy commit:

1582875573
andrewrk
I didn't even remember this until later in the branch. look how perfectly having OS version ranges solves this

1582881660
Snektron
<alexnask "like: int widths[] = { [0 ... 9]"> Hey neat, imma start using that

1582881923
alexnask
GCC has a bunch of stuff, computed gotos are also pretty neat

1582882045
alexnask
You can also use enums with that btw ;)

1582900300
betawaffle
switching between Zig and Go has shown me how much better integer casting is in Zig

1582900444
fengb
Really? I don't think I encountered that

1582900494
fengb
I can't imagine how I could write this kind of code in Go though:

1582900565
betawaffle
idk, maybe i'm wrong an they are both a bit unpleasant, but Zig has more safety options

1582900580
betawaffle
take this go: uint64(uint32(int32(x)))

1582900646
betawaffle
that's how you 1. sign extend x to 32 bits, 2. zero extend that to 64 bits

1582900728
betawaffle
but you have to really understand the semantics of those cast

1582900740
betawaffle
with zig, it's more obvious what someone's doing

1582900800
fengb
Isn't that the same as `@as(u64, @as(u32, @as(i32, x)))`?

1582900829
fengb
Or does `uint32(int32)` actually translate to `@bitCast(u32, i32)`

1582900838
betawaffle
yeah, but what if x is bigger than an int32? in zig that would compile-error

1582900855
fengb
Oh, does Go just give up?

1582900856
betawaffle
yeah, it's a bit cast

1582900867
fengb
Damn... okay I think Zig wins here :P

1582900886
betawaffle
casting between signed/unsigned of the same type is a bit cast

1582900910
betawaffle
casting to a bigger size will sign or zero extend, depending on the type

1582900915
betawaffle
and casting down...

1582900925
betawaffle
is just truncation

1582900935
betawaffle
though i can't remember about signed truncation

1582900970
fengb
Hmm... is Zig an exception when it comes to explicitly splitting up those casts?

1582900976
fengb
(How does Rust do it)

1582900989
betawaffle
rust is completely explicit about all of that, i think

1582901025
fengb
`Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will truncate`

1582901054
fengb
Rust's `as` keyword semantics are just as overloaded :(

1582901093
betawaffle
hmm, the go spec doesn't even have the word "cast" in it

1582901093
fengb
Maybe this is an advantage towards not having a keyword, since it's ambiguous what should be done

1582901129
betawaffle
ah, they call it conversions

1582901155
fengb
Of course they do ;)

1582901155
betawaffle
"Conversions between numeric types"

1582901180
betawaffle
1. "When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size."

1582901212
fengb
"The transmute function is very simple, but very scary. It tells Rust to treat a value of one type as though it were another type. It does this regardless of the typechecking system, and completely trusts you."

1582901232
fengb
Sometimes I wish Rust would respect me :(. Bitcasting is a pretty common low level concept

1582901236
betawaffle
that's the same as zig's @bitCast

1582901245
fengb
Yeah but it's very! scary!

1582901265
betawaffle
right, because in rust representations can be undefined

1582901334
betawaffle
i'm such a huge fan of zig's arbitrary integer sizes

1582901351
fengb
LLVM is capped at 128 though :(

1582901367
betawaffle
what does zig do with larger ones?

1582901368
BaroqueLarouche
mq32: isn't that the Quake3 Inverse SqRoot constant ?

1582901384
fengb
betawaffle: right now it crashes with a compiler error

1582901390
fengb
Not very graceful

1582901408
betawaffle
well, i tend not to need things larger than 128, but stuff like u29, u7, etc are really useful

1582901417
fengb
It's considered a bug so it'll be fixed soonâ„¢

1582901435
mq32
BaroqueLarouche, indeed it is

1582901440
fengb
Ah yeah, I just had to use a bunch of i7s because it was per spec

1582901470
betawaffle
right, weirdly sized signed integers are a

1582901472
mq32
var privkey: u4096 = undefined;

1582901487
fengb
I have this fugly bitcast:

1582901526
fengb
I'm really unhappy to use the bits of f64 :(

1582901530
fengb
But hey it works

1582901534
metaleap
fengb: "LLVM is capped at 128 though" --- llvm langref: "The integer type is a very simple type that simply specifies an arbitrary bit width for the integer type desired. Any bit width from 1 bit to 223-1 (about 8 million) can be specified."

1582901538
metaleap
which one is it =)

1582901591
betawaffle
one thing that's still sort of annoying in zig is i'd like to be able to shift a an integer's bits between sizes too, like a special right and left shift that shifts bits but also shrinks/grows the size

1582901593
metaleap
or you meant float?

1582901617
betawaffle
like u7 << 1 becomes a u8

1582901628
fengb


1582901631
betawaffle
(but obviously it'd need to be a different operator

1582901662
mq32
betawaffle: why should it be another operator?

1582901663
fengb
betawaffle: sounds like a candidate for std.math function

1582901681
mq32
i think it's quite reasonable that a shift-left of 3 bit will increase the type size by 3

1582901684
betawaffle
mq32: because how'd you do regular shifting?

1582901692
mq32
if you want to discard the bits, use @truncate

1582901699
mq32
that will make your intent much clearer

1582901716
betawaffle
ah, interesting. well the other problem is that the shift may not be comptime-known, right?

1582901718
fengb
That doesn't make sense at the language level. Builtins should map to assembly

1582901722
betawaffle
(only comptime bound)

1582901747
fengb
(Or some notion of an existing assembly instruction)

1582901761
mq32
betawaffle, you may not use any type for shifting that would shift more than te number of bits

1582901775
mq32
so (a<<b) will require b to be u3 when a is u8

1582901793
betawaffle
right, but what i'm saying is your shift could be a runtime-known

1582901806
betawaffle
and you wouldn't know what type comes out the other side?

1582901819
mq32
the maximum possible type

1582901822
betawaffle
or would it always be the largest size possible, ohhh

1582901825
betawaffle
right ok

1582901831
betawaffle
that could definitely work

1582901839
betawaffle
i'd like to see that implemented

1582901851
grayhatter
is zig trying to abstract away some of the semantics of how the hardware actually does it's work?

1582901852
fengb
add a std.math function

1582901856
fengb
Shouldn't be too hard

1582901887
fengb
grayhatter: not really. We try to be more explicit about things though

1582901915
fengb
If it's ambiguous across machines, the language tends to be conservative and crash on undefined behaviors, and we have ways to force one strategy

1582901918
betawaffle
do we already have std.math functions for bit-range extraction?

1582901924
grayhatter
I'm thinking that if << will alter the type of the result, that's abstracting away the physical types the cpu will use

1582901954
betawaffle
grayhatter: it's be like sign/zero-extending first, then shifting

1582901954
grayhatter
s/cpu/arch

1582901982
fengb
grayhatter: I agree it doesn't make sense. That's why I'm advocating against hijacking the operator. We do that sort of thing in stdlib though

1582901999
grayhatter
I understand that, but in C, if you bitshift past your size, it doesn't grow the size for you, it'll just truncate

1582902020
betawaffle
right, but zig never lets you do that anyway

1582902022
fengb
That's well defined in Zig to be illegal. The type system won't let you do that

1582902027
betawaffle
(without a separate operator)

1582902058
grayhatter
I agree that something like that should be explict, over implicit. But I don't think I'd want my language to change the size of memory block I'm using

1582902068
fengb
+1

1582902125
fengb
I've been doing this and getting realignment is painful: `stack: []align(4) u8`

1582902139
fengb
Should I switch to u32 even though the bookkeeping is slightly less intuitive?

1582902173
fengb
(It feels weird to stick arbitrary data into []u32)

1582902194
grayhatter
I'm also of the opinion that stdmath should be allowed to change memory size for things it owns. numpy is an example of getting it right. They allow you to controll the memory, but if you choose not it, they'll do it for you (and correctly)

1582902270
grayhatter
well, perhaps math, not stdmath... but I'm only half paying attention to zigs libs

1582903681
fengb


1582903853
mikdusan
fengb: I already forgot the answer to that

1582904050
fengb
Just claim 1GB in savings

1582904085
alexnask
I added a single deinit in a PR and saved 2 GB /s

1582904107
mikdusan
exponent!

1582908812
andrewrk
mikdusan, do you know about macosx version numbers?

1582908836
andrewrk
I tried `uname -r` on my 10.14.6 laptop and it reports "18.7.0"

1582908868
andrewrk
what is this mysterious 18.7 number, and do you know what the most reliable way to get the native macos version is?

1582909068
fengb
Catalina 10.15.2 reports "19.2.0"

1582909096
fengb
Apparently it's the Darwin version

1582909098
BaroqueLarouche
maybe it's the Darwin version ?

1582909111
Snektron
I would guess that its the olde year.month.patch scheme but thats not correct

1582909119
fengb


1582909253
fengb
`sw_vers -productVersion` reports the macos version

1582909258
fengb
Not sure which one should be used >_>

1582909268
andrewrk
ok yes it's the darwin version. I think we want to use the macos version though. anyone know how to do `sw_vers -productVersion` programatically? e.g. what is sw_vers doing

1582909303
andrewrk
supposedly this is open source but apple does not make things easy to find

1582909322
fengb


1582909359
andrewrk
brilliant

1582909798
andrewrk
woo, in the os-version-range branch, zig correctly detects the native C ABI as "musl" on alpine linux

1582909822
BaroqueLarouche
nice!

1582909847
andrewrk
I'm rather pleased with how that works

1582910095
mikdusan
andrewrk: `uname -r` has little to do with `sw_vers`. `uname -r` iirc is the kernel version. so think of it as linux returning "5.4.15" . then apple versions their brand macOS and it is reported via `sw_vers`, or the expensive `system_profiler`

1582910162
mikdusan
apple's `10.15.3 (Catalina)` would be analogous to ubuntu 19.04

1582910230
andrewrk
that makes sense. but I think that zig's os version range should be macos versions not darwin versions. whereas on linux I think it makes sense to be linux kernel versions, not distro versions

1582910274
andrewrk
having looked at the implementation of sw_vers, I think native macos version detection will attempt to execute sw_vers rather than requiring to link against CoreFoundation :-/

1582910445
andrewrk
that can potentially be solved later, but that's a whole new set of problems to tackle

1582910466
mikdusan
the cheapest way would be to read /System/Library/CoreServices/SystemVersion.plist or somesuch and fallback to sw_vers

1582910475
mikdusan
yup optimize later

1582910511
andrewrk
oh, there's an xml file with the answer right there?

1582910521
mikdusan
plist is xml'ish. but yeah

1582910590
andrewrk
damn we don't have an xml tokenizer yet. that's all that is needed here

1582910730
andrewrk
hmm I think this might be a nice set of contributor friendly issues

1582910741
andrewrk
I think people would enjoy doing native OS version detection

1582910768
BaroqueLarouche
or doing a XML library

1582910780
andrewrk
yes, just a tokenizer

1582910806
andrewrk
you can get really far and avoid a lot of issues by only tokenizing xml

1582910925
metaleap
and in fact, for 80% of "mere lookup needs", 1 or 3 careful stringIndexOfs will get you the answer if its known to occur 0x or 1x in the file =)

1582910962
metaleap
(not pretty, but neither is 3rd parties sticking to xml)

1582911005
Cadey
andrewrk: does Zig support the x32 ABI on Linux?

1582911012
Cadey
or in general

1582911021
Cadey
that uses 32 bit function pointers

1582911037
andrewrk
yes, have a look at `zig targets | jq .abi`

1582911074
Cadey
:+1:

1582911141
mikdusan
there is also a decent curation of darwin -> macOS history:

1582911143
mikdusan


1582911533
andrewrk
Cadey, I'm happy to help if you run into issues. That ABI is not well tested/explored in the zig community

1582911543
andrewrk
but it should work correctly in theory :)

1582912364
fengb
I thought x32 was sorta deprecated

1582912562
andrewrk
Cadey's use cases tend to be exploratory

1582912577
Cadey
fengb: i'm not a normal person, besides this is needed to get Zig binaries to run on TempleOS

1582912621
BaroqueLarouche
The road to god is a hardship

1582912936
alexnask
lol

1582913268
Cadey
in the immortal words of Q from Star Trek: "Making sense? Oh, dear Twilight, what fun is there in making sense?"

1582913307
TheLemonMan
there's literally zero support for x32-linux in the stdlib

1582913375
Cadey
i'm aware, but where we're going we don't need the stdlib

1582913424
TheLemonMan
what about HolyStdlib ?

1582913491
Cadey
in TempleOS there isn't a difference between the standard library and the kernel implementation

1582913508
andrewrk
god and man are one

1582913584
Cadey
i think i found a bug in how it handles core locking

1582913593
Cadey
seth sometimes steals quantums

1582913942
TheLemonMan
good to know SMP is approved by the almighty

1582916501
fengb


1582916669
fengb
How does Zig compare with these examples?

1582917023
TheLemonMan
well it has no packages so you cannot have any problem with huge dependency graphs

1582917090
TheLemonMan
the file abstraction does the same fake-mode thing on Windows though

1582917185
fengb
I suppose we also don't have unicode so we won't have the string problem :P

1582917229
TheLemonMan
yeah, you're free to bring your own encoding when/if you need it

1582917319
mq32
The file abstraction is a lot different imho

1582917334
mq32
Dir.openFile("path", .{ .read=true, .write=false });

1582917339
mq32
no flags involved here

1582917347
mq32
at least no bit flags

1582917381
TheLemonMan
check out fs/file.zig

1582917391
TheLemonMan
the whole Mode/mode() thing

1582917499
mq32
mode will return u0 on windows

1582917610
TheLemonMan
is that really better than faking it?

1582917641
mq32
it's more honest

1582917653
mq32
it's like "yeah the function exists, but it can return no bits"

1582917658
mq32
i would prefer not having the function on windows

1582917682
companion_cube
fengb: thanks for the Go ðŸ¿

1582917745
TheLemonMan
lol, you have to drop down to the raw Win32 (or even worse the NtDLL) APIs to fetch the attributes by hand then

1582917751
TheLemonMan
in a separate code path

1582917778
mq32
TheLemonMan: why? we can replace "mode()" with some more generic FileAttributes type

1582917806
TheLemonMan
sure thing, but you are defending the status quo

1582917820
mq32
i just said it's better than what go does

1582917826
TheLemonMan
and I pointed out that a u0 mode is not honest

1582917857
andrewrk
yeah basically we don't have file permissions on windows implemented yet

1582918050
mq32
but such articles are always nice to read before going 1.0

1582918274
dimenus
is it possible in zig to bring fields of a substruct into the namespace of the parent?

1582918283
dimenus
eg, Odin's using statement

1582918283
dimenus


1582918312
metaleap
why does this dude bother with windows anyway, is he a game dev? it's quite irrelevant for "infrastructure software" (as he calls it) in 2020

1582918340
metaleap
dimenus: not fields only decls AFAIK

1582918345
TheLemonMan
dimenus, no fields, only declarations

1582918349
mq32
metaleap: i don't think so. windows is still really widespread in infrastructure ;)

1582918364
mq32
maybe not in "network" or "it" infrastructure

1582918373
mq32
but rest of IT uses it

1582918394
andrewrk
dimenus, no:

1582918406
mq32
how many hospitals run desktop linux to manage their stuff?

1582918508
BaroqueLarouche
Windows is still ~90% in the market share

1582918610
TheLemonMan
BaroqueLarouche, yo, how's the zig-on-gba project going?

1582918680
BaroqueLarouche
TheLemonMan:  Took a bit on a break to focus on zigimg, last time I was working on required lib stuff to make objaffine demo. Like adding Fixed Point math and sin/cos table

1582918750
BaroqueLarouche
I should push this branch public, will do that either tonight or tomorrow

1582918847
BaroqueLarouche
on zigimg, I did a huge refactoring to have a proper generic Image class that can read different image format and adding PCX support by adapting mq32's code

1582919605
jessermeyer
Does cImport() internally leverage translate-c?

1582919668
TheLemonMan
yes

1582919697
jessermeyer
Thanks.

1582919743
jessermeyer
I apologize for asking this again.  I've forgotten.  Does translate-c parse the c code as is, or does it let clang pre-process the source file first?

1582919767
jessermeyer
(so it sees both macros + macro expansions)

1582919770
BaroqueLarouche
jessermeyer:  How do you call COM api in your code, like  D3D RenderTargetView and such? Just curious how you did on your side

1582919792
TheLemonMan
the latter, the C code as-is is pretty much useless

1582919851
jessermeyer
I call the v-table macros directly.

1582919857
jessermeyer
When using COM

1582919869
jessermeyer
But today I've been exploring Vulkan instead of DX12 since the COM is driving me nuts.

1582919884
BaroqueLarouche
Have a look at this:

1582919908
jessermeyer
Yeah I saw your GitHub posts on this.

1582919913
BaroqueLarouche
it will be even better once

1582919990
jessermeyer
I was having enough problems getting the v-tables populated correctly originally that I never explored being clever about it.

1582920014
jessermeyer
So most of my COM calls are quite direct.

1582921455
metaleap
lsp slow-mo-progress update: took a break from ast-traversals for a nicely working little build-on-save with live diagnostics-sync:

1582921543
metaleap
now with fmt-on-save and build-on-save and symbols-listing i got a decent productivity base to tackle the actual meaty needs. jump-to-def / peek-definition really has to happen next & soon. dammit

1582921659
jessermeyer
nice!

1582921664
metaleap
best part is the as-you-type parse-error wigglies. to not annoy, they're marked as infos (blue) instead of "danger"-red

1582921796
mq32
metaleap: how can i install your zig-lsp?

1582921814
metaleap
right now? with a lot of pain  :D

1582921822
betawaffle
ugh...

1582921824
mq32
haha :D

1582921847
andrewrk
metaleap, are you doing anything with the semantic analysis dump?

1582921853
betawaffle
i'm debating whether to just ignore the fact that in NBT, bytes are supposed to be "signed"

1582921906
betawaffle
it's seems super meaningless to specify signed-ness as part of the encoding

1582921933
metaleap
mq32: i'll move things to a single repo for ease of pulling/updating but for now its spread across 4 libs in 4 separate repos and the @import()-paths assume that those exist side-by-side each other

1582921936
betawaffle
and the way go does slices and signedness is just awful

1582922040
mq32
metaleap: what about submodules?

1582922084
metaleap
mq32: yeah the single-repo would actually be mirroring these 4 as git submodules, when i get to that (when i have sth real to offer not just the early gimmicks)

1582922098
metaleap
andrewrk: not yet, it's planned for after once I got as far on ast alone (and perhaps some of the more trivial expr-eval opportunities) as it'll take me.

1582922217
metaleap
i also assume --- could I be wrong? --- that the semantic-analysis-dumps will be based on the compilers lazy eval, hiding things that the sources themselves reveal and the LSP UX also should

1582922315
andrewrk
that's correct

1582922503
mq32
andrewrk: how much work would it be to implement an AST dump of the parser output?

1582922505
metaleap
so i'll get the ground truths straight from sources as far as that approach can go, before deferring for extra intel goodies to ad-hoc json dumps (seem to land ~3MB depending how much of std is in there) --- right now i can load ASTs for ~400 source files into RAM in 3-4 seconds startup time, then only very rarely on-edit refresh one or the other in a tiny handful of millis. and thats only debug-build. too delicious to not exploit to the max, first

1582922554
andrewrk
mq32, why would you need that? use std.zig.parse

1582922688
andrewrk
metaleap, you should be able to implement jump-to-definition without semantic analysis. but it will take detours through any aliases (e.g. pub const foo = bar; )

1582922722
andrewrk
true jump-to-definition will require semantic analysis, and the answer could be different depending on build mode or other build-time options

1582922729
metaleap
andrewrk yeah i'm gonna have to impl

1582922741
andrewrk
const MyType = if (isPrime(x)) Foo else Bar;

1582922742
metaleap
ie i certainly want to be able to resolve @import("my"++"file.zig")

1582922760
mq32
andrewrk: i want to test out how good a pure text-based docgen would be

1582922773
mq32
so: just using the text without semantic analysis

1582922777
andrewrk
metaleap, maybe don't do that yet:

1582922808
metaleap
for the branchings i'd just show all possibilities. if it grows unwieldy in the listings , even better for the programmer to keep the possibilities space in full view at all times

1582922812
andrewrk
part of the reason for this proposal is the use case of IDEs/tools

1582922829
andrewrk
that's a good approach, and the approach planned for the generated docs as well

1582922850
andrewrk
metaleap, maybe as a warm-up exercise you could help complete the implementation of

1582922908
andrewrk
idea is to take multiple semantic analysis dumps and merge them into one, turning scalars into arrays where applicable. as a result the generated docs js file will need to be improved to handle the extra information, but it will also allow more complete and correct docs that apply to all builds

1582922955
metaleap
there's an idea! so the missing parts are those indicated by TODO or are there others as well?

1582923036
andrewrk
idk I'd have to read the code myself to remember. I think it merges AST first, and primitive types. and then TODO is the rest

1582923074
andrewrk
once primitive types are merged, you can merge structs; for example if a struct has a field that is composed only of the same primitive types in the same order, then you can easily merge that

1582923088
andrewrk
repeat until there is nothing left to merge

1582923124
andrewrk
I think contributing to this and to generated docs would be a really good way to become knowledegable of exactly the right things you need to know for the LSP project

1582923160
andrewrk
it would also put you in a good position to suggest changes to how the semantic analysis dump is structured

1582923278
metaleap
ok i shall take a more in-depth look into this whole machinery this weekend!

1582923922
TheLemonMan
andrewrk, can you s/unionation/pointer/ here

1582923960
betawaffle
andrewrk: stream today?

1582923981
andrewrk
TheLemonMan, done

1582923985
andrewrk
betawaffle, yep in 50 min

1582925576
andrewrk
big news:

1582925648
BaroqueLarouche
anybody know why Apple doesn't use LLD ?

1582927389
betawaffle
phew, thought i might have missed the start of the stream

1582927440
andrewrk
gimme another hour to finish up what I'm working on

1582927464
betawaffle
ok

1582927558
betawaffle
i'm really disappointed how the #go-nuts reacted to my complaint about casting

1582927685
metaleap
betawaffle did they go nuts .. did they show no guts?

1582927698
betawaffle
heh

1582927744
betawaffle
no, they though it was silly that i'd want to be able to cast from a slice of (the equivalent of) []i8 -> []u8

1582927767
betawaffle
"really, pray tell, what will the negative values be in the unsigned type?"

1582927872
betawaffle
or rather... they thought i should just loop over my slice instead. and that's what any other language would do under the hood, but go doesn't "hide" that from you

1582927894
betawaffle
are you f*ing kidding me?

1582928536
fengb
There's a lot of stockholm syndrome in Go :(

1582928564
metaleap
well you can "dirty"-cast from one slice type to another same-sized slice type in C or zig, but i think with "unsafe" pkg you could do the same in go IIRC

1582928565
fengb
There was massive backlash on trying to introduce Rust or Zig style try macros

1582928581
betawaffle
metaleap: correct, you can do it with unsafe in go

1582928597
betawaffle
*(*[]uint8)(unsafe.Pointer(&val))

1582928622
betawaffle
but that's... even more frowned upon

1582928635
metaleap
exactly. just the ticket. with a little "lecturing" in the pkg name :D

1582928660
andrewrk
4550 is ready to be merged if it passes tests

1582928666
fengb
That's how C woudl do it. Totally fine

1582928702
betawaffle
but the problem is... they don't make you do that for int8 -> uint8

1582928702
andrewrk
that was super weird when they rejected the `try` proposal

1582928711
shakesoda
how dare you have the audacity to know what you expect out of numbers on a computer!

1582928720
andrewrk
I was thinking, "interesting, they're closing the gap between go and zig. this is going to be good for them"

1582928723
betawaffle
andrewrk: tbh, i didn't like the try proposal

1582928732
andrewrk
wasn't it pretty much exactly zig's try?

1582928738
betawaffle
i like try in zig, but it's different in go

1582928755
betawaffle
no, it had quirks, because go has quirks

1582928800
fengb
Meanwhile, I do shit like `const result = Op.Fixval{ .i32 = @ptrCast(*align(4) i32, raw_result_ptr).* };`

1582928806
betawaffle
oh yeah, no more struct { ... }.my_func

1582928822
betawaffle
fengb: that's nice and clear, tbh

1582928848
fengb
It's just really raw... trying to optimally reuse the memory is really playing hell with my sanity

1582928863
fengb
Maybe I should go back to bitcasting everything to be the same size. That was a lot easier

1582928877
betawaffle
oh i see what you're saying

1582928886
andrewrk
fengb, I think

1582928907
fengb
Yeah I think I'm gonna revert this crap

1582928917
fengb
And pull it into phase 2 or something

1582928929
fengb
I had a good idea but it's just way too complicated

1582928955
betawaffle
i really wanted something like ^ that in Go

1582928962
fengb
Just gonna live with up to 12 bytes of bloat per variable :(

1582928970
betawaffle
being able to cast from a slice to an array pointer...

1582928997
betawaffle
fengb: unions?

1582929032
fengb
Yeah that was my first approach. Putting a u32 inside a u128 is a little heavy but it's so much cleaner

1582929048
fengb
This was me trying to compress the memory to the correct size... but it's a lot worse than I had imagined

1582929100
betawaffle
i wish there was a language that could deal with arbitrary bits as nicely as erlang, that wasn't erlang

1582929178
fengb
betawaffle: I think part of the problem of Go is that they're trying to pretend to be low level

1582929188
betawaffle
right

1582929206
shakesoda
seeing that u65535 is possible in the docs had me stuck on that thought all that night

1582929212
betawaffle
they're not app-level enough, and not low-level enough

1582929220
shakesoda
just shove and entire c64 rom in that one variable

1582929223
shakesoda
* an

1582929240
betawaffle
shakesoda: too bad it's a compile error atm

1582929259
shakesoda
well, the docs say it's valid at least :)

1582929272
fengb
Yeah it's an implementation bug (e.g. LLVM)

1582929367
shakesoda
fengb: re app vs low level, I really hate how some languages have made many just plain afraid of thinking about memory and bits

1582929378
shakesoda
you're on a computer! it's a fact of life! and we know how the numbers work, too.

1582929463
fengb
Eh... it's nice to stop worrying about bits at a low level. I don't anyone in Lisp would want to worry about translating lists into actual bits

1582929476
shakesoda
no amount of clever vm/compiler will save a program that doesn't make any attempt to acknowledge the fact that it does, in fact, need to run on a real machine.

1582929493
fengb
Have... you met functional programmers? ðŸ™ƒ

1582929519
shakesoda
worse, I've met... oop programmers

1582929552
betawaffle
shakesoda: this is where you'd want to run, isn't it?

1582929561
fengb
Eh, oop gets a bad rap because people use "objects" in languages and pretend like that's the only design needed

1582929617
shakesoda
the conventional java interpretation of oop is one of the most harmful things to have ever happened to software development

1582929627
fengb
Yeah I don't doubt that ;)

1582929651
BaroqueLarouche
who needs unsigned int anyway ? - Sun programmers in the 90's

1582929667
fengb
But also... strategy pattern is useful. And languages that don't let me implement that are really annoying

1582929668
shakesoda
I don't think every idea that gets thrown around is terrible, but oh goodness, the monsters people have learned to create in their name.

1582929697
shakesoda
betawaffle: yes, turns out

1582929717
fengb
Anyway... Java programmers don't generally think about memory spaces. Maybe that's a bad thing, but most of the Java work I've done has very little to do with memory layout

1582929731
fengb
So shoving bits into the same place doesn't make as much sense as inheritance polymorphism

1582929740
betawaffle
so that's why java is such a memory hog

1582929767
fengb
We could get away with doing union polymorphism... but that doesn't buy a whole lot and it'd look foreign in Java

1582929790
fengb
Nah, Java is a memory hog because it loads all the classes into memory for funsies

1582929807
fengb
Can you imagine a language where you only load the classes that you use?

1582929824
shakesoda
turns out, i can

1582929830
betawaffle
i can imagine one where you don't load classes at all :P

1582929849
shakesoda
I have a very fundamental belief that one should always have the machine on the mind when writing programs, at least a bit

1582929853
fengb
Yeah it's every other language. But Sun decided otherwise

1582929867
fengb
Why am I defending Java? lol

1582929869
shakesoda
certainly not wrangling it in every single possible moment, but it should always be on the mind

1582929901
shakesoda
down this line of thought is a lot of that I like to complain about with modern software

1582929922
fengb
You're not wrong

1582929936
betawaffle
this one hit me in the feels today:

1582929939
metaleap
the whole java hype 2 decades ago was something else. it was the hottest thing evarr. applets! smart fridges! tomcat servlets! oh boy, the kool-aid that was guzzled.....

1582929941
betawaffle
it's really true

1582929949
fengb
OTOH, we can only do so much. Enterprise software sucks, but business priorities come first

1582929950
betawaffle
especially the part about dependencies

1582929981
fengb
And yes, we've gotten lazy but we can't all be doing C++ every day and ship features as fast as business wants them

1582930019
fengb
Hell, I do Javascript most of my day. I think most of it is crap, especially Electron

1582930060
fengb
But... solving UI is hard in general. And as crappy as React is, it's less crappy than a lot of other stuff that came before it

1582930108
fengb
(Honestly though, I actually like React. It's gotten out of my way more than every other UI framework I've used)

1582930144
BaroqueLarouche
fengb: any experience with any desktop UI tookit ? (Qt, WinForm, MFC, GTK, etc.)

1582930170
shakesoda
javascript has so much insanity in every corner it is unbelievable lol

1582930182
fengb
It does... but it's also not a real problem

1582930190
shakesoda
no, it's just an annoyance

1582930194
fengb
Most of it wouldn't pass normal linting rules

1582930209
shakesoda
it's weird, and then you learn that it is weird, and then you have tools that tell you you've encountered the weird again.

1582930212
shakesoda
and then you move on

1582930275
fengb
MichaÃ«l Larouche: hated MFC. GTK felt pretty raw and it renders ugly on non-Linux. I actually think Cocoa is one of the best designed APIs once you get over its weird architecture

1582930282
shakesoda
I generally don't think of c++ as being a good idea for most software, everything in it is a collection of guns pointed in every direction

1582930301
shakesoda
unfortunately, I also work in games, and c++ is incredibly common. as is being shot.

1582930321
BaroqueLarouche
in games it's either C++ or C#

1582930332
fengb
Let's fix that!

1582930340
BaroqueLarouche
and shipping C# code on consoles is...."fun"

1582930362
metaleap
fengb: "And yes, we've gotten lazy but we can't all be doing C++ every day and ship features as fast as business wants them" --> thats the narrative but what i witness in reality is that where "business" relies on nominally-simpler-than-C / GC'd stacks such as java/.net and equivs, an overall sloppier dev atmo emerges that leads to coders being really sluggish with every silly little task and introducing dumb bugs left and right. moving from all the

1582930363
metaleap
high-level hand-holding stuff to sth like zig showed me that a tech requiring the utmost attention and discipline wrt mem & resources carries that over to the other "domain" aspects & design decisions, i think. the projects i've seen in hi-level stacks that 100s of devs laboured over endlessly yet listlessly over a decade or so.. could be leaned up so tightly if it could just be reset, but "business" would never go for it. so it goes

1582930393
shakesoda
yeah, it's a bit hard to avoid c++ (or c#) in games when you aren't flying solo

1582930458
shakesoda
i will say though, it's very likely the low level bits of my in-house engine will be moved to zig sooner than later (from c and a sprinkle of c++)

1582930468
fengb
metaleap: sure I agree but I don't think we'd have 10% of our large developer ecosystem if we stuck with older non-GC systems

1582930486
fengb
And we can argue how useful most of it is... but it pays the bills

1582930512
shakesoda
i have little concerns for anything but my own needs with it, and zig doesn't also force me to go all-in just to get things working, so it's a very much viable option

1582930530
shakesoda
the high level/game code is all haxe->lua, which I'm already fairly happy with

1582930555
fengb
I'm also not a game dev. I've heard... rants from Jon Blow and he'd probably hate my guts if he met me >_>

1582930577
shakesoda
uh I am not sure I'd worry too much about his opinion specifically

1582930588
shakesoda
he's a smart guy and all, just with a lot of burning hot takes

1582930620
shakesoda
i'm not sure if i'd get along with him either. maybe.

1582930673
fengb
Oh yeah. But I do sense a degree of smug from a lot of game devs. I can understand the resentment... but I really couldn't care about my data layout when I'm dealing with concurrency issues because users click on random things

1582930702
fengb
Most of my hard problems are because browsers suck or concurrency crap I can't control

1582930734
fengb
Anyway... I think I digressed enough

1582930737
shakesoda
well, when at all possible you should always care about basic performance properties - at least in so far as to not obviously do things in the worst ways

1582930742
jaredmm
Eh, it all matters. We stack inefficient software on top of inefficient software repeat for multiple layers and then try to find ways to make things passibly fast.

1582930749
shakesoda
yeah, that's the thing there

1582930767
shakesoda
bad performance in anything compounds, in all the software you use and build

1582930793
shakesoda
does everything need to be as fast as is humanly possible? no - but it shouldn't be

1582930819
shakesoda
gamedevs are particularly sensitive to this, because our entire lives are measured in small numbers of milliseconds :)

1582930833
jaredmm
I mean, most game devs aren't great, either. They're the same as everyone else, trying to get a job done. You typically have one or two guys that are focused on trying to set people up to succeed, but then you let everyone else into it and oops, they've got deadlines.

1582930868
shakesoda
game devs are a broad category, too, lots of very different work

1582930876
betawaffle
shakesoda: what games do you work on?

1582930919
betawaffle
andrewrk: your hour is up

1582930942
jaredmm
As a profession, I think we set ourselves up for failure in a lot of ways. No one understands hardware, everything is hard, and everyone wants the world.

1582930982
betawaffle
hardware is surprisingly complicated

1582930985
shakesoda
betawaffle: recent projects nda, past highlights include skullgirls, stepmaniax, various indie games that have needed better render performance or porting (and, sometimes, 3d models)

1582931001
fengb
Also the free lunch is up. We can no longer just throw hardware at problems

1582931033
jaredmm
I understand why there's people raging against the machine, but for the majority of the work that we do, the cost of the development is visible while the cost of doing that development wrong is amortized over a very long time and written off by the next guy to come in as "the old guard didn't know what they were doing".

1582931040
fengb
Software engineer: coasting on the shoulders of hardware engineers since 1950

1582931052
betawaffle
fengb: but we are... we're just throwing

1582931071
Sahnvour
jaredmm: gamedev is crippled by tight schedules and bad management usually though, people outside of specialists just don't have the time to learn this stuff because you gotta get that new feature for the next milestone

1582931073
shakesoda
hardware is indeed complicated but the most needed work for making things run well is the basics, not the intimate details.

1582931092
fengb
betawaffle: it actually requires rethinking and redesign now. In the golden day we literally did nothing but wait a few years, but now we gotta account for parallelizability

1582931103
shakesoda
the stuff that costs very little time and fairly minimal knowledge to do as you go

1582931104
jaredmm
Sahnvour: you can replace gamedev with every industry, but I agree.

1582931112
Sahnvour
sure

1582931301
betawaffle
i still can't figure out why Go has native complex number types

1582931303
jaredmm
On Blow specifically, he's just saying a lot of things that build up after dealing with all the problems with development. He made enough money that he was able to indulge in some grand ideas for change. I'd be interested in seeing if his opinion changes the deeper into it he gets.

1582931351
betawaffle
like, it would make sense if it had more than only complex numbers...

1582931363
betawaffle
but that's the only "weird" built-in type it has

1582931374
fengb


1582931400
fengb
I think most of the reasoning behind Go can be summed up with "because word-of-god wanted it"

1582931401
jaredmm
When it is your money burning away every month, you quickly realize why a lot of the inefficiencies exist. It isn't a great choice, but saving money now vs. potentially losing some in the future due to maintenance costs (or if you're some companies, continuing to charge to fix problems you made in the first place).

1582931476
shakesoda
jaredmm: ye olden technical debt, acceptable costs etc

1582931527
betawaffle
i think zig needs complex numbers, quaternions, decimal fixed-point numbers, rationals, matrices, etc.

1582931556
shakesoda
betawaffle: except for complex numbers these would all be very useful to me, and I completely disagree :D

1582931560
jaredmm
I'm working on rewriting an application right now because of requirement changes and technical debt that has created security issues, looking at 10 year old TODOs.

1582931587
betawaffle
shakesoda: you use quaternions a lot i bet

1582931594
shakesoda
I do, actually.

1582931614
betawaffle
aren't they just a 4-dimensional version of complex numbers?

1582931637
shakesoda
hmm, that's a reasonable way to describe them

1582931671
shakesoda
jaredmm: one of the games I work on has amassed about 20 years of technical debt, and some brave souls have finally put in the work to kill a lot of it in this last year

1582931675
shakesoda
it is a wonderful thing.

1582931696
betawaffle
anyway... that sort of proves that

1582931707
betawaffle
i like the way that haskell does it

1582931718
betawaffle
you can define whatever the fuck operators you want

1582931732
betawaffle
:=- can be an operator

1582931747
companion_cube
:-/ can be one too

1582931760
shakesoda
this is the case where operator overloading is useful, but it's also not so big of a loss to not have it in my experience

1582931768
shakesoda
operator overloading hides

1582931787
betawaffle
fair enough

1582931790
jaredmm
Principle of least surprise and all that leads me to prefer a language that can be expressive without overloading. Symbols don't immediately make me think about everything that could be going on behind them, especially when overloaded.

1582931827
shakesoda
yeah, exactly, not having that concern is something I've been liking about zig

1582931840
jaredmm
When you work with a lot of people who will try to write `genius` code for everything, it gets tiresome trying to keep that unique context in your head per application while a function call is an obvious sign that I need to see what the function does.

1582931840
betawaffle
i suppose a reasonable stance to take would be every operator has to map to a single instruction, generally

1582931840
shakesoda
I can see quite clearly the full extent of what I am dealing with, by what it says.

1582931888
fengb
Not all instructions are the same speed ðŸ™ƒ

1582931920
shakesoda
jaredmm: that has been a very real and severe issue in... most... of the c++ codebases I've ever had the misfortune to work on

1582931926
betawaffle
let me ask a probably silly question... why do we allow operators at all? why not only function calls?

1582931957
fengb
andrewrk has (facetiously?) threatened to take out operators before

1582931978
betawaffle
stream when?

1582932030
betawaffle
my only problem with function calls is paren soup

1582932033
fengb
I'd argue that if we get rid of operators, we might as well move towards Lisp syntax

1582932040
shakesoda
betawaffle: for the basic types where the ops quite reasonably map to basic cpu instructions on every machine, 1 + 1 will involve no surprises

1582932074
shakesoda
meanwhile a * b hiding a matrix mult and who knows what else, could be a very big and expensive surprise in the wrong place.

1582932075
betawaffle
except that we know that's not true shakesoda...

1582932091
betawaffle
just think of overflows, wrapping, saturating

1582932101
betawaffle
it all gets very complicated and non-obvious

1582932113
shakesoda
zig watches out for such things :)

1582932119
Snektron
<BaroqueLarouche "who needs unsigned int anyway ? "> - also soustroup, 2019

1582932133
betawaffle
i would like to see saturating arithmetic

1582932135
fengb
Well in Zig, we have illegal checked behavior when things get non-obvious

1582932174
fengb
And force you to make a decision. I actually think this is a very nice solution

1582932186
shakesoda
I think this also encourages taking simpler approaches

1582932189
betawaffle
i like being forced to make a decision

1582932217
fengb
Sometimes it gets annoying... like `i64 - u8`... I know why I want to do damnit

1582932221
shakesoda
the language encouraging good behavior is very much desirable

1582932231
betawaffle
what i don't like is that i can't put methods on non-struct types!

1582932243
shakesoda
can't you also put them on enums?

1582932259
betawaffle
yeah, but that's not enough

1582932278
dhawkie
hi guys. really excited about starting a new project in Zig, using  C interop. but I am having trouble from the get-go. I am statically linking to a c library. the library has a huge struct with over 100 complex fields. it also has functions that act on that struct. there is a function in the library that takes the struct and initializes the

1582932279
dhawkie
contents. but to create and pass that struct(from cImport->cInclude) from Zig I have to fill all the fields first.. how can I bypass this and provide a struct/something to the library to act on? i tried to create a c wrapper to create the uninitialized struct, but ran into other issues. maybe there's a simpler way... thanks for any help!

1582932291
fengb
`const Wrapper = extern struct { data: u64 };` ðŸ™ƒ

1582932293
betawaffle
i want too put them on floats, and i want native flag types

1582932311
betawaffle
too...

1582932326
fengb
dhawkie: you can define an uninitialized variable with `var foo: Type = undefined;`

1582932342
fengb
Or zero it out with `var foo = std.mem.zeroes(Type);`

1582932421
dhawkie
aah, "undefined", i saw that somewhere but had forgotten it. thanks, i'll try it

1582932425
daurnimator
dhawkie: ask yourself: what do you

1582932450
dhawkie
whatever basically, they will get overwritten anyway

1582932457
daurnimator
dhawkie: either they need to be initialised to some special value; or they can be undefined; or the C library assumes 0 initialisation (which would be treacherous for different variable types...)

1582932543
daurnimator
dhawkie: ah right: yeah you could be searching for the pattern: `var foo: Type = undefined; if (mylib.initmything(&foo) != mylib.code_okay) return error.FailedToInitialise;`

1582932598
betawaffle
is an inline for with ifs ultimately the same as a switch?

1582932613
betawaffle
do switches ever turn into something more efficient?

1582932638
betawaffle
like a binary search, or jump table?

1582932647
fengb
LLVM will probably optimize them both into a jump table

1582932659
betawaffle
both?

1582932662
betawaffle
interesting

1582932672
daurnimator
betawaffle: switches often turn into jump tables; `if` tends to turn into branches

1582932678
fengb
Switch definitely, inline if it recognizes it

1582932702
daurnimator
betawaffle: though LLVM may optimise things....

1582932725
betawaffle
i guess i'm too used to Go's level of optimization

1582932733
fengb
I think doing simple `if (same_var == foo)` or slightly complex `if (mem.eql(u8, same_var, "foo"))` works fine, but no guarantees

1582932774
fengb
When it doubt, check Godbolt. I had to do some prodding to get LLVM to cooperate:

1582932783
shakesoda
zig spares me from worrying about a lot of the more trivial optimizations and I appreciate that greatly

1582932788
betawaffle
the reason i ask is you can't build a switch at comptime, but you can do an inline for with all comptime-known values

1582932804
fengb
Ah yeah, I kinda want to make a proposal for generating a switch

1582932840
daurnimator
andrewrk: did you ever give git-bug a try?

1582932906
betawaffle
when the zig package manager stuff is done, i hope most of std can be turned into completely optional and replaceable packages

1582932944
companion_cube
beware of the npm effect

1582932966
daurnimator
betawaffle: yes the intention is to split a lot out. However we also want the package manager itself to be implemented with the standard library

1582932971
betawaffle
yeah, well we need to figure that out too, because it's real... npm, rust, and go all have that problem at least

1582932989
fengb
I'm still hoping we can have a defacto curation system going

1582933000
andrewrk
dependency proliferation is a problem in the sense that bugs in software are a problem

1582933002
companion_cube
I think the stdlib at least needs a good set of containers, json, and some IO

1582933022
daurnimator
companion_cube: e.g. why json?

1582933027
andrewrk
give someone a programming language, and they will create bugs

1582933040
andrewrk
give someone package management, and they will create dependency proliferation

1582933060
companion_cube
daurnimator: so taht everyone agrees on the type and can use it without questions

1582933064
andrewrk
the solution is the same: better tooling to help guide programmers to prevent problems

1582933076
fengb
andrewrk: not always true. Ruby tends to feature a core of a few common gems because the community gelled around them

1582933084
daurnimator
speaking of json, once

1582933086
betawaffle
right, so what tooling can help the package management problem?

1582933100
companion_cube
steam achievements when you remove dependencies

1582933107
fengb
npm ecosystem decides on a whim, so you end up with duplicates of everything

1582933130
daurnimator
fengb: on the other hand, in lua that centralisation/agreement never happended, so you have 10 different libraries for arrays...

1582933145
betawaffle
go was doing pretty well until modules

1582933158
fengb
Right, I feel like it's a solvable `*social*` problem, but definitely not solved by most ecosystems

1582933162
companion_cube
I'd say that standardizing at least *types*/interfaces is good

1582933162
betawaffle
it's almost as if the easier it is to depend on things, the more people will depend on...

1582933174
companion_cube
then you can still have libraries making various choices for implementation

1582933190
companion_cube
(see `future` in rust)

1582933190
daurnimator
betawaffle: there was a saying in python: "the standard library is where modules go to die"

1582933208
companion_cube
and yet, the stdlib is what makes python so convenient ootb

1582933213
companion_cube
for scripting and such

1582933216
betawaffle
companion_cube: i do like the idea of standardizing interfaces

1582933223
betawaffle
speaking of interfaces...

1582933229
fengb
Maybe we can have a distributed stdlib...

1582933235
companion_cube
imagine if your io reader interface is not commonâ€¦ ðŸ˜±

1582933239
daurnimator
companion_cube: sort of... when I write robust python I always end up having to swap out stdlib modules

1582933243
frmdstryr
Just jumped on, if you're talking about package managers I'd highly recommend looking at how conda does it

1582933250
betawaffle
companion_cube: tbh, that's the problem i have in zig right now

1582933255
companion_cube
heh, I wouldn't write robust python, just small scripts :p

1582933256
betawaffle
i don't get streams yet

1582933279
fengb
Oh boy... yet another Python package manager? :P

1582933296
frmdstryr
conda is robust because every package build is done in a completely new env

1582933322
betawaffle
can we learn from nix somehow?

1582933327
daurnimator
frmdstryr: zig packages are going to be source-only to start with

1582933338
companion_cube
can nix learn to not want to own the whole system? :p

1582933366
betawaffle
companion_cube: that's kinda my problem with it still

1582933382
betawaffle
i'm on a mac, and it's not trivial to make it happy on latest OS version

1582933400
fengb
Oh yeah, Catalina removed support to write to /nix

1582933412
betawaffle
you can make it work, but it's high-touch

1582933436
betawaffle
andrewrk: stream never?

1582933502
frmdstryr
daurnimator: How does that work if it has external c/c++ deps?

1582933554
daurnimator
frmdstryr: great question. I've thought it through that build.zig should contains declarations like external dependencies and other misc configuration.... but maybe that should be in an easier-to-parse-for-others format

1582933588
daurnimator
fengb: did you get anywhere with moving std.fmt to streams?

1582933601
fengb
Nah, I haven't looked yet

1582933621
frmdstryr
conda solves it by building specific libs, eg Qt and bundling it as a package so you can specify and build against specific versions

1582933660
frmdstryr
it's pretty much like debian but "app" level instead of os level

1582933674
fengb
I think one of the goals is to make C/C++ shippable in Zig packager

1582933720
frmdstryr
yeah that's the proper way, then it can all be bundled into an installer easily as well

1582933767
andrewrk
betawaffle, I wanted to show off the latest changes regarding os versions as part of target info, and I didn't get it done in time, so I'm going to postpone to tomorrow

1582933830
dimenus
andrewrk: i'm reviewing your changes in the os-version-ranges branch and I'm a bit confused as to how glibc versions fit into the new system. If I specify a glibc version, should that generate a non-native targeT?

1582934051
andrewrk
dimenus, an important new feature of this branch is granularity into specifying what exactly about a target is native and what is not

1582934070
andrewrk
for example, one can do this now: -target native-native-gnu.2.10

1582934084
andrewrk
one will get a fully native target, except with an overridden glibc version

1582934150
andrewrk
another interesting example would be (on linux): -target native-windows

1582934159
andrewrk
or in the WSL: -target native-linux

1582934192
andrewrk
in the former case you could run an executable in Wine with native CPU features; in the latter case a linux executable on windows with native CPU features

1582934224
dimenus
andrewrk: that's what i expected actually - but it doesn't seem to function correctly yet

1582934230
andrewrk
in the branch?

1582934232
dimenus
yep

1582934237
andrewrk
which example?

1582934254
dimenus
i'm just calling 'setGnuLibCVersion' in my build.zig

1582934274
dimenus
that emits a regular native target instead of the one you defined above

1582934285
andrewrk
that function doesn't exist in this branch

1582934330
andrewrk
that data is specified as part of the target now

