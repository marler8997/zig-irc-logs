1584835346
andrewrk
mikdusan, yeah I just spent the entire stream implementing the preprocessor more completely

1584837228
pixelherodev
ifreund, Are you using wlroots, or writing it all from scratch?

1584837661
ifreund
pixelherodev: wlroots for sure

1584837712
ifreund
no reason to reimplement all of that, and I doubt I could do a better job then those folks have

1584837945
pixelherodev
Yeah, it's probably much easier to use wlroots in Zig than the Rust-Wayland peeps had it

1584837948
andrewrk
on the stream today we successfully compiled LuaJIT natively with `zig cc`. it almost worked with -target aarch64-linux-musl but ran into lld: error: undefined symbol: __divtf3

1584837965
pixelherodev
So just a single function missing in compiler-rt?

1584837972
andrewrk
looks like it

1584838415
ifreund
pixelherodev: well the wlroots-rs people attempted to create safe bindings, which is very hard to do with how lifetimes are managed in wayland

1584838424
ifreund
if they had just used unsafe it wouldn't have been very hard

1584838444
fengb
But unsafe is evilllllll

1584838535
mq32
nice thing about comptime_int: it doesn't care about signedness

1584838552
mq32
C/C++ is so picky about sizeof() and ssize_t

1584838556
mq32
all those warnings

1584838576
Bekwnn
size_t is such a headache

1584838587
ifreund
wayland can be done in safe rust (see

1584838639
mq32
Bekwnn: size_t is zigs usize (kindaish)

1584838644
ifreund
i've used it for wayland clients, but there's nothing that can stand up to wlroots for compositors

1584838653
ifreund
plus I wanted to learn zig :D

1584838675
Bekwnn
does the std tend to return things in usize prolifically like the c++std does though?

1584838700
Bekwnn
I haven't noticed it do that much. Meanwhile in C++ you use vector and WHOOPs into size_t land you go

1584838719
fengb
std prefers usize when dealing with memory based indexing

1584838720
ifreund
what's wrong with that? it's the accurate type to use

1584838945
Bekwnn
I'd prefer it to be part of the template definition personally. Most C++ programs can be sped up by creating a vector class that uses int32_t internally for capacity and size

1584839178
Bekwnn
uint*

1584839990
daurnimator
ifreund: are you particularly familiar with wayland already?

1584840130
ifreund
daurnimator: not an expert by any means, but this compositor isn't my first wayland project

1584841004
andrewrk
clang has an -O4 flag o.O

1584841166
Bekwnn
I remember reading about how there is virtually 0 difference between O2 and O3

1584841407
pixelherodev
That's not true

1584841414
pixelherodev
-O2 is different from -O3

1584841428
pixelherodev
But anything above -O3 on GCC is literally identical (e.g. -O4)

1584841438
pixelherodev
Well, might be true on Clang

1584843612
Bekwnn
pixelherodev: I'm struggling to find it, but it wasn't so much about them

1584843617
pixelherodev
Ah

1584843621
pixelherodev
That's probably pretty accurate

1584846700
pltrz
ifreund[m] are you me?

1584846734
pltrz
hahaha jokes aside, I feel the exact same way about dwm and sway

1584846779
pltrz
I like the master-slave model of dwm

1584846826
pltrz
i was just thinking these days of starting a dwm-like under wlroots

1584846834
pltrz
do you have a repo?

1584857209
watzon
Can I tell you how much I can not wait for zig to work well as a drop in C compiler?

1584857228
watzon
I missed today's stream, gotta watch it later

1584867307
kenaryn
Hello computer people. Does anyone have tried NixOs AND VoidLinux and would accept to tell a few words about its both strengths and flaws? I wish to abandon Debian stable for a simpler and more efficient dependencies' system. Thank you

1584869187
ifreund
pltrz: repository is

1584869210
ifreund
building on another machine might require some tweaks to the build.zig even

1584869304
ifreund
kenaryn: NixOS is really great for managing multiple conflicting configs and sorta sandboxing development environments

1584869307
ifreund
unless you

1584869349
ifreund
unless you've bought into the systemd hate meme, I'd recommend arch over void for most use cases as it's just simpler/easier to work with

1584869773
kenaryn
Thank you for your feed-back ifreund. mikdusan said nevertheless no more later than yesterday that ArchLinux was quite difficult to maintain it updated. Do you disagree?

1584869919
ifreund
yeah, it's not hard at all imo.  Also void is rolling release just like arch

1584869938
kenaryn
I didn't know that last point.

1584869990
ifreund
it's not like you need to update arch every day like some people do, you can easily go months without having issues

1584870006
ifreund
as log as you don't do any partial upgrades of course

1584870032
ifreund
also updating is not hard, far easier than updating a debian based system for example

1584870181
ifreund
really you can't go wrong with nix, void, or arch though. Try em all and see which you like best imo

1584870547
kenaryn
You're kind. In fact, it is intended mainly for web developpment and later for embedded programming. Does virtual environments would be sufficient or a OS-related sandboxing would be more appropriate?

1584870850
ifreund
i personally just use arch + virtualenv for python and docker for a few other things.  Hard to say if that'd be sufficient for your needs since I don't know exactly what they are

1584871294
kenaryn
Thank you, I think it's clear enough. By the way, do you know any advantage for virtualenv over venv?

1584871361
ifreund
same think afaik

1584871499
kenaryn
Allright, I will not talk about anything else than Zig for now. Andrew Kelley dislikes pretty much the signal/noise ratio's decrease. Thanks again =)

1584871619
ifreund
no problem, sorry for the off topic talk andrew

1584886790
ifreund
is it considered idiomatic to use @This() everywhere inside structs as one would do with `Self` in rust?

1584888531
andrewrk
there's nothing wrong with doing that. Personally I prefer to use `const Self = @This();` and then refer to `Self`

1584889153
ifreund
pretty neat that zig just lets you do stuff like that with types :D

1584889402
andrewrk
this site is handy:

1584889406
andrewrk
it would be neat to have a zig version of this

1584889426
andrewrk
need that wasm build of zig :)

1584889534
ifreund
looks like they accept new tutorials as pull requests

1584891982
andrewrk
argh this is throwing a monkey wrench into my efforts to prepare the CI for llvm 10:

1584892059
mq32
oh no!

1584892167
andrewrk
oh... that was the paris region. the amsterdamn region is all stocked up... I think I might have a guess as to why

1584892626
frett27
seems every body is launching a covid 19 following app :-)

1584892651
frett27
there's a lot of work on this on github thoses days in EU

1584892653
mq32
i'm coding c++ right now and i'm sooo missing a good autoformat and trailing-commas in function calls

1584892719
fengb
Clang format doesnâ€™t work that well?

1584892748
mq32
nah, not with my coding style

1584892763
mq32
for multi-line function calls i'm using zig style (even before zig)

1584892775
fengb
Best part of zig fmt: your coding style doesnâ€™t matter!

1584892777
mq32
but looks like that's not the preferred c++ way of life :D

1584892843
fengb
Yeah Zig matches my opinions better than most languages. But I was also happy to swallow my pride when working with Go

1584893107
scientes
go also means you have to swallow your desire for manual memory management

1584893137
scientes
and @fieldParentPtr()

1584893204
mq32
btw, most malicios thing in clang-format: SortIncludes:    false

1584893242
mikdusan
btw, most malicious thing in c/c++: includes :P

1584893822
mq32
mikdusan: yep

1584893831
mq32
and compile time optimizaton based on include orders

1584896884
shakesoda
mq32: anything that's not the preferred c++ way of life is probably for the better of society ;)

1584896934
mq32
shakesoda: I throw "TType" at you

1584896941
mq32
and FField

1584897027
fengb
The non-preferred C++ way is probably worse than preferred :P

1584897623
companion_cube
scientes: is that really a strong desire in you?

1584897643
companion_cube
personnally Go seems like it'd kill me over my desire for sum types and generics

1584897779
fengb
Oh I just meant that I absolutely despised the Go style but I stopped caring

1584897844
companion_cube
that's still nice yeah.

1584897943
fengb
Whereas Zig mostly matched my opinions already >_>

1584901900
adamkowalski
do we have a way to cast an anonymous list of T to a []const T?

1584902077
shakesoda
adamkowalski: doesn't []T coerce to []const T? (just not the reverse)

1584902113
shakesoda
or do you not have a []T to begin with

1584902200
adamkowalski
well that's the thing, i'm trying to make my api accept any of those

1584902211
adamkowalski
I have `session.run(foo)`

1584902224
adamkowalski
where if foo is a single tensor then the output type should also be a single tensor

1584902246
adamkowalski
if you pass me in a array of tensors where the length is known at runtime, I will return to you a dynamically allocated array of answers

1584902265
adamkowalski
if you pass me a array of tensors with a the length known at compile time, I will return to you a statically allocated array of answers matchig the length

1584902282
adamkowalski
if you pass an anonymous list of tensors then it should be treated as if it's a compile time known array

1584902335
shakesoda
sounds kind of like you're doing this sort of thing

1584902384
shakesoda
this lets you pass in, say, f32 and get a pointer to a buffer of f32's, or [3]f32 and get out a pointer to a list of those etc

1584902413
adamkowalski
kindof

1584902425
adamkowalski
the output type should mimic the input type

1584902439
adamkowalski
mind taking a look at an example?

1584902470
adamkowalski
if you look here

1584902485
adamkowalski
line 105 I have session.run(y)

1584902510
adamkowalski
does that example there make sense or should I explain it?

1584902597
shakesoda
this has a surprising amount of try's, kind of odd to have so many failure cases in the api

1584902602
shakesoda
anyway, i'm looking for how run is defined

1584902655
adamkowalski
alright that function is a monster, so it might make sense for me to explain with some context first

1584902656
shakesoda
you're already using @TypeOf like I'd have suggested

1584902682
shakesoda
so I'm not sure I know where the problem is

1584902683
adamkowalski
the library is called compute graph, and it's trying to be a competitor to tensorflow/pytorch

1584902693
adamkowalski
but everything is written from scratch in zig

1584902718
adamkowalski
it's designed to operate on what are called tensors

1584902734
adamkowalski
so scalars, vectors, matrices, cubes

1584902756
adamkowalski
however, it's a lazy API so when you say `add(&graph, x, y)` it doesn't actually add

1584902772
adamkowalski
it just creates an operation on the graph saying eventually I want to add x and y

1584902801
adamkowalski
operations on the graph are polymorphic and not known until runtime so you need to allocate space for them on the graph and hold essentially a vtable

1584902809
adamkowalski
hence every operation requires a try

1584902841
adamkowalski
then when you call session.run(foo) it will actually look at the graph, figure out what are the fewest nodes needed to compute the answer and finally do the work

1584902855
adamkowalski
hence it needs to allocate again since we are working with matrices

1584902895
adamkowalski
does that all make sense? i'm happy to answer any questions, and also try to defend the design I have

1584902907
adamkowalski
I also encourage you to throw tomatoes or say how I can improve the API

1584902929
adamkowalski
the problem is however, that when calling session.run often times you want to know the value of several tensors

1584902950
adamkowalski
so if you can call session.run(a) to just get the value of a

1584902965
adamkowalski
or you can call session.run(&[_]Tensor{a, b}) to get the answer of both a and b

1584902977
adamkowalski
I want to simplify that syntax to session.run(.{a, b})

1584902988
adamkowalski
but all 3 types of parameters should be accepted

1584903036
adamkowalski
and the output type of session.run depends on the input type passed in

1584903203
shakesoda
i feel like you could avoid most of the trying by preallocating some sufficient amount of memory for operations and set a flag for a completeness check slightly later or something, but at least it seems reasonable given the explanation

1584903258
shakesoda
I see the problem though, and I'm not sure enough about the way anonymous lists are typed

1584903333
shakesoda
maybe the best approach here is to look at one of the std apis that take in an anonymous list?

1584903780
adamkowalski
shakesoda: the problem then would be that if you don't know how big the graph is up front you will get a random failure at a certain point

1584903815
adamkowalski
the idea is that the allocations for graph construction don't matter because you do it once at the start of your application

1584903828
adamkowalski
the portion that will be run frequently and needs to be fast is `session.run`

1584903842
adamkowalski
that is how you will make predictions, and actually generate concrete values

1584903866
adamkowalski
also, each operation can fail because I do shape and type inference

1584903894
adamkowalski
for example if you add two their and their shapes don't match up and cannot be broadcasted together then it is an error as well

1584903907
adamkowalski
then I can offer something that google and facebook cannot

1584903918
adamkowalski
which is that if you have an invalid graph you can detect it at compile time

1584903924
adamkowalski
once we get compile time allocators that is

1584904006
shakesoda
it's just frustrating to have that much surface area for potential failures

1584904019
shakesoda
imo

1584904075
adamkowalski
and I'm open to how to clean it up

1584904098
adamkowalski
I can get rid of the try for Graph.init and Session.init once we get return value copy elision

1584904127
adamkowalski
I'm currently allocating the arena on the heap because other fields within the structure need to reference it

1584904154
adamkowalski
but as far as errors when trying to add two tensors I"m not sure how you can ever garuantee those are going to work

1584904164
adamkowalski
especially since most of the time the values are not known till runtime

1584904228
adamkowalski
I think I got the anonymous list syntax working though!!!

1584904245
adamkowalski
but my compile times are starting to increase A LOT with all this meta programming

1584904393
shakesoda
the only way I can think of that'd avoid all the failure cases is if you had something like a prepare function that took in an operation list and types, then filled it out after, but i feel like that just causes new usability problems

1584904441
shakesoda
it's probably viable, but i don't know if it'd be

1584904496
fengb
According to andrewrk, comptime is around 100x slower than it should be

1584904498
shakesoda
and heh, compile times are a pretty strong reason i keep my metaprogramming minimal

1584904503
shakesoda
in all langs, not just zig

1584904534
adamkowalski
fengb: thank god, i'm gonna bank on that fact and keep on going with my current approach

1584904549
adamkowalski
shakesoda: we don't have overloading so it's necessary in a lot of places it wouldn't otherwise be

1584904558
shakesoda
overloading is a worse solution regardless

1584904561
adamkowalski
i'm trying to keep it down when possible

1584904573
adamkowalski
shakesoda: whats wrong with overloading

1584904588
adamkowalski
I think it makes more sense to use overloading or a trait system then have methods on classes

1584904594
adamkowalski
because then classes are not open to extension

1584904616
fengb
I don't like extensible classes

1584904621
shakesoda
overloading as a solution is something you end up with when you've already lost

1584904644
adamkowalski
I've got further questions for both

1584904647
shakesoda
like, it's always to address another failure, and adds ambiguity :\

1584904661
adamkowalski
shakesoda: how would you approach the problem I was just solving

1584904681
adamkowalski
I wanted to provide a uniform API for people so that it doens't matter what you are running you always call session.run

1584904722
adamkowalski
otherwise I would need `runTensor`, `runTensors`, `runTensorsThatAreActuallyAnonymousLists`, `runTensorsThatAreInAStaticArray`

1584904748
adamkowalski
fengb: my graph supports several different scalar types, f64, f32, f16, i64, etc

1584904760
adamkowalski
lets say that instead of that you wanted a type that made sense for your domain such as dollars

1584904763
adamkowalski
or watts

1584904784
adamkowalski
you cannot extend my system with your new type because I rely on things such as + being defined

1584904812
adamkowalski
so you could say okay, make a new function add which can you freely add to your type and then as long as you can x.add(y) you're golden

1584904822
fengb
You're talking about polymorphism, which I'm fine with

1584904823
mikdusan
adamkowalski: not sure if I understood array/slice/anon above, but here's a quick stab at a single-function allocating if runtime len:

1584904825
mikdusan


1584904833
adamkowalski
well but now your screwed because I cant extend i32 to support add

1584904840
shakesoda
I don't think the run is where the design problem is happening - everything else is too abstract to begin with, and I have a feeling you could constrain the solution at some much earlier step to avoid a lot of troubles

1584904842
adamkowalski
I can't overload so I can't just do a add(x, y) either

1584904868
shakesoda
I'd have to go solve the whole thing myself to go further down that thought rabbit hole though.

1584904888
adamkowalski
shakesoda: well like I said I'm open to any and all ideas

1584904892
adamkowalski
but the fundamental problem I have

1584904900
adamkowalski
is you need to suppor tensors

1584904902
shakesoda
call it a gut feeling that there's an earlier point where you could constrain the types and simplify everything

1584904908
adamkowalski
which are scalars such as 5

1584904912
adamkowalski
vectors such as .{1, 2, 3}

1584904921
adamkowalski
matricies such as .{.{1, 2,}, .{3, 4}}

1584904941
adamkowalski
cubes .{.{.{1, 2}, .{3, 4}}, .{.{5, 6}, .{7, 8}}}

1584904946
adamkowalski
and arbirary levels of nesting

1584904954
adamkowalski
and then you can say add(graph, x, y)

1584904967
adamkowalski
add does not care what you are dealing with, it will give you back the appropriate tensor

1584904993
adamkowalski
and the other constraint I have which I have spend many weeks on

1584905027
adamkowalski
you need to be able to take the derivative of any arbitrary mathematical expression

1584905045
adamkowalski
so you need to know the entire computation graph so you can analyze it and understand how to differentiate through it

1584905073
adamkowalski
thats the esesence of modern machine learning and gradient based optimization (what others call neural networks)

1584905109
adamkowalski
and you need to be able to support differnt scalar types to be able to handle high or low precision so you can make the tradeoff between precision and performance

1584905248
adamkowalski
all of that is already implemented, and there are tons of tests to show the different use cases. so if you look at any of those and think i'm doing something unidiomatic please let me know and I will gladly fix it

1584905870
TheLemonMan
pixelherodev, are you still seeing stack traces w/o file names and line numbers?

1584906305
jaredmm
Where's a good example in std for OS conditional usages? std.net uses some os.SOCK_* values that aren't defined on all OSs.

1584906371
andrewrk
jaredmm, perhaps lib/std/fs.zig

1584906392
andrewrk
`std.Target.current` is a comptime value with all the information about the target

1584906412
andrewrk
for example you can `switch(std.Target.current.os.tag)`

1584906462
andrewrk
if that seems like a lot of boilerplate, it's because zig gives you

1584906496
pixelherodev
TheLemonMan, I believe so

1584906500
pixelherodev
I can pull trunk and try again if you want?

1584906505
TheLemonMan
yep

1584906734
pixelherodev
TheLemonMan, got a bug with which to trigger a backtrace?

1584906764
TheLemonMan
pixelherodev,

1584906776
pixelherodev
thanks

1584906836
pixelherodev
`???:?:?: 0x7f96c28705a0 in ??? (???)`

1584906838
pixelherodev
TheLemonMan, I'd say so

1584906928
kenaryn
andrewrk what is the host's name you mentionned with ARM processors out of stock in Paris region? I think I'm being swindled with PlanetHoster.

1584906973
andrewrk
TheLemonMan, is this the error you were mentioning getting with llvm10/polly?

1584906981
TheLemonMan
pixelherodev, try

1584906986
andrewrk
because it's happening in the llvm10 branch on ubuntu with the llvm apt repo

1584906996
TheLemonMan
andrewrk, yep

1584907010
andrewrk
hmmm this is a regression from 9. quite annoying

1584907031
andrewrk
kenaryn, scaleway

1584907050
kenaryn
Thanks a lot!

1584907101
TheLemonMan
packaging is hard

1584907179
andrewrk
worst case scenario we switch linux to also do a cached build from source, just like the rest of the OS's

1584907198
andrewrk
but that's a couple hours of work, which I was previously not planning to do

1584907221
pixelherodev
TheLemonMan, `???:?:?: 0x55bb02e698be in buf_hash (../src/buffer.cpp)` and so on

1584907250
TheLemonMan
awesome, can you fax me your `zig` binary?

1584907266
pixelherodev
... fax?

1584907291
pixelherodev
It's 120MB

1584907295
pixelherodev
How much paper do you *have*?

1584907321
TheLemonMan
I'm already chopping some trees

1584907328
TheLemonMan
yeah upload it somewhere

1584907334
mikdusan
I'm waiting for the day someone locates TheLemonMan and actually faxes him base64 binary in 14pt font

1584907379
pixelherodev
... where?

1584907388
TheLemonMan
Times New Roman or Comic Sans?

1584907390
pixelherodev
Where should I upload a 120MB file...

1584907406
pixelherodev
How about the Edwardian Cursive thingy

1584907468
TheLemonMan
filebin.net looks good enough

1584907582
andrewrk
wing dings. good luck cracking the code...

1584907601
andrewrk
here's something a friend of mine made:

1584907621
andrewrk
it has a pretty big flaw though

1584907623
andrewrk
it's not written in zig

1584907887
ifreund
0x0.st has a 512MiB maximum iirc

1584908020
pixelherodev
TheLemonMan,

1584908028
pixelherodev


1584908060
ifreund
I assume there's no way to get zig fmt to wrap lines yet?

1584908081
TheLemonMan
pixelherodev, danke

1584908088
andrewrk
ifreund, that's not planned. what you can do is hint about what should be on separate lines in various ways, such as using a trailing comma in lists

1584908115
andrewrk
zig fmt has no concept of line length

1584908182
mikdusan
hmm I don't get that llvm10 error. maybe because gcc-9.3.0 ?

1584908203
andrewrk
mikdusan, on ubuntu bionic with apt.llvm.org?

1584908211
mikdusan
archlinux

1584908224
andrewrk
it's a problem specifically with the packages in apt.llvm.org

1584908227
ifreund
so basically you're saying i just need to use some variables to break stuff like this up?

1584908234
mikdusan
ah ok nevermind me playing catchup :)

1584908237
ifreund
not my fault the variable names are so log :D

1584908244
ifreund
s/log/long/

1584908258
andrewrk
ifreund, yes or you can put a trailing comma after the last @ptrCast parameter

1584908295
andrewrk
ifreund, also, you should always use `const` instead of `var` unless you would get a compile error

1584908320
andrewrk
said another way, always `const` unless you plan to mutate it

1584908391
ifreund
really wish there was a compile warning that could be enabled to tell about unneeded `var`

1584908409
ifreund
though I assume that suggestion's already been made

1584908432
andrewrk


1584908468
andrewrk
you can also use . instead of .*.

1584908476
pixelherodev
TheLemonMan, does Zig hardcode the path to obtain debug info from? Could be because I have it in /usr/local

1584908521
andrewrk
ifreund, and finally, you can use a normal pointer for c.wl_listener, rather than [*c]. just pick the correct pointer type, it'll wok

1584908522
andrewrk
*work

1584908539
TheLemonMan
pixelherodev, it does use relative paths from the build directory, but that doesn't explain why there's no line infos

1584908548
ifreund
thanks for all the code review :D

1584908562
andrewrk
np. I'm proud that it's easy to review zig code without really seeing any surrounding context :)

1584908577
ifreund
it's fine to use the normal pointer even when I'm passsing a pointer to this function to the c library?

1584908611
ifreund
(hence the callConv(.C)

1584908612
mikdusan
Zig... putting code reviewers out of workâ„¢

1584908641
Barabas
Would be nice to get some actual work done =P

1584908663
Barabas
(Instead of spending my time reviewing stuff)

1584908664
andrewrk
ifreund, yes. [*c] represents the type system missing information, much like *c_void. it's always better when you can use one of the zig pointer types that actually tells you wtf is going on in the memory

1584908684
ifreund
sweet, good to know

1584908703
mq32
andrewrk: wasn't there a proposal to forbid C pointers in normal code?

1584908711
andrewrk
yeah still planned

1584908721
mq32
ðŸ‘

1584908733
Barabas
What is 'normal' code?

1584908752
mq32
non-autotranslated zig code

1584908764
mq32
User-written zig code has no reason whatsoever to use C pointers

1584908769
Barabas
ah ok, so you'd know when something is generated?

1584908818
andrewrk


1584908831
ifreund
wait so i've been using .*. everywhere for no reason? i'm too used to ->

1584908838
andrewrk
I'm slower on the draw, need to get back below 1,000 so I can be fast again

1584908861
Barabas
ifreund, yes life doesn't have to be so hard :D

1584908862
andrewrk
ifreund, yeah, I mean the code's not wrong

1584908875
mq32
oh no, 1003 issues! :D

1584908879
shakesoda
you do indeed not need to use so much .*

1584908905
ifreund
just not idiomatic :D, this is a great way to learn a language

1584908956
shakesoda
andrewrk: I still have some places where I need to [*c] in ptrcasts (calling a c api) and don't know the way around it

1584908969
ifreund
i got the straight up tranlation of the c code I was working off of done yesterday, today is splitting it up into a workable architecture and making it into more idiomatic zig

1584908974
mq32
shakesoda: why that?

1584908978
andrewrk
shakesoda, every one of these cases is either a bug in zig with the way type casting works, or ur doin it wrong

1584909009
pixelherodev
TheLemonMan, I build it in a subdirectory

1584909013
pixelherodev
Would that cause a problem?

1584909031
TheLemonMan
pixelherodev, I've reproduced yer problem, gimme a few mins to find out what's wrong

1584909048
shakesoda
mq32: because [*][*]T won't coerce to [*c][*c]T and I need the latter to do this interfacing

1584909057
mq32
ah

1584909059
shakesoda
so i had to ptrcast it

1584909070
mq32
you can also just adjust your translate-c output to be correct instead :)

1584909131
andrewrk
mq32, [*][*]T is supposed to coerce to [*c][*c]T

1584909137
andrewrk
oops, shakesoda ^

1584909185
shakesoda
if that's the case, it's a bug

1584909201
ifreund
nice, knowing that trailing commas control zig fmt has totally fixed my line length complaint

1584909228
TheLemonMan
the casting logic stops at the outermost cast

1584909278
Barabas
andrewrk should it though? The [*c] pointers can be null, right and [*] can't be.

1584909306
shakesoda
Barabas: as such it's safe to coerce

1584909314
shakesoda
(which is the case here)

1584909316
mq32
ifreund: trailing commas in function calls are just â™¥ï¸

1584909317
Barabas
So if you give [*c][*c] to someone you might get it back filled with nulls, which will break your [*][*]

1584909330
shakesoda
right

1584909348
Barabas
I'm pretty sure I had a similar case and andrewrk told me it doesn't work :P

1584909355
andrewrk
ifreund, you can also line break after `if (x)` and after any binary operator

1584909389
andrewrk
Barabas, shakesoda: oh, yes actually I think you just need to put `?` in the correct place

1584909404
andrewrk
the inner one

1584909435
shakesoda
that works

1584909486
ifreund
sweet, orelse is a binary operator. That fixes the other issue I had

1584909491
andrewrk
then you can additionally @ptrCast it to [*][*] but that obviously does not have safety checks, whereas normal coercions from [*c] have safety checks

1584909539
shakesoda
ptrcast to [*]?[*] was able to coerce to [*c][*c]

1584909610
shakesoda
it'd be nice if something like this case were documented, it's kind of hard to arrive at a reasonable solution for dealing with c apis that use **

1584909624
shakesoda
i had to burn quite a while figuring out how to convince that to obey me

1584910104
mq32
Now that i'm coding C++ again zig has awoken a deep fear of exceptions in me

1584910134
shakesoda
-fno-exceptions

1584910135
shakesoda
;)

1584910197
mq32
yeah, but then error handling will be painful :D

1584910206
shakesoda
not more painful than exceptions are.

1584910207
pixelherodev
`-fno-exceptions -fno-rtti -Wall -Werror -Wextra -pedantic -O3` is my default CXXFLAGS set

1584910219
pixelherodev
Remove `-O3` and it's the bare minimum I'll accept to work with C++

1584910223
shakesoda
pixelherodev: same, but not O3

1584910233
pixelherodev
Remove the `-fno-exceptions -fno-rtti` and it's my bare minimum for working with C

1584910255
mq32
pixelherodev:

1584910264
shakesoda
pixelherodev: but c doesn't have either of those anyways

1584910280
pixelherodev
I know

1584910281
pixelherodev
That's the point

1584910289
shakesoda
oh,

1584910291
shakesoda
missed the word

1584910334
shakesoda
for opt I usually use -Os or -O2, never really have trusted O3

1584910349
shakesoda
you can thank old gcc for that

1584910390
shakesoda
pixelherodev: I usually also have -g and -fno-strict-aliasing

1584910580
Barabas
without exceptions the standard library doesn't work in C++, right?

1584910598
shakesoda
mostly works fine

1584910601
Barabas
oh

1584910609
shakesoda
a lot of the standard library is junk anyways though

1584910617
Barabas
Yeah sure, I don't like any of it tbh

1584910641
Barabas
maybe a few things, like sort (and friends) is nice to have

1584910646
shakesoda
basic stuff (containers, strings) works totally fine

1584910681
Barabas
What does it do when the memory allocation fails when doing push_back or something?

1584910694
shakesoda
crash, like you're going to when that happens anyways lol

1584910713
Barabas
Depends

1584910717
shakesoda
i usually end up with my own after a while anyways, because of the amount of headaches c++ standard library causes in games anyway

1584910738
Barabas
hmhm

1584910749
shakesoda
least of which are "horrible compile times"

1584910766
shakesoda
and exceedingly bad debug performance

1584910774
Barabas
I like maps, and then you insert something and you have to do if (result.first.second) ...

1584910826
shakesoda
the standard hashmaps are convenient but not really that good

1584910910
shakesoda
I forget why, exactly, I think the problem is just that they are specified in a way that is impossible to implement in a

1584910933
Barabas
C++ is like quantum mechanics

1584910940
Barabas
if you think you've understood it you really didn't :P

1584911008
mq32
Barabas: we're discussion sequence points in a c++ channel right now

1584911020
mq32
solution: never ever do post- or preincrement operators

1584911075
Barabas50
urgh, my internet had a hickup

1584911083
andrewrk
TheLemonMan, here's my workaround for the polly thing:

1584911084
Barabas50
Oh... my name =/

1584911119
Barabas53
ok... whatever, I'm 53 now

1584911177
andrewrk
hmm the stack trace tests are quite brittle when start.zig is changed

1584911372
Barabas53
> solution: never ever do post- or preincrement operators

1584911377
Barabas53
Glad I don't =D

1584911396
Barabas53
+= 1 is my friend. Easier to read as well.

1584911400
mq32
i'm happy that andrew did not put them into zig

1584911402
mq32
Barabas53: true dat

1584911437
Barabas53
worst is function(argument, i++) (or ++i??) you never know what happens, or at least I don't.

1584911459
shakesoda
even when you do it's bad code

1584911472
ifreund
yeah I used to feel cool using them in, well, interesting ways.  Now i've grown up a little and realised that I could read my own code

1584911476
mikdusan
imagine naming a language successor after problematic syntax :)

1584911493
ifreund
s/could/couldn't/

1584911494
Barabas53
My favorite one is: while( i --> 0)

1584911498
shakesoda
imagine making a language successor that's vastly worse than what it succeeds?

1584911532
andrewrk
c++ ?

1584911534
Barabas53
And keeps all the horrible things for compatibility, but isn't actually compatible. (As in C code doesn't compile cleanly as C++ ^^)

1584911535
shakesoda
not to say there is nothing useful in c++, that isn't true

1584911546
shakesoda
but it is almost always way, way worse than C in so very many respects

1584911548
andrewrk
oh I'm late to the joke

1584911553
Barabas53
lol

1584911573
mikdusan
I think andrewrk  evaluated before incrementing

1584911583
Barabas53
I'm just very happy there's a sane language ;)

1584911714
shakesoda
once zig gets #1717, my wishlist becomes simply "faster compiles" (although I still think the looping syntax is bizarre, and there's a good few ways to end up with confusing types)

1584911743
Barabas53
You get used to it

1584911755
shakesoda
well, I can be used to it and still think it's bizarre

1584911760
Barabas53
=D

1584911762
mq32
hehe

1584911773
andrewrk
what's an example of ending up with a confusing type?

1584911773
Barabas53
Though the extra thing on the while is a bit strange

1584911814
shakesoda
constructs like while (cond) : (do some stuff) {} eternally feel weird even if I'm used to writing it, it is really self-inconsistent

1584911847
Barabas53
Yes that one is a bit hmm... not sure.

1584911862
Barabas53
But I do like that there's no for (i=0; i < N; i++) ^^

1584911893
Barabas53
because it's not different from i=0 while(i<N) { i+=1 }

1584911917
redj
trying to build llvm from git clone

1584911917
redj
are there any step by step instructions somewhere? I can't even get cmake to do it's thing right out of the box/clone. I get "does not appear to contain CMakeLists.txt" pointing to the root dir where there's no CMakeLists.txt

1584911924
Barabas53
And once you need a bit more than the standard you get into discussions about whether while or for is better and you have wasted another half an hour =P

1584911931
shakesoda
Barabas53: I'd like if my while didn't require leaking the loop counter out of the loop scope, where it's useless

1584911933
shakesoda
andrewrk: I had to enlist help here to figure out how on earth to type a .{ "thing", "other thing", null }, and earlier there was the ** -> [*]?[*] situation, which is really hard to come up with

1584911947
shakesoda
things of that nature

1584911968
shakesoda
I think, generally, that is less of a language issue than something the compiler could be more helpful with

1584911970
Barabas53
You can easily put an extra brace around the whole thing though, but I understand.

1584912057
shakesoda
Barabas53: needing to add another level to contain that is pretty obnoxious :(

1584912069
andrewrk
redj, yes:

1584912093
shakesoda
the way loops are is a nitpick though, it doesn't impede my getting anything done

1584912109
shakesoda
they just feel inconsistent, and it'd be nice to not have the counter scope issue to begin with.

1584912143
andrewrk
you're not alone with that feedback

1584912167
shakesoda
slices can also be pretty confusing, although I think that's a much better situation with making arrays behave more consistently

1584912182
shakesoda
there's a lot of situations where it's not obvious by writing it what you're going to end up with

1584912238
shakesoda
to an extent this is just needing to get used to it, but i always feel like i'm hoping for the correct magic to happen

1584912246
Barabas53
My main 'problem' with Zig is getting used to writing everything 'inline'. Especially with nested things that gets messy quickly. And on top of that the tests are in the same file...

1584912282
shakesoda
that said, I very much like that slices exist, they're nice

1584912287
Barabas53
Yes

1584912318
Barabas53
Better than adding a span class 40 years later xD

1584912365
Barabas53
They're one of the most basic things, so it's great they're build into the language imho

1584912369
shakesoda
I've described zig on several occasions as "like C that learned something from the last several decades"

1584912420
Barabas53
And I'm really excited about the recent array changes (just wish it didn't brake my code, hint hint

1584912502
Barabas53
Plus I'm very happy there aren't any constructors, destructors or private members which you can't get to

1584912556
shakesoda
yeah, not having hidden stuff happen behind your back is one of the things that pulled me in to begin with

1584912571
Barabas53
And the error handling is great

1584912738
Barabas53
The only thing I'm not sure about is extending existing 'classes'. If you need to add this one method, you can no longer use `thing.my_method()` but have to type `MyExtension.my_method(thing)`

1584912764
shakesoda
and you'll always know exactly where it is.

1584912774
shakesoda
this is a feature, heh

1584912816
TheLemonMan
pixelherodev, what compiler did you use to compile that binary?

1584912833
shakesoda
it's also not something I run into the way I design programs, so maybe I'm missing the point.

1584912902
Barabas53
It's mostly a problem when you use libraries. When it's all your code, you can just change it where you need to.

1584912939
Barabas53
I also don't run into it that quickly, but it's something I've been wondering about.

1584912941
shakesoda
the same statement applies though, I don't design things with the idea of extending classes

1584912984
shakesoda
(similarly, inheritance is banned in my c++ codebases, it is simply not how things are designed)

1584913043
fengb
Iâ€™ve found extension methods to be far more annoying than they are useful

1584913046
Barabas53
Well, I've had it happen a few times (twice?) that I wished there was some method on std.ArrayList which wasn't there.

1584913083
fengb
Yeah and imagine if every library decided that

1584913101
fengb
Now you have 2 dozen new methods on ArrayList that you donâ€™t know where it comes from

1584913110
shakesoda
i'm quite happy with just writing a regular function and calling do_the_thing(&list, ...)

1584913124
shakesoda
never any mysteries, dirt simple

1584913128
Barabas53
Sure

1584913136
shakesoda
simplicity is a virtue

1584913158
shakesoda
an idea which i think brings most people around here anyways, heh

1584913162
Barabas53
But then you want it to work for more than one type

1584913205
Barabas53
And just to be clear. I'm not saying it's abd to write a separate method.

1584913209
shakesoda
one should generally prefer concrete over abstract implementations for simplicity, but you can totally substitute in a var

1584913230
shakesoda
so, not too different

1584913398
shakesoda
it's a tangent, but interestingly, I've found that I use things like ArrayList quite a lot less in zig than I end up using vectors and the like in C++

1584913440
ifreund
what do you use instead? or are you just using fewer containers in general?

1584913442
shakesoda
it's been appropriate in more cases to just use slices and poke the allocator myself

1584913457
shakesoda
ifreund: yeah, fewer in general, as the basic tools are quite good

1584913484
Barabas53
Silly example:

1584913605
shakesoda
I feel like in that case there's not really much of a benefit in the struct wrapping

1584913680
shakesoda
it lets you call with your ., but you might as well just call ensureSize(list, size) by itself if you've got the function in scope

1584913732
Barabas53
Yes, but the one advantage the `list.method()` has is that it already knows the type

1584913787
Barabas53
while `ensureSize(list, size)` doesn't, so you have to do `ArrayListExtension(u32).ensureSize(list, size)` which is a bit longer than I'd like.

1584913836
Barabas53
I also have no suggestion how to make it better though :P

1584913889
Barabas53
In C++ I would use function overloading, but after you've done that three times you start to regret it as well ^^

1584913935
shakesoda
I was thinking just typing the list argument with var and letting it be loose, compiler will scream at you if it won't work

1584913959
Barabas53
Yeah might also work.

1584914044
shakesoda
i've got a few functions on hand that work that way, it's been fine and not overly verbose or anything either

1584914278
Barabas53
Yeah, well it's really my only complaint, so no biggy.

1584915072
pixelherodev
GCC 9.2-r4 I think

1584915246
ifreund
why do we need to label a block to break from it? Shouldn't a break without a label always function on the innermost block?

1584915303
mq32
ifreund: this would result in a lot of confusion

1584915318
mq32
while(some) { if(some.other) { break; } }

1584915332
mq32
your idea would mean that break is now breaking the if-block, not the while block

1584915415
ifreund
ok I see how that could cause some problems, (though arguable only because people are used to what break does in C)

1584915455
mq32
nah, break is fine as it is

1584915477
mq32
it's good to see what blocks can break by start

1584915485
mq32
and to have a separate syntax for value return

1584915692
ifreund
Does make simple cases like this a little more verbose than I'd like, though I can live with it

1584915745
mq32
i would not do that

1584915760
mq32
i bet that there's a hidden resource leak

1584915772
mq32
what do you intialize the other fields with?

1584915779
ifreund
hmm?

1584915796
mq32
is .renderer owning or not?

1584915807
mq32
and are other fields in your struct owning something?

1584915809
ifreund
the c lib allocates the memory

1584915827
mq32
so you don't have to call free() or clib_free() or whatever?

1584915840
ifreund
i do

1584915852
fengb
If 2nd statement fails, the 1st statement might be leaking

1584915863
ifreund
thanks fengb

1584915869
mq32
yep, that's what was my thought as well

1584915887
ifreund
yeah I think I'll restructure this a little

1584915892
mq32
also if

1584915900
mq32
just initialize the struct field-by-field

1584915906
fengb
Might be prudent to add errdefer, but it wonâ€™t work inside of a separate block :/

1584915942
ifreund
so maybe i should just make the struct undefined then init the fields one by one

1584915948
fengb
Sometimes I wish I could add a defer to the parent block

1584916003
mq32
my usual pattern looks like this:

1584916003
mq32


1584916103
ifreund
cool

1584916105
diltsman
How do you handle the type Error!?Token in a while loop?  It looks like the while loop unpacks the error but not the optional.

1584916228
mq32
while(try foo()) |opt| { }

1584916305
diltsman
I was hoping that while(foo())|tok|{}else|err|{} would work.

1584916332
mq32
you can also unpack the ?Token in the loop itself

1584916335
diltsman
Unfortunately, that unpacks the error but leaves the optional.

1584916339
diltsman
How do you do that?

1584916360
diltsman
Is there the equivalent of a C break?

1584916489
mq32
sure

1584916490
mq32
break;

1584916523
mq32
while(err_or_opt()) |opt| { if(opt) |val| { â€¦ } else { break; } } else |err| { â€¦ }

1584916547
diltsman
Cool.  Thanks.

1584920552
andrewrk
fengb, I wonder if `zig cc` is going to make it easy to get a wasm build of zig

1584920626
andrewrk
we need the libc++ stuff, but then we should be able to cross compile llvm/lld targeting wasm

1584920670
andrewrk
hmm. nah I think we'll still probably want emscripten for this use case

1584921186
ifreund
I've got to say, error handling in zig is pretty amazing

