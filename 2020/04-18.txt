1587168862
Snektron
clang also spits out code thats calls compilerrt functions

1587168885
Snektron
Im not sure whether its as aggressive as gcc though

1587168890
Snektron
I think its kind of a weird system

1587168917
Snektron
(zig also has its own implementation of many eabi compilerrt functions)

1587169497
GreaseMonkey
ok, at this point i'm actually quite glad that zig can handle circular imports

1587169729
Xavi92
:)

1587171309
Kingsquee
wait, why are multiple return values a thing if we have tuples

1587171335
Kingsquee
or are they not a thing and I'm reading old threads

1587171395
Xavi92


1587171433
Xavi92
Kingsquee: don't really get it either. But that might be to my current lack of expertise with the language

1587171579
karrick
Pardon my ignorance, but what does `def bar: Bar = .A;` mean in the above linked GitHub comment?

1587171597
karrick
The `.A` is what I don't know in Zig parlance yet.

1587171608
karrick
(maybe the enum)

1587171649
karrick
oh duh

1587171664
karrick
yeah: the type is `Bar` and the value is Bar's `A`.

1587171681
Xavi92
karrick: is one of the fields from the enum. If I'm not mistaken, the `.` must precede so it can be inferred, I guess

1587171693
karrick
yeah makes sense. thx

1587171719
karrick
Is there a reason to put colons in `var` and `def` statements at all?

1587171734
karrick
`def bar Bar = .A;` vs `def bar: Bar = .A;`?

1587171759
karrick
same with `var foo Foo = undefined;` vs `var foo: Foo = undefined;`

1587171795
karrick
I suppose I might be treading on thin ice, because I don't have as much experience in Zig as any of you.

1587171812
Xavi92
karrick: the example has not been compiled since it relies on syntax that has not been accepted (or even reviewed) yet, but currently Zig uses 'const/var name: type = value;'

1587171814
Kingsquee
don't sell yourself too short

1587171822
Xavi92
karrick: np :)

1587171830
Kingsquee
@Xavi92: def wouldn't replace const everywhere, with pointers etc

1587171847
Xavi92
Kingsquee: why not?

1587171854
karrick
I never understood the purpose of having that colon in the var statements. Figured it was a parser issue.

1587171861
Kingsquee
*def i32

1587171871
Kingsquee
not very clear

1587171872
Xavi92
Kingsquee: that wouldn't be needed at all. Why not just *i32?

1587171880
Kingsquee
yes, that's my point

1587171892
Xavi92
*i32 = status quo *const i32

1587171908
Kingsquee
unless I missed something, you might want to edit your post to clarify you're not just proposing 'def == const'

1587171927
Xavi92
Kingsquee: "This requires const to disappear so *Foo and []Foo are immutable by default. Otherwise, it makes it inconsistent to have const for declarations but not for forcing const-safety, so it just can't be used. "

1587171937
Xavi92
I think that statement made that clear. Or at least I hope so

1587171940
Kingsquee
ah, I missed something

1587171960
karrick
Having qualified my opinions as meaningless in this arena, I do agree with Xavi92's statement about that code block example being very readable.

1587172011
Xavi92
Kingsquee: Please do not hesitate to ask any other details. I would like the explanation to be as understandable as possible

1587172024
Xavi92
karrick: thanks for the kind words. :)

1587172077
Xavi92
karrick: the whole Zig community has been on a heated discussion about this for a couple of days now, but I think the `def` approach is what makes most sense now, after reading all of the other approaches

1587172081
Kingsquee
I personally kind of like the idea of 'a <- 4' if a is var, since that gives a really nice readability of "this thing is being changed and not defined", but in the current situation I think your proposal is, in positive vibes that utf8 cannot express, most-tolerable

1587172151
karrick
Kingsquee: I have thought of that idea as well. However, we have a problem in that we have a history of C like expressiveness to mutate variables, and we are trying to make immutability the default for declarations. So I kept my mouth shut.

1587172162
Xavi92
Kingsquee: `a <- 4` is introducing a new operator to the language, which I'm not a fond of, as stated on my proposal. Also, people coming from C, C++ or Rust would find that strange at first glance

1587172174
Kingsquee
I'm from all of those so Â¯\_(ãƒ„)_/Â¯

1587172219
Kingsquee
the only reason I can see it's impractical is destructuring

1587172222
Xavi92
Kingsquee: then think of reducing the number of operators on Zig to a minimum

1587172260
Kingsquee
it's really not though, as what we currently have could be considered an overloaded operator

1587172265
Kingsquee
it's just one we've gotten really used to

1587172279
Xavi92
Kingsquee: as I stated on the proposal, destructuring should be really put into question if it's causing troubles in language design

1587172308
Kingsquee
anything that helps me see exactly where the moving parts are is nice

1587172312
Xavi92
Kingsquee: can't see it as a priority. There are many other ways to return multiple values from a function

1587172341
karrick
After finishing reading Xavi92 's suggestion, it seems to bring together the best ideas from different people.

1587172342
Xavi92
Kingsquee: be it returning a tuple, a struct or using a mutable pointer

1587172358
Xavi92
Thanks again, karrick :)

1587172397
Kingsquee
that said, there's really no ambiguity when the only time '=' could mean assignment is when the variable name is prefixed by 'def'

1587172403
Kingsquee
so it works out

1587172403
karrick
Xavi92: would you mind editing your example to include how one would define struct methods

1587172499
Xavi92
karrick: sure, 1 sec

1587172895
Xavi92
karrick: done ->

1587172969
karrick
oh... TIL enums can have methods

1587173025
Xavi92
karrick: well, didn't try to write methods on enums actually, so that might be plain wrong

1587173036
Xavi92
karrick: but I hope everyone gets the idea behind, after all

1587173061
fengb
they can have methods yes

1587173067
karrick
I am not trying to a smart ass. I honestly don't know well enough whether it was possible.

1587173079
karrick
thanks fengb

1587173169
Xavi92
fengb: phew, then I got that right by luck :P

1587173235
Xavi92
fengb: did you read my comments on the proposal (link above), BTW?

1587173259
fengb
Yeah, I donâ€™t really see how def is better than const

1587173284
Xavi92
fengb: "This requires const to disappear so *Foo and []Foo are immutable by default. Otherwise, it makes it inconsistent to have const for declarations but not for forcing const-safety, so it just can't be used."

1587173300
karrick
I like `def` because it implies `define`. Define this symbol to always mean thus and such.

1587173317
fengb
Not sure hijacking a proposal for something tangentially related is that great either

1587173368
Xavi92
fengb: removing `const` and providing sigils instead does not sound like a better idea either

1587173402
fengb
Iâ€™m in favor of status quo

1587173409
Xavi92
karrick: actually I don't really care that much about which keyword ends up being used. It's just `const` cannot be used for some things but not for others, so it's better to remove it

1587173422
Xavi92
fengb: status quo favors default mutability

1587173432
karrick
`const` never bothered me either

1587173437
fengb
Again this isnâ€™t the issue for that

1587173486
Xavi92
karrick: default mutability is already an issue in C and C++, specially since we programmers are lazy and prefer fewer keystrokes over const-correctness

1587173502
karrick
fengb: is your concern the fact that in the "drop const keyword" some discussion suggested using `def` rather than `const`?

1587173564
fengb
Nah itâ€™s just switching const to def doesnâ€™t feel like it solves andrewrkâ€™s problems, and getting rid of const is shoving all the changes at the same time

1587173568
Xavi92
fengb: I think Andrew also made clear he would make default immutability a thing, so I don't see how `const` fits on the language once that is implemented

1587173630
fengb
I also donâ€™t have that much weight. I just talk a lot >_>

1587173631
Xavi92
fengb: getting rid of const is introducing new operators to the language, which IMHO translates directly to worse readability

1587173686
Xavi92
Operators should be kept at a minimum. We prefer reading words than sigils, that's a fact

1587173871
Xavi92
fengb: as I said on the comments, "Removing the const qualifier and making declarations solely depend on the operator will surely look confusing to newcomers, at least those coming C, C++, Rust or similar languages, which I think are the principal target for Zig."

1587174305
Xavi92
Anyway, bed time. See ya!

1587174323
karrick
ðŸ‘‹

1587179149
GreaseMonkey
"error: compiler bug: integer and float literals in var args function must be casted." oh that is wonderfully honest

1587179155
GreaseMonkey
even if i am aware that varargs are gone in trunk

1587179190
fengb
One of the many reasons varargs was removed :P

1587183450
oats
re: the 'const' thread bikeshedding:

1587183459
oats
I really do not like this example in particular

1587183461
oats
a +=, b :=, var c :=, d = someFn();

1587183479
oats
I really hope the language doesn't end up encouraging/allowing this :P

1587185141
foobles
oats I was the one who proposed that

1587185143
foobles
and I totally agree

1587185147
foobles
that was a bad call :p

1587185160
foobles
mixing assignment / declaration on one like, imo, is awful

1587185523
oats
haha, I appreciate your coming forward :)

1587185572
oats
definitely good to get all the bikeshedding out of the way now instead of in 3 years once the nuclear power plant is built and everyone is riding their bikes to work

1587185601
mikdusan
uniform mutability and (decl or assign) for lhs: This is the WayÂ®

1587185643
oats
as in two forms only?

1587185657
oats
some kind of 'const (a, b) = someFn();'

1587185666
oats
or 'var (a, b) = someFn();'

1587185724
mikdusan
except I don't think we need parens

1587185736
oats
sure

1587185744
oats
not the part I was focusing on though :)

1587185781
foobles
I wouldn't care about parens

1587185801
foobles
but it makes it clear that the const/def/var is distributing over all of them

1587185854
oats
const {a, b} = someFn();

1587185861
oats
whatever :P

1587185902
mikdusan
and last 4 lines of this is what it would look like with `:=` for decls. I added a parens for mixed lhs.. pretty much would match what fn params parens would be. it's a receiver:

1587185904
mikdusan


1587185936
oats
I don't mind := for decls in Go

1587185949
oats
but there is the trouble of shadowing other vars

1587185974
mikdusan
I don't think zig shadowing rules change here

1587186125
foobles
yeah

1587186133
foobles
oats I think shadowing would just be disallowed

1587186155
foobles
if you want to "shadow", just make a new variable, and then assign on the next line

1587186173
foobles
mikdusan I like this

1587186175
darithorn
i think he's talking about when using := with tuples

1587186185
darithorn
newVar, alreadyDefinedVar := someFn();

1587186199
foobles
yeah

1587186212
foobles
what i am saying is do this:

1587186245
foobles
`new_var, replacement_for_other_var := someFn();    other_var = replacement_for_other_var;`

1587186267
darithorn
it happens a lot in Go with the idiomatic way of error handling

1587186342
foobles
yeah, but zig has better error handling

1587186355
foobles
so I dont think this would be nearly as necessary as go

1587186357
foobles
*as in go

1587186360
darithorn
very true

1587186544
mikdusan
I consider the tuple lineup as sugar and semantically equiv to having the tuple reference, and then `const a = tuple[0]; const b = tuple[1]; // equiv to `const a,b = tuple;`

1587186624
mikdusan
and the normal name-collision and shadowing prevents Go shadowing footgun

1587188644
GreaseMonkey
i've now got a working deflate+gzip unpacker but the code's a bit of a mess

1587188684
GreaseMonkey
and, well, for some definition of "unpacker" - there's a struct you can call read against but i'm not feeding the results into an actual file, plus the CRC isn't being calculated for the gzip stuff

1587188723
GreaseMonkey
having said that, the port of Mark Adler's puff.c mentioned in the issue tracker should be fast enough if you believe the statistics in the file itself being about 1/4 of the speed of zlib (which is

1587190556
foobles
how is `~|CONST!#(x)|~ y;` as a replacement for `const x = y;`?

1587191349
GreaseMonkey
ok, turns out my deflate implementation is using 460KB resident according to top

1587191373
GreaseMonkey
had to check it for leaks

1587191426
GreaseMonkey
attempting to decompress a ~512MB tarball does result in, uhh, let's say it isn't fast enough to handle that nicely

1587191474
GreaseMonkey
-Drelease-fast maybe doubles the speed so i should probably buffer it better

1587192460
pixelherodev
Profile!

1587192465
pixelherodev
Callgrind, perf, etc!

1587193145
StateOff
Hi everyone. Trying the newest zig release again for Ludum Dare (gamejam). I am a little stuck and would appreciate any help.

1587193162
StateOff
I wonder why I get a "cannot assign to constant" with something like this:

1587193221
GreaseMonkey
wait, ludum dare's on right now?

1587193232
StateOff
Yes :D Theme is "Keep it alive"

1587193282
GreaseMonkey
anyway, change "valye" to "value" before that bites you later... and after that, you need self to be a pointer to Data, otherwise it ends up constant

1587193297
GreaseMonkey
so: pub fn append(self: *Data, value: u8) !void { ... }

1587193320
StateOff
Thank, sorry - this is a fake sample, also not handling the error yet when calling append.

1587193341
GreaseMonkey
ah in that case: `try data.append(2);`

1587193386
StateOff
Next time I will use godbolt. Forgot that it supports zig

1587193452
StateOff
Ok so I am wondering about this error:

1587193511
StateOff
I was expecting this works since data is 'var'

1587194127
StateOff
I think I found my answer here

1587194134
StateOff


1587194175
StateOff
So it needs to actually be a pub fn append(self: *Data, value: u8) !void { ... if it is supposed to be mutable (not self: Data).

1587194224
StateOff
Thanks for listening. Curious to see if there will be more zig entries to LD. Good night everyone.

1587200170
GreaseMonkey
alright, 546300976 bytes compressed, 1635216384 uncompressed. (exact file i'm testing for benchmarks is FreedomStudio-2019-08-2-lin64.tar.gz.) here's the metrics from time

1587200193
GreaseMonkey
-Drelease-safe takes 50.879s real / 49.617s user / 0.797s sys.

1587200259
GreaseMonkey
-Drelease-fast takes 41.643s real / 40.546s user / 0.721s sys.

1587200292
GreaseMonkey
it does not write to disk at this point, but it does read from disk (although there's a chance it's all in cache right now)

1587200348
GreaseMonkey
also, 116KB resident lol... and that's with a 100KB block buffer

1587200351
pixelherodev
How's that compare to standard tools?

1587200364
pixelherodev
In terms of compression/decompression speed

1587200387
GreaseMonkey
oh right the resident value is kinda moot for zig as it doesn't factor in stack usage much i think

1587200393
pixelherodev
(I'd measure locally, but it wouldn't be a valid commparison)

1587200397
pixelherodev
s/mm/m

1587200397
GreaseMonkey
for standard tools? yeah i'll check that

1587200440
GreaseMonkey
gunzip into /dev/null: real 8.989s / user 8.770s / sys 0.157s

1587200562
GreaseMonkey
long story short, it's Fast Enoughâ„¢. there's still room for improvement though

1587200578
GreaseMonkey
also, 906 lines across 8 files

1587200591
GreaseMonkey
but not particularly well commented... OTOH, there's a blatant copypaste

1587200800
Xavi92
Hi there :)

1587200826
pixelherodev
How long does yours take for just decompress?

1587200940
GreaseMonkey
i don't have compress at this stage

1587201033
GreaseMonkey
i will say though, if we're making packages the size of a heavily customised Eclipse w/ all the embedded toolkit stuff bundled (typically GCC, GDB and the whatever-Link tools), then something is probably wrong

1587201040
GreaseMonkey
at this stage anyway

1587201103
ifreund
i think any working implementation is a step up over none

1587201112
pixelherodev
for sure

1587201118
ifreund
speed can certainly be improved in the future

1587201124
pixelherodev
I was simply curious

1587201129
ifreund
yeah me too

1587201139
pixelherodev
Speaking of improving performance

1587201146
pixelherodev
I've committed unholy devilry :)

1587201147
pixelherodev
`mmap`

1587201182
pixelherodev
Mapped virtual memory directly to physical memory (w/ an offset for some of it since the zero page is off limits :( )

1587201197
pixelherodev
Have a few restructures to boost performance as well

1587201206
pixelherodev
and the urge to hit myself for wasting time on this when it already runs in <5ms

1587201374
pixelherodev
Yay, ~15% faster now! That was totally worth the effort. Not.

1587201397
GreaseMonkey
i used mmap for some C code which i wrote to stabilise the Perfect Dark Attack Ship Agent 2:06 WR video, it was

1587201409
GreaseMonkey
mmap is a sorely underrated facility

1587201551
pixelherodev
On the bright side, the performance hit of being unable to use the zero page is only ~2.5%

1587201591
pixelherodev
(based on enabling access temporarily and measuring instruction count via callgrind)

1587201643
pixelherodev
Actually, that's completely inaccurate, and I have no way of measuring it; the stdlib fails because the returned pointer is null

1587201669
pixelherodev
The `mmap` syscall is returning a null pointer, Zig is trying to store it to a non-allowzero pointer

1587201701
pixelherodev
I was really measuring cost of running vs cost of print a stack trace, which is a completely useless metric

1587201709
pixelherodev
(stack trace w/o debug info)

1587203394
daurnimator
GreaseMonkey: is your deflate implementation uploaded anywhere?

1587204240
GreaseMonkey
daurnimator: currently not, i can sort that uhh

1587204266
GreaseMonkey
oh right, MIT licence, yeah let's do that

1587204632
GreaseMonkey


1587204699
GreaseMonkey
also i personally prefer snake case over camel case any day of the week, but it does seem that the standard library uses camel case

1587204720
GreaseMonkey
nevertheless, there are a few places where snake case has slipped in

1587204934
GreaseMonkey
...should've clarified it's for 0.5.0

1587205115
GreaseMonkey
although the 0.6.0 linux binary from the site Just Worksâ„¢ so i might go and port it to that

1587205455
ifreund
GreaseMonkey: I used to be a snake_case everywhere man myself, but I've grown to quite like the conventions of snake_case for variables, camelCase for functions, TitleCast for types, etc. that zig uses

1587205462
ifreund
makes code more readable imo

1587205472
GreaseMonkey
i've seen camel case be the cause of bugs

1587205487
GreaseMonkey
and is it GZipReader or GzipReader?

1587205493
GreaseMonkey
stuff like that

1587205521
ifreund
i feel like if they both exist that's a problem

1587206097
TheLemonMan
pixelherodev, you forgot to update the stack-trace tests too

1587206193
ikskuh
GreaseMonkey, definitly gzipReader ;)

1587206194
ikskuh


1587206219
ikskuh
or Gzip when we go for

1587206219
ikskuh
:D

1587206240
pixelherodev
The important question is

1587206246
pixelherodev
Is it gee-zip, or guh-zip?

1587206268
GreaseMonkey
we've clearly learnt it's jzee-zip

1587206278
pixelherodev
Gazip

1587206286
GreaseMonkey
not djee-zip, but jzee-zip

1587206350
GreaseMonkey
also found a dumb mistake where i was still using the slow way to read bits in one case

1587206362
ikskuh
ge-tsipp

1587206635
Xavi92
GreaseMonkey: you definitely made a quick progress on Zig, didn't you? :)

1587206684
GreaseMonkey
Xavi92: yeah, this is day 3, although i have had prior exposure to implementing a deflate decompressor

1587206880
Xavi92
GreaseMonkey: still a significant progress though :)

1587207011
TheLemonMan
GreaseMonkey, what's wrong with BitInStream ?

1587207035
TheLemonMan
I see you wrote your own InputBitStream

1587207044
GreaseMonkey
TheLemonMan: i didn't know BitInStream existed

1587207260
daurnimator
shouldn't it be called `Gzip.Inflate`? :)

1587207270
GreaseMonkey
quite possibly

1587207276
daurnimator
GreaseMonkey: see also crc in the standard library

1587208172
Xavi92
I'm writing an experimental branch of zig (

1587208222
daurnimator
am I weird for preferring const because it starts on the left hand side of the keyboard

1587208246
Xavi92
daurnimator: so does `let`, doesn't it?

1587208248
TheLemonMan
65 comments in two days, nice

1587208255
daurnimator
Xavi92: nope?

1587208262
ifreund
a little, but I agree that const is very pleasant to type :D

1587208294
ikskuh
Xavi92: you got a comment :)

1587208299
Xavi92
Please see changes on

1587208337
Xavi92
daurnimator: it depends on the keyboard layout I guess. On QWERTY, `def` are three keys that are very close between them

1587208348
daurnimator
'def' => all on the left hand; annoying. 'let' => starts on the right hard, doesn't feel right. 'const' => starts on the left and has nice see-saw from left-right-left

1587208373
Xavi92
daurnimator: I don't see that as a convincing argument nonetheless

1587208389
daurnimator
yeah its probably just a me thing

1587208407
Xavi92
ifreund: whereas I like `const` too, I already explained why it doesn't fit if default immutability is achieved

1587208424
ikskuh
daurnimator, Xavi92: I wrote some stupid stuff about the typeability of `let` vs `const` vs others in the `let` issue :D

1587208469
ifreund
Xavi92: i've honestly had my fill of bikeshedding for a bit

1587208489
ikskuh
Xavi92: i think for declarations, there should be no "default", the coder should always chose

1587208497
GreaseMonkey
daurnimator: stdlib CRC is nice and fast, thanks for the suggestion, commiting and pushing now

1587208498
ikskuh
but pointers should be immutable by default

1587208558
GreaseMonkey
i do also believe in "immutable by default", it's safer

1587208572
Xavi92
ikskuh: I agree. Default declarations seem to force new operators

1587208619
GreaseMonkey
...hmm, actually, yeah, requiring one to say "this is mutable" or "this is immutable" but not leaving it ambiguous does kinda appeal

1587208647
GreaseMonkey
OTOH there is also the extreme of "what if we made sure everything was explicit", which is... well, has anyone here ever tried Vulkan?

1587208660
Xavi92
GreaseMonkey: any modern systems language such as Zig should be safe-by-design, rather than what C already does

1587208668
Xavi92
GreaseMonkey: so I agree completely with default immutability

1587208694
Xavi92
GreaseMonkey: I already proposed that on #5056 but soon got rejected by andrewrk

1587208720
Xavi92
GreaseMonkey: in fact I prefer default immutability (which I pointed out clearly on #5056), nonetheless

1587208770
Xavi92
BTW,

1587208823
Xavi92
Still, new function declaration syntax is not implemented `def foo = fn() void {}`, but I intend to add this feature on that fork too

1587208858
Xavi92
Again, if anyone contributes to that branch, I'll be very glad

1587208899
sanaris
something is wrong with the linker on *buntu systems?

1587208982
GreaseMonkey
i'll be heading to bed before tomorrow happens, gnight everyone

1587209002
sanaris
Or is it me not giving to cmake all proper variables?

1587209129
sanaris
I can see that cmake script is looking into gcc even after I expressed directly to only use Clang-10 includes

1587210336
Cadey
i think this might be a zig bug:

1587212396
FireFox317
TheLemonMan, what are you using the Once object for? Just curious where it can be applied

1587212565
mikdusan
anything lazy. singleton patterns.

1587213111
FireFox317
I see, nice

1587216916
TheLemonMan
FireFox317, yeah I needed it to create singletons without having to worry about data races

1587216986
TheLemonMan
it's also useful for shared libraries when you cannot run your own init code

1587218682
daurnimator
TheLemonMan: "unless the test block in once.zig is analyzed." => like with meta.refAllDecls?

1587222280
TheLemonMan
daurnimator, that shouldn't reference the tests blocks

1587223113
karrick
I have been anxiously following the Async work in Zig for some time, wondering how Zig will handle concurrency without a scheduler. I read the section in the 0.6.0 release notes regarding the efforts, and have to comment, because I noticed something when designing concurrent algorithms in Go using atomic primitives.

1587223163
karrick
I realize the above link is about Go concurrency, but the bottom line is algorithms need to be able to signal when they are runnable or not.

1587223654
karrick
I was watching andrewrk do a live coding demo with async work a number of months ago, and I got the impression that at syscall boundaries for slow calls, Zig compiler was introducing some modicum of logic to detect whether new threads were threads were runnable.

1587223687
ikskuh
karrick: zig async doesn't require threading

1587223702
karrick
There must be a way for threads to communicate to the scheduler, in the OS since Zig does not schedule threads, whether that thread is eligible.

1587223726
ikskuh
karrick: yes, there are syscalls to query FDs on their readyness

1587223733
ikskuh
it uses a scheduler that is implemented somewhere in zig std

1587223747
ikskuh
look at the man page for poll or epoll

1587223755
karrick
That must be where I saw andrewrk working on in his demo

1587223894
ikskuh
the magic that makes zig async usable is here:

1587223935
ikskuh
the event loop used there is defined here:

1587223976
ikskuh
please note that zig async works completly different compared to go for example

1587223995
ikskuh
go uses user-space threads with a custom scheduler whereas zig uses more of a continuation style

1587224009
ikskuh
where you can suspend routines into a "frame"

1587225345
karrick
ikskuh: thanks for the links. I know it works completely differently, because it eschews a runtime and scheduler, and have been wondering how it will accomplish proper concurrency without a scheduler. Accordingly, some feedback method needs to be provided that allows a thread of execution, or not thread, to say when something makes sense to run. Sort of like condition variables. "I'm going to sleep. Wake me up when..."

1587225375
ikskuh
zig async

1587225379
ikskuh
but not a thread scheduler

1587225416
ikskuh
when a function awaits something, it suspends and returns to the caller

1587225417
karrick
Okay, then it's making sense. I suppose Zig is designed to also run without an OS.

1587225425
ikskuh
yes

1587225437
ikskuh
suspending means: storing its state in a frame somewhere and you can resume that frame later

1587225438
ifreund
yep, and also to give you absolute control if you want it

1587225444
ikskuh
^= this

1587225448
karrick
So Zig cannot defer to the OS to make those scheduling decisions.

1587225453
ifreund
sure

1587225472
ifreund
i'm fairly certain you can implement thread-based async in zig

1587225493
ikskuh
zig async is actually multithreaded by-default

1587225504
ikskuh
but you can utilize each thread for more than one async task at a time

1587225533
ifreund
what i mean is that you could implement whatever go is doing in zig theoretically

1587225549
ikskuh
not sure

1587225561
ikskuh
but probably yes, you can implement coroutines in zig

1587225565
ikskuh
but needs some assembler

1587225569
karrick
I need to do some reading about how the event loop is evolving...

1587226158
fengb
Async isnâ€™t scheduled. The event loop is scheduled of sorts but the async stuff is actually synchronous under the hood

1587226244
fengb
e.g. resume â€œfreezesâ€ current execution and hands back control to the previously suspended frame

1587226493
Xavi92
karrick: posted a reply to your comment ->

1587226569
fengb
For event IO, itâ€™s similar to how nodejs does it. Any IO tosses the suspended frame to the event loop manager, and schedules a callback with the native OS kqueue/epoll/uring to wake it back up

1587226597
karrick
^ that summary is much appreciated

1587226600
fengb
And Iâ€™d imagine the event loop is pretty dumb and just runs whatever is woken back up

1587226621
ikskuh
Xavi92: "def cmd_a = CmdHandler {" definitly a bad idea

1587226628
karrick
kind of like condition variables might

1587226629
fengb
But... you donâ€™t need the builtin loop to use language async. Itâ€™ll just be a bit more raw

1587226638
ikskuh
has a really low readability, hides several declarations

1587227292
fengb
karrick: just to be a pain, you can have comptime var that stores structs and/or functions

1587227305
fengb
I donâ€™t know why youâ€™d do that but itâ€™s possible

1587227378
karrick
I was pondering that possibility and could come up with no practical reason to support it. Unless you wanted to be able to support functions modifying themselves, like in Lisp.

1587227424
ikskuh
well, in zig functions and function pointers are synonymous

1587227435
ikskuh
so having a function pointer is also just "var x : fn()void"

1587227495
karrick
I expected as much. But when you bind a function declaration to a symbol, do you expect to rebind it later? Sometimes yes. Event loops and higher order functions use that all the time.

1587227503
fengb
In comptime yes you can do self modification

1587227519
ikskuh
fengb: with #1717 you can do that for all functions

1587227524
karrick
But when bound at the top level, usually you are making a constant declaration, and do not intend on rebinding a function name to a different function body later.

1587227559
ikskuh
var foo = fn() void { std.debug.warn("I'm goneâ€¦\n", .{}); foo = fn() void { std.debug.warn("this is you future now\n", .{}); }; };

1587227562
fengb
Zig used to have your syntax idea. It was changed and you can probably find the old issue

1587227584
karrick
There is a difference between re-binding a pointer to a function pre-compiled function body, and building new functions at run time.

1587227584
ikskuh
we need zig fmt for the irc chan

1587227606
ikskuh
karrick: true. zig will never have the second one except you thunk that

1587227616
fengb
I prefer const foo = since you can easily grep for a declaration

1587227619
karrick
ikskuh: that example makes sense

1587227642
fengb
@ikskuh: Oh thatâ€™d make sense in a body yes

1587227648
ikskuh
fengb: yeah, that is my argumentation as well. you can grep pretty easily

1587227664
ikskuh
fengb: it would also make sense on top-level to do stuff like "init on first call"

1587227673
ikskuh
and you can just call "init_once()" all the time

1587227682
ikskuh
and after the first call, it will just be a ret

1587227696
karrick
fengb: I agree. And while when I first started to read Zig code thought it bizarre to see `const` keyword preface struct declarations, I find it really easy to read.

1587227738
karrick
I have done exactly that in some Go and JavaScript code, ikskuh ...

1587227758
karrick
I have had multi-stage inits for some things... hold on. ugly example link coming up

1587227791
fengb
Change is hard. I also wanted C style declarations a year ago

1587227825
karrick
Here is what I might call a proof of concept of that example. Not easy to read code. And it's actually the least performant version of this algorithm:

1587227831
ikskuh
fengb: yeah, true. but i don't think the stuff proposed in "the issue" is worth the change

1587227862
fengb
I have no idea whatâ€™s going on there. We apparently decided itâ€™s a dumping ground for all the changes

1587227865
karrick
That silly code modified a field member pointing to a function 3 times.

1587227879
fengb
And most of them donâ€™t solve andrewrkâ€™s issues in the first post

1587227924
ikskuh
fengb, yeah, true

1587228072
mikdusan
heh #5076 (drop const keyword) is now tied for zig all-time most comments in issues; tied with #544 (hard tabs)

1587228117
karrick
It's a complex topic being discussed, with different scenarios being considered.

1587228120
ikskuh
i'm still happy that there are a lot of people who think "status quo + #1717" is totally okay

1587228124
ifreund
the 2 tallest bikeskyscrapers in zig history

1587228192
fengb
I donâ€™t disagree that itâ€™s complex, but weâ€™re also shoving in random stuff thatâ€™s pretty irrelevant

1587228193
BaroqueLarouche
const main = fn will be weird at first, but more consistent with the idea that (almost) everything is an expression

1587228244
ifreund
Yeah i'm totally happy with the status quo optinon personally, but also rather tired of the discussion

1587228271
companion_cube
this is why you need a dictator, like andrewrk :)

1587228286
karrick
agreed

1587228295
ifreund
exactly, i just want andrew to lay down the law

1587228312
BaroqueLarouche
Judge Dredd Andrew

1587228326
fengb
I expressed my viewpoints already so I donâ€™t have much to add. Whatever decision he makes, Iâ€™ll be happy itâ€™s done lol

1587228330
karrick
Maybe I'm wrong, but while it is a proposal to do X, and whose intention is to solicit discussion on the PROS and CONS of X, does that not allow for Y and Z to be discussed, if they are related to X?

1587228385
fengb
I donâ€™t think itâ€™s disallowed per se, but I also donâ€™t see most of the posts addressing anything close to the original point

1587228392
karrick
I am completely cool with benevolent dictator / enlightened monarch approach as well. But it sounds like andrewrk is asking for different ideas so he can make an informed decision from the community of users.

1587228433
karrick
in the end, I'm still a fan of Zig and wish I could carve out more time to learn and use it

1587228435
fengb
andrewrk wants to drop const to make it easier to assign stuff. That part has been missing in half the discussions

1587228469
karrick
I put forth one suggestion to do that:

1587228494
ikskuh
karrick: zig once had such a syntax

1587228512
ikskuh
it was dropped in favour of more flexibility and more consistent declaration syntax

1587228524
karrick
âœ…

1587228526
ikskuh
how do you declare an anonymous struct with that? ;)

1587228535
ikskuh
you know that you can do that:

1587228542
fengb
andrewrk amended the proposal to include all const declarations, including inside functions

1587228542
ikskuh
var foo : struct { i : i32 } = .{ .i = 10 };

1587228543
ikskuh
?

1587228553
fengb
And then the flood doors opened to make all the syntax changes

1587228582
karrick
I don't have any good reasons to oppose whatever is decided upon.

1587228602
fengb
I donâ€™t see most of the discussions close to solving his problems though

1587228619
karrick
Have you had any thoughts about how to resolve his concerns?

1587228663
fengb
Not really. SpexGuy had a good summary that I mostly agreed with. And the ones in consideration donâ€™t have the problems I initially feared

1587228705
fengb
So... Iâ€™m just here bikeshedding about bikeshedding and hoping this gets resolved before we destroy ourselves >_>

1587228708
karrick
I actually don't think there is any solution that will make everyone happy, because we are jamming immutable and mutable language together.

1587228724
fengb
I donâ€™t even know why that topic came up

1587228730
karrick
why what topic?

1587228735
fengb
Nowhere is a part of the original proposal

1587228739
karrick
what

1587228746
fengb
Default immutability

1587228763
ikskuh
karrick, zig is never gonna be a immutable language

1587228782
karrick
I'm not saying it would or should be

1587228784
fengb
That wasnâ€™t the intent of the original proposal

1587228805
karrick
yeah, I just rescanned the proposal and did not see it there.

1587228819
fengb
And while I like default immutability, Iâ€™m really annoyed that itâ€™s all weâ€™re talking about here

1587228826
ifreund
^

1587228834
mikdusan
my take on this; the uniform-multi-assign is pretty much agnostic to { const, `=`, `:=` } possibilities. and the `=` option has the consequence of a new keyword like `set` or `reset` for assign

1587228856
companion_cube
zig secretly becomes tcl

1587228857
ifreund
after reading SpexGuy's comments I don't think there's much more to say

1587228915
ikskuh
mikdusan: why do we need destructuring in the first place?

1587228940
karrick
Isn't dropping `const` imply a "default immutable" stance, however?

1587228948
companion_cube
to use tuples as multiple return ikskuh

1587228956
companion_cube
{x,y} = f()

1587228959
karrick
Right now the mutability or immutability is pretty explicit: `var` or `const`.

1587228961
ikskuh
companion_cube: i know that this is the use of this

1587228964
ikskuh
but why do we need this?

1587228965
mikdusan
ikskuh: i believe it's an accepted proposal #498

1587228969
companion_cube
ah, idk

1587228983
companion_cube
although it is indeed convenient to return multiple values somehow

1587228987
ikskuh
mikdusan: damn :D

1587228999
companion_cube
instead of C's ugly "return one value and modify argument pointers for the other return values"

1587229000
ikskuh
C++ got destructuring as well

1587229004
ikskuh
and it's horror

1587229019
ikskuh
companion_cube: we have anonymous structs

1587229023
foobles
`auto[x, y] = foo();` :)

1587229030
companion_cube
ikskuh: but without destructuring it's annoying

1587229039
ikskuh
nah, because your returns are named

1587229044
ikskuh
readability++

1587229047
mikdusan
> "C++ got destructuring as well and it's horror" --> "C++ it's horror" ; there I simplified it.

1587229050
ikskuh
foobles: that works for a LOT of stuff. like â€¦ arrays, structs, tuple, â€¦

1587229068
fengb
JS has destructuring and I find it far more abused than useful

1587229078
ikskuh
mikdusan: we try to cramp even more features into destructuring than c++ or c#

1587229089
ikskuh
like, reassigning values mixed with declarations and so on

1587229106
ikskuh
this screams for abuse

1587229117
ikskuh
it's easier to type

1587229121
companion_cube
go also does that a bit with their `x, err := â€¦` right?

1587229123
ikskuh
but definitly not easier to maintain

1587229130
mikdusan
i guess my point is this: by making destructuring uniform (ie: no mixing), it's not going to matter which way const goes

1587229155
foobles
I think destructuring should only be allowed for declarations

1587229162
companion_cube
yeah I don't see why one would reassign in a destructuring either

1587229168
companion_cube
it'sâ€¦ unheard of :p

1587229172
ikskuh
foobles: +1

1587229191
ikskuh
and then we can just use "const { a, b } = foo();"

1587229196
ikskuh
which is at least semi-readable

1587229211
companion_cube
`let {a, mut b} = foo();`

1587229214
companion_cube
oops :-Â°

1587229219
ikskuh
but will eventually yield hard-to-find bugs

1587229225
companion_cube
why so?

1587229231
ikskuh
because you may want to return a complexer type in the future

1587229239
ikskuh
like, having an additional info in the return type

1587229245
companion_cube
ikskuh: there's a trivial solution to that

1587229248
ikskuh
now everything that depends on that will break

1587229251
companion_cube
fail if you don't bind all the fields

1587229266
foobles
what about destructing more complicated struct?  `const { a = .x, b = .y } = foo();` if foo returns a struct with x and y?

1587229267
companion_cube
(cause it's a bug to ignore a return value)

1587229279
mikdusan
I would expect destructuring to support `_` in positions

1587229285
mikdusan
but I don't know if that's been talked about

1587229286
companion_cube
mikdusan: that seems obvious

1587229300
ikskuh
what is allowed to be destructured?

1587229301
ikskuh
only tuples?

1587229308
ikskuh
or structs and arrays as well?

1587229572
mikdusan
ikskuh: so far I've only seen destructuring wrt. initialization lists (tuples). so sounds like no for structs/unions/arrays

1587229610
companion_cube
(and that's where I'm going to wish for pattern matching)

1587230831
Xavi92
I'm modifying the compiler so it accepts the `def` keyword and provides default immutability ->

1587230879
Xavi92
zig's std lib won't compile yet, but I'm getting closer. I'd be very grateful if anyone helped me out with this

1587230945
Xavi92
fengb: "I donâ€™t even know why that topic came up" "Default immutability" -> andrewrk suggested removing `const` would make things easier to provide default immutability on a later stage. That's the relation between both topics

1587231041
Xavi92
fengb: As I've already explained on #5076, `const` loses sense if default immutability is provided, but I don't agree with the idea of `a = b` as a declaration. That'd be a big step backwards in terms of readability IMHO

1587231098
karrick
I think the "default immutability" aspect arose because the desire to remove the requirement for `const` from global declarations evoked some negative feedback about the resulting asymmetry between global and function level `const` declarations. Some people wanted to ensure both were the same to allow code to easily moved back and forth.

1587231130
Xavi92
Whatever andrewrk finally decides, I hope he has readability and safety as main priorities

1587231243
Xavi92
karrick: #5076 came right after #5056 was closed down, and since #5056 was aiming for default mutability, I see the relation between both proposals

1587231404
Xavi92
ikskuh: "def cmd_a = CmdHandler {" definitly a bad idea" -> I don't see why. After all, status quo has as `const name = definition` syntax for structs and enums, so I think it could work for functions too. It also avoids repeated code in the case of handlers, which is quite common in C

1587231426
ikskuh
Xavi92, tell me all declarations in this code:

1587231433
ikskuh
def foo = MyCallback {  };

1587231463
ikskuh
and now in this:

1587231476
ikskuh
const foo = fn(dst: *i32, src: i32= void { };

1587231488
ikskuh
and please explain why your variant is superior

1587231499
ikskuh
i can't see why it should be

1587231530
Xavi92
ikskuh: imagine you have N functions with that very same signature, and any change in the signature requires changing all of those N functions

1587231543
ikskuh
yes

1587231552
ikskuh
favour reading code over writing

1587231559
ikskuh
i don't care if i have to do that

1587231559
ifreund
^^^

1587231562
fengb
Where are the variables?

1587231581
ikskuh
i am happy if i return back to the code 2 years later and don't have to look up every teeny tiny bit of declaration

1587231594
ikskuh
i used to do a lot of macro stuff in C/C++

1587231600
Xavi92
ikskuh: if N functions are declared with the same signature, it might not be so clear the relation between them. `MyCallback` provides an interface to that

1587231603
ikskuh
now i went on to generating code

1587231618
ifreund
Xavi92: that's a job for a namespace + comments imo

1587231620
ikskuh
Xavi92: so? I can surely match patterns

1587231626
ikskuh
and what ifreund says

1587231635
ifreund
and good variable names

1587231641
pixelherodev
Refactoring is freaking trivial with a good editor

1587231644
ifreund
^

1587231649
ikskuh
i'm a lazy fuck, but i have learned that sometimes typing more is the long term solution to being lazy

1587231673
Xavi92
Anyway, I just suggested that syntax

1587231692
pixelherodev
ikskuh, I've learnt that power in Kakoune :)

1587231694
Xavi92
I'm not defending it either. I already know the cons behind it

1587231699
ifreund
ikskuh: join pixelherodev and I over in kakoune land to learn the true power

1587231736
Xavi92
My efforts are concentrated on having default immutability and avoid the crazy idea of introducing new keywords because some people don't like typing between 3 and 5 characters

1587231739
pixelherodev
`%s\bdynarec\.ebus\b<ret>cebus<esc> `

1587231740
ikskuh
> Modal editor

1587231742
ikskuh
nope :D

1587231753
pixelherodev
actual command I used a short while ago

1587231773
ikskuh
Xavi92, and still you chose to introduce a new keywordâ€¦

1587231790
pixelherodev
Refactored a file in less than ten seconds and it would've been faster if I could type faster than 110WPM

1587231802
fengb
pixelherodev: slowpoke

1587231806
pixelherodev
Yeah :(

1587231820
Xavi92
ikskuh: `const` does not have any sense once default immutability is implemented. Why use it?

1587231835
ikskuh
because it has still the meaning of const ;)

1587231837
fengb
Get a mechanical keyboard. Youâ€™ll sound like 500 wpm

1587231843
ikskuh
always assume zero-knowledge

1587231854
pixelherodev
anyways i'm in tremendous pain right now so I'll be back later, have fun with the bike shedding

1587231862
Xavi92
ikskuh: anyway, I've defended myself a million times. I'm tired of repeating myself

1587231887
ikskuh
Xavi92: yes, and you can still not convince me that you're ideas are superior to status quo ;)

1587231901
pixelherodev
status quo forever!

1587231934
fengb
The status is totally quo

1587232009
ikskuh
instead of building space for more bikes

1587232235
ikskuh
if you have two ways of parsing a file, how would you call the functions?

1587232249
ikskuh
one has "stupid parsing" which only returns the raw structure of the file

1587232261
ikskuh
the other one preprocesses some data and returns only data contents

1587232295
fengb
parseStructure and parseMeta?

1587232325
ikskuh
i think i'll go for "parse" and "parseData"

1587232368
ifreund
parseRaw/parseData imo

1587232369
ikskuh
parse is raw parsing, parse data will only yield data records and contains all logic to calculate correct offsets

1587232376
ikskuh
ifreund, yeah, better

1587232561
ifreund
Xavi92: by the way,

1587232848
frett27
hello, i hardly try to make iotmonitor project compile on rpi (

1587232878
ikskuh
frett27, do you use any C code in your project?

1587232885
ikskuh
or only zig code with libc linked?

1587232886
frett27
yes,

1587232896
frett27
i tried with :  zig build-exe -target  hello.zig  -lc

1587232906
frett27
the hello is just a std.debug.warn

1587232911
ikskuh
hm

1587232915
frett27
but when adding the flag it fails

1587232916
ikskuh
sounds like you found a bug

1587232936
frett27
pi@OrangePi:~/iotmonitor$ zig build-exe  hello.zig  -lc

1587232936
frett27
Code Generation [18/496] std.debug.dumpStackTrace...Illegal instruction

1587233003
TheLemonMan
frett27, get a backtrace with gdb

1587233010
TheLemonMan
and what rpi model is that?

1587233040
frett27
i'm using a orangepi, it's also an arm

1587233063
frett27
i'll look with the gdb

1587233199
frett27
Code Generation [18/496] std.debug.dumpStackTrace...

1587233199
frett27
Program received signal SIGILL, Illegal instruction.

1587233199
frett27
0x015fded0 in iter_function_params_c_abi(CodeGen*, ZigType*, FnWalk*, unsigned int) ()

1587233221
TheLemonMan
paste somewhere the output of `bt` and `disassemble`

1587233279
frett27


1587233505
TheLemonMan
hmm, are you sure the `disassemble` output isn't cut? I can't see 0x015fded0

1587233532
TheLemonMan
it may be some more UB in the stage1 compiler

1587233670
frett27
=> 0x015fded0 <+1084>:  udf     #65006  ; 0xfdee

1587233688
frett27
UB ?

1587233753
TheLemonMan
frett27, yeah that's not in the paste

1587233759
frett27


1587233776
TheLemonMan
U(ndefined) B(ehaviour) in the C++ codebase

1587233834
frett27
the used zig is the binary from

1587233877
frett27
i know the plateform is not yet fully supported, in cross plateform

1587233928
frett27
but wanted to give it a try to see if it can help supporting it, as embedded, rpi is a widely used plateform

1587233964
frett27
udf -> user defined function ?

1587233983
TheLemonMan
undefined opcode, it's a trap

1587234034
frett27
ok, so linked to the plateform / cpu choose ? it's it ?

1587234080
TheLemonMan
yep

1587234108
frett27
are there any ways to try to use "more common" arm instructions ?

1587234195
TheLemonMan
the problem is in the C++ code, that arch/platform and the use of a bootstrapped compiler made it surface

1587234286
frett27
is that because the boostrap compilation target the wrong cpu ?

1587234305
frett27
and we have wrong instruction linked by the zig ?

1587234352
TheLemonMan
no, the bootstrap compiler enables the undefined-behaviour checker for all the C/C++ code it compiles

1587234371
TheLemonMan
whereas clang/gcc don't unless you explicitly enable it

1587234509
frett27
in the hello case there is just a link to C library (no C code here). in the full project i have links with C code (but not compiled by zig)

1587234599
frett27
seems rust has the same troubles :

1587234622
TheLemonMan
no that's completely different

1587234632
TheLemonMan
the C++ code I'm referring to is the compiler itself

1587234851
frett27
ok, see the UB sanitizer from clang

1587234915
meowray
TheLemonMan: Context of

1587234953
frett27
TheLemonMan, let me reformulate, from what i understand, an ub is present in the compiler, and clang activate a gard in udf instruction

1587234959
frett27
it that correct ?

1587234988
TheLemonMan
meowray,

1587235067
meowray
git commit --amend --author ='LemonBoy <thatlemon AT gmail DOT COM>' ?

1587235090
TheLemonMan
yep

1587235108
TheLemonMan
I have two more approved patches that are only waiting to be committed

1587235113
meowray
2 tests failed. i need  to fix them

1587235137
nycex
which allocator should I use in stdlib tests?

1587235138
TheLemonMan
hm? the harbormaster was happy when I submitted the diff

1587235146
ifreund
ok, i feel dumb. Why cant i find a memcmp(3) equivalent in std.mem?

1587235160
TheLemonMan
ifreund, mem.eql

1587235163
pixelherodev
TheLemonMan, you okay?

1587235165
pixelherodev
` Closes my will to live`

1587235169
ifreund
for structs?

1587235177
pixelherodev
std.meta.eql?

1587235180
ifreund
mem.eql taks slices

1587235186
ifreund
ah that may be it

1587235186
pixelherodev
meta.eql should work IIRC

1587235202
TheLemonMan
if you want byte-by-byte comparison you need mem.asBytes(struct) and then mem.cmp

1587235211
TheLemonMan
meta.eql does a field-by-field comparison

1587235227
ifreund
that's actually what i want in this case, thanks guys

1587235239
meowray
TheLemonMan: harbormaster is not on D62475

1587235293
meowray
oh, upgrade-enum-debug-info.ll.bc is empty when the diff is uploaded

1587235362
TheLemonMan
oh right, I was looking at another patch

1587235375
TheLemonMan
empty? let me check my local dif

1587235449
meowray
it is a blob.

1587235451
TheLemonMan
oh well, git diff didn't inline its content, awesome

1587235511
TheLemonMan
pixelherodev, I got some nasty corruption because of that bug and I spent way too much time trying to find out what was wrong heh

1587235849
TheLemonMan
meowray, do you want me to upload the binary somewhere?

1587235983
TheLemonMan
FireFox317, are you interested in some more UB squashing? :P

1587236113
ikskuh
funky

1587236122
ikskuh
"var i : 32 = 0;" is totally legit unless you access i :D

1587236130
meowray
TheLemonMan: your producer (clang 7.0.1) is strange...

1587236178
TheLemonMan
meowray, afair I've copy-pasted that from another test heh

1587236529
meowray
upgrade-enum-debug-info.ll.bc should be generated by a known release version of llvm-as <

1587236679
marijnfs
is there a way to use a []u1 efficiently?

1587236835
ifreund
marijnfs: no idea what you're trying to do, but have you seen std.PackedIntArray/PackedIntSlice?

1587236871
marijnfs
that might be it?

1587236885
marijnfs
also I wanted to implement a bloom filter, but I see there already is one!

1587236907
marijnfs
but I might have different needs anyway

1587236922
marijnfs
I want to have bits stacked together indeed, so [8]u1 being one byte

1587236980
TheLemonMan
meowray, yeah I generated that with llvm built before applying the patch

1587237663
ikskuh
the heck?!

1587237939
ikskuh


1587238064
nycex
why should the LeakCountAllocator in std.testing only be used for temporary test programs?

1587238075
ifreund
huh? i don't get it ikskuh

1587238089
ikskuh
read the error message

1587238105
ikskuh
nycex: you can use leak count allocator in any program

1587238117
ikskuh
but not the std.testing.allocator

1587238119
ifreund
well, there is no member `j`, onl `i`

1587238132
ifreund
s/onl/only/

1587238141
nycex
well i want to use it for a test i want to add to the stdlib

1587238198
ikskuh
ifreund: i declare a value of type Bar, not Foo ;)

1587238202
marijnfs
ifreund: I think he means the compiler doesn't say Foo is not a Bar

1587238202
nycex
should I just use an buffer and FixedBufferAllocator?

1587238206
ikskuh
Bar has j, not i

1587238212
marijnfs
I just acts like its a anonymous struct

1587238233
ifreund
ah, yeah my eyes just glazed over that

1587238278
ikskuh
it's â€¦ interesting

1587238394
marijnfs
maybe thats how its implemented?

1587238400
marijnfs
why care about the type there?

1587238411
ikskuh
because the error message is wrong

1587238426
ikskuh
it's misleading

1587238430
marijnfs
yeah i agree, but I guess implementation wise it makes sense to pass it through

1587238436
marijnfs
but yeah a simple check there would help

1587238500
ikskuh
well, i changed two parameters here and got hell of confused

1587238501
ikskuh
:D

1587239400
meowray
TheLemonMan: eventually pushed... i also learned a lot through the process

1587239621
ikskuh
can i somehow hook up releases of a new zig version to rebuilding projects of mine with github CI?

1587239692
BaroqueLarouche
yes, there's a GitHub Action for that

1587239723
BaroqueLarouche
oh, maybe not

1587239734
BaroqueLarouche
but there's a GitHut Action that download master zig and build your project

1587239743
ikskuh
yeah, that's a nice thing

1587239748
ikskuh
but doesn't help project rot

1587239757
ikskuh
would like to keep my stuff up-to-date

1587239908
meowray
TheLemonMan: ppc bitreverse.i64 was also my first adventure with llvm... why can't rldicl be used on ppc32?

1587239938
meowray
T

1587240174
nycex
when i run the std tests, can i specify to only run e.g. the tests for std.fs?

1587240186
ikskuh
you can havea a test filter

1587241190
nycex
what do i specify there? i tried to specify the a part of and the full name of the test and also the path of the file the test is in, but it both didn't work

1587241512
TheLemonMan
meowray, the patch process with phabricator has been nothing but frustrating for me heh

1587241568
TheLemonMan
meowray, hm that's the only non-pdf opcode listing I've found, the same notice can be found on other ppc manuals

1587241625
TheLemonMan
like this one

1587242494
shakesoda
does zig std have any of whatever that data structure is called where you have a linked list of fixed size arrays, instead of one big one you grow

1587242518
shakesoda
it's easy enough to just make one, just wondering if there's already one

1587243492
ifreund
hell yeah, our bdfl has closed it

1587243551
BaroqueLarouche
yes status quo!

1587243655
ikskuh
ah nice

1587243666
ikskuh
this was a crazy ride :D

1587243964
companion_cube
ðŸŽ‰

1587244236
ikskuh


1587244245
ikskuh
a new small library on the sky of zig packages!

1587244288
BaroqueLarouche
Nice!

1587246533
Xavi92
ifreund: so will default immutability be finally implemented?

1587246634
Xavi92
I can't believe a proposal with +70 comments finally resulted in status quo

1587246658
ikskuh
Xavi92: why that? it's totally legit and there was no conensus about how it should change

1587246690
Xavi92
ikskuh: wrt default immutability I mean

1587246747
Xavi92
In fact, even if I suggested replacing `const` for something else for consistency reasons, I could live with it. Default immutability is a more important issue though

1587246785
ikskuh
i don't think it's that important

1587246807
ikskuh
depending on what andrews plans are on close(),deint() and so on

1587246820
ikskuh
we will have way less `const` things in idiomatic zig codes

1587246982
ifreund
don't forget that having `var` things that could be `const` will become a compiler error, that proposal is accepted

1587247038
ikskuh
yeah, i wonder how that will turn out

1587247208
oats
\[T]/ praise status quo

1587247291
oats
I hope this sets a precedent of being reluctant to make large, sweeping changes to syntax unless a really big issue shows up

1587247296
karrick
Cool: "don't forget that having `var` things that could be `const` will become a compiler error, that proposal is accepted"

1587247362
oats
ifreund: as in, if you declare something as var, but don't actually mutate it, the compiler will yell at you?

1587247390
ifreund
yeah

1587247398
oats
very legal & very cool :P

1587247425
ifreund


1587247437
oats
rust does something similar, but I don't remember if it's a warning or an error

1587247448
ifreund
it's warning

1587247462
ifreund
zig doesn't have warnings though :D

1587247482
oats
shit, really?!

1587247482
karrick
I wonder if this is something that `zig fmt` could fix...

1587247484
oats
that's kinda cool

1587247488
oats
I need to write more zig

1587247497
oats
stuff like that slipping under my radar

1587247502
Xavi92
ikskuh: didn't know that proposal got accepted. That turns it around

1587247649
Xavi92
Now I can sleep at nights :)

1587248123
torque
man, I'm kind of glad for that wild ride, as it helped me realize I definitely care enough about zig to throw my hat in the ring

1587248136
Xavi92
Overall, I'm happy with the decisions made: #224 and #1717 are accepted, which are a step forward in safety and readability, respectively. Can't wait to see these features implemented

1587248216
ifreund
yeah i'm quite happy with the direction zig is going

1587248240
ifreund
i think that issue was good to get some pent up bikeshedding out of everyone's systems

1587248250
Xavi92
Congratulations to the community, and specially andrewrk, for what I think is driving Zig into the valid direction

1587248274
oats
torque: thanks for your input, I enjoyed your first comment :)

1587248281
Xavi92
ifreund: gotta admit so much bikeshedding was exhausting, tough lol

1587248291
oats
I was feeling almost exactly the same and thought about weighing in before I saw yours

1587248367
oats
so we have settled on white for the color of the bikeshed :P

1587248383
marijnfs
I have some strange issue where I spawn a thread and pass a context, but the context is corrupted when it reaches the function

1587248964
marijnfs
is there an issue allocating a buffer in a main thread, and then using it in a spawned thread?

1587249180
mikdusan
andrewrk: it seems we build musl when -target *-*-musl; so this I think is borking alpinelinux host. `zig cc` seems to always build musl.a

1587249205
mikdusan
by always I mean use it. the cache is working fine.

1587249275
meowray
TheLemonMan: We should use Power ISA Version 3.0B for reference, not AIX stuff

1587249340
mikdusan
marijnfs: do you have a code reduction?

1587249817
marijnfs
mikdusan: i'm trying to make one, it seems hard to reproduce atm

1587249930
mikdusan
is your context storage stack or heap?

1587251141
marijnfs
mikdusan: heap, it a pointer

1587251357
mikdusan
ok; just make sure by the time thread finishes, that memory is still valid

1587251667
GreaseMonkey
ok, had a go at porting my deflate decompressor to use BitInStream and... i'm surprised as to how slow it is

1587252138
GreaseMonkey
using a 1KB buffer gives me a 10x speed improvement over doing reads a byte at a time for my own implementation so i'll try shoving in a BufferedInStream

