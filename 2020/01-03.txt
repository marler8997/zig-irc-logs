1578011879
fengb
I think I found a seam with async :(

1578011913
fengb
I'm resuming from a callback and it's not suspending correctly

1578011980
fengb
I'm guessing that should be illegal

1578014498
andrewrk
fengb, that should work fine

1578017318
adamkowalski
andrewrk: is this the recommended pattern for using closures in Zig

1578017364
adamkowalski
the test for it is right here

1578017417
daurnimator
adamkowalski: you should probably write: `const func = struct { pub fn foo() void {.... }.foo;`

1578017474
fengb
Iâ€™m definitely looking forward to anon functions :)

1578017482
daurnimator
note that soon functions can actually be anonymous

1578017484
adamkowalski
So what's the rational for leaving out lambdas / closures

1578017491
adamkowalski
we can make them zero cost if we have a capture clause?

1578017514
daurnimator
adamkowalski: "leaving out"?

1578017538
adamkowalski
we don't have lambdas, and I've seen lots of andrew's videos where he said a lot of design is what you leave out

1578017555
adamkowalski
so i'm assuming he knows about lambdas, decided against them, and I want to know the rational

1578017561
daurnimator
adamkowalski: what are you calling lambdas

1578017570
adamkowalski
if they aren't great, I'll try learn to cope without em

1578017579
adamkowalski
I would say a lambda is a closure that doesn't capture

1578017586
daurnimator
adamkowalski: we already have those

1578017594
adamkowalski
closure is a function which is stored as a variable

1578017603
hryx
closures specifically are tricky with Zig's philosophy of making all allocations explicit

1578017610
adamkowalski
and may* capture the closing scope

1578017623
adamkowalski
hryx no allocation, you must capture what you need

1578017636
daurnimator
adamkowalski: "closure" is usually defined as a superset of "function" where a number (0 to infinity) of variables are "closed over"

1578017649
adamkowalski
it's a simple rewrite into a struct with all the captured elements as members and then a call function

1578017662
daurnimator
adamkowalski: its really hard to make "capture"

1578017672
adamkowalski
daurnimator: you said we have lambdas already? do you just mean function pointers?

1578017685
adamkowalski
we don't have syntax to create them though

1578017704
adamkowalski
we have the ability to store function pointers in a variable and pass them to and receive them from functions

1578017726
adamkowalski
but we cannot simply create a function without a name

1578017731
daurnimator
adamkowalski: `struct { pub fn temp(x: i32, y: i32) i32 { return x + y } }.temp` is this not a lambda?

1578017735
adamkowalski
daurnimator: well it would allocate on the stack

1578017758
adamkowalski
I guess so. It's just a big gnarly haha

1578017780
daurnimator
adamkowalski: note that functions without a name at all are accepted.

1578017790
adamkowalski
I feel like we could change our syntax for functions to be const temp = fn

1578017796
adamkowalski
thats more in line with const temp = struct

1578017800
daurnimator
adamkowalski: see link. that's coming

1578017840
adamkowalski
oh thats awesome!

1578017858
daurnimator
adamkowalski: so not only do you already have them today (but ugly). they're getting nicer soon :P

1578017904
adamkowalski
that stuck out to me a bit since everything else was always anonymous but not functions

1578017959
adamkowalski
daurnimator: but so whats the rational against having the call operator be overloadable?

1578017976
daurnimator
adamkowalski: zig doesn't allow

1578017978
adamkowalski
the we can have structs that you can pass to functions

1578018012
adamkowalski
yeah I guess that's true, I guess that makes it simpler to reason about your codebase

1578018018
daurnimator
exactly.

1578018107
adamkowalski
but so besides changing the closure is there anything else that stuck out about my codebase?

1578018116
adamkowalski
did you think the syntax for declaring a tensor was reasonable?

1578018145
daurnimator
adamkowalski: I don't know why you made a closure instead of just having the contents of it there

1578018152
adamkowalski
it's recursive

1578018157
daurnimator
oh right

1578018169
daurnimator
so... uh... recursion might be sort of going away

1578018177
adamkowalski
I need the data to be contiguous in memory

1578018185
adamkowalski
so I need to traverse the nd array literal and flatten it

1578018201
adamkowalski
how would you approach it instead?

1578018221
daurnimator
adamkowalski:

1578018234
fengb
It wonâ€™t go away. Itâ€™ll just be a pain to use :P

1578018310
pixelherodev
Argh - been working on an ESP8266 project. and there are SO MANY ways it would be better if I could write it in Zig :(

1578018327
pixelherodev
Error unions alone would save me so much pain

1578018348
daurnimator
pixelherodev: have you given llvm-xtensa a spin?

1578018361
pixelherodev
Not worth the risk.

1578018368
fengb
I hope Zig succeeds just to push error unions into the mainstream

1578018373
pixelherodev
Yeah

1578018380
daurnimator
fengb: I still want error values

1578018381
hryx
ooh what's it about pixelherodev ?  I'm excited to see/make embedded shiz done with zig in the future

1578018397
pixelherodev
Without going into details, it's a medical project

1578018415
adamkowalski
daurnimator how would you solve that problem without recursion?

1578018444
pixelherodev
Again, without going into too much detail, there's an investor interested in it, so I can't afford to risk using an (AFAIK) unstable toolchain

1578018447
adamkowalski
daurnimator: what are error values? would that allow us to add data to the error rather than just being a tag? I'm really missing that

1578018460
fengb
daurnimator: do you mean errors with extra data? Or more like Rust/Haskell/ML style errors

1578018460
pixelherodev
If all goes well, I can explain everything in ~2 months

1578018468
pixelherodev
If it goes poorly, I can do the same because nobody will care anymore :P

1578018471
fengb
pixelherodev: good luck!

1578018475
pixelherodev
Yeah, thanks

1578018483
hryx
sounds cool, also a perfect amount of mystique in your answer

1578018528
adamkowalski
also tail recursion won't blow up the stack, I feel like that could be allowed. It's a fixed size usage

1578018547
pixelherodev
I mean, I could probably spill the details without anyone caring, but at the same time I don't feel comfortable doing that even for something that's of relatively minor secrecy

1578018574
hryx
no, don't ruin your comfort or the mystique

1578018595
fengb
adamkowalski: thereâ€™s a proposal to mark functions tail recursive

1578018595
hryx
but you should totally announce it when you can

1578018619
adamkowalski
the compiler should be able to see that? Is that just to make it explicit?

1578018686
fengb
Yeah itâ€™s helpful as a personal check, especially if the compiler will reject non tail calls

1578018707
daurnimator
fengb: errors with extra data.

1578018727
fengb
daurnimator: ðŸ‘

1578018768
fengb
(Iâ€™m not a fan of result types because the compiler gets no help)

1578018777
pixelherodev
Okay I know I've said this before

1578018786
pixelherodev
But I don't see a lot of Unicode

1578018788
pixelherodev
What was that?

1578018812
daurnimator
pixelherodev: a thumbs up

1578018814
pixelherodev
Ah

1578018923
daurnimator
So now that non-exhaustive enums are accepted (

1578018957
fengb
Oh converting them to actual enums?

1578018960
daurnimator
e.g. I think AF_* constants should become non-exhaustive enums

1578018982
daurnimator
*members of a non-exhaustive enum

1578019071
andrewrk
flags remain the same though

1578019255
pixelherodev
Huh

1578019259
daurnimator
andrewrk: yep

1578019262
pixelherodev
#2647 looks cool

1578019385
daurnimator
pixelherodev: indeed. I hope andrewrk accepts it :)

1578019405
daurnimator
probably with emekoi's suggestion in the comments

1578019483
daurnimator
(with `union(error) {`)

1578020653
adamkowalski
we should think about creating a unified interface for errors and optional

1578020672
adamkowalski
they are both monads, maybe we can have do notation like haskell and unify error, optional, async, etc

1578020691
adamkowalski
also with optional I feel like we need something that allows us to convert it to an error so we can use try syntax

1578020749
adamkowalski
if your function "needs" a key to exist in a hashmap to continue for example. the current if (optional) |value| {} else {} is a bit much

1578020785
fengb
Is there a reason this isn't a string?

1578020799
daurnimator
adamkowalski: ? I don't know how those would get unified.

1578020815
daurnimator
adamkowalski: for optionals you already have `orelse` syntax

1578020850
daurnimator
fengb: no reason I see

1578020884
fengb
Saves a byte now with sentinels ;)

1578020894
adamkowalski
daurnimator: they are both monoids, functors, applicatives, monads

1578020916
adamkowalski
so you can have "map" which takes an optional and a function

1578020919
fengb
I understand half those words

1578020932
adamkowalski
if the value exists, call the function on the value and put it back in an optional

1578020978
adamkowalski
fengb pretty much it's just having map, and_then, or_else

1578021000
adamkowalski
but in abstract algebra we use map, bind, apply

1578021020
adamkowalski
try is syntax sugar for that right now

1578021030
adamkowalski
we don't have a try equivalent for optionals though

1578021038
daurnimator
I understood at least 2 of those additional words

1578021052
adamkowalski
ah, alright i'll back up

1578021068
adamkowalski
pretty much in haskell we have common "interfaces" (they call them type classes)

1578021082
adamkowalski
just like in c++ there are iterators, containers, etc

1578021092
adamkowalski
the most common in haskell are functors, applicatives, monads

1578021104
daurnimator
adamkowalski: I think you're saying is that these `foo() catch |e| return e` `foo() orelse return something` should share a keyword?

1578021106
adamkowalski
they provide a unified interface for accessing many common types

1578021113
daurnimator
adamkowalski: already lost me there

1578021130
adamkowalski
i'm saying that right now Zig uses many special purpose API's for each type

1578021144
adamkowalski
we don't have overloading

1578021145
daurnimator
by api do you mean syntax?

1578021150
adamkowalski
we don't really deal with iterators uniformly

1578021168
adamkowalski
arrays and slices are the only thing that can be accessed with []

1578021175
adamkowalski
it makes it really hard to write generic code

1578021190
adamkowalski
i'm proposing that we start finding the commonailities between types and have common apis to access them

1578021216
adamkowalski
then just like people have "concepts" in c++, "traits" in rust, "type classes" in haskell, "interface" in ...

1578021217
daurnimator
you're using such weird words to describe things here. they're not APIs... they're syntax.

1578021228
adamkowalski
they are functions

1578021238
daurnimator
they are explicitly

1578021239
adamkowalski
[] is just getting an index into something

1578021244
adamkowalski
i'm building a tensor type

1578021245
adamkowalski
I can't use that

1578021249
adamkowalski
which is shame

1578021257
adamkowalski
now I need to have my own .index method

1578021281
fengb
[] maps to memory. It's intentionally not a function or interface

1578021283
adamkowalski
we don't have good mechanisms for treating different types in a similar fashion is what i'm saying

1578021293
adamkowalski
like if you want to write a sort function

1578021309
adamkowalski
wouldn't it be nice to take anything which is random accessible, read and writable?

1578021322
daurnimator
adamkowalski: no

1578021331
adamkowalski
why?

1578021339
daurnimator
because it changes how the function should be implemented

1578021347
adamkowalski
does it though?

1578021372
daurnimator
yes. if I write a function like that, I'm probably going to want to assume that elements are linear in memory

1578021379
adamkowalski
if something is contigous in memory, has random access, and is mutable do I care if it's an array, slice, arraylist, or some other custom type that matches the interface

1578021388
daurnimator
[] let me do that. if I was going via method... I can't make that assumption

1578021409
adamkowalski
it's a precondition of your function

1578021411
fengb
If it's contiguous, they can devolve into a slice

1578021416
daurnimator
^

1578021443
daurnimator
adamkowalski: note that we also have .at() supported by e.g. std.ArrayList which might be what you're after here?

1578021457
adamkowalski
daurnimator: write that's my problem with it

1578021463
adamkowalski
sometimes it's .at, sometimes it's []

1578021472
adamkowalski
now if I want to write a function with something random accessible

1578021474
adamkowalski
it's a pain

1578021507
adamkowalski
I guess you can just only take in a slice and force everyone else to devolve to a slice

1578021515
adamkowalski
but things like +, -, /, etc

1578021519
adamkowalski
I wish we didn't have those

1578021532
adamkowalski
because I can add matrices, but they don't share a syntax with numbers

1578021534
adamkowalski
but why?

1578021573
adamkowalski
my point is, striving to create a set of interfaces that every type adhers to allows for writing more generic code that is reusable

1578021661
andrewrk
hryx, you were looking for stuff to do, here's another good one:

1578021662
fengb
Sometimes I kinda like Lisp's simplicity. So we don't bicker about any of this :P

1578021701
pixelherodev
Operator overloading is *convenient*.

1578021717
pixelherodev
That's about the only remotely positive thing I can say about it, and that's not exactly heavy praise

1578021848
dimenus
are the debug.warn format specifiers in the documentation?

1578021881
hryx
andrewrk: ah cool, I'll peep that. Still playing with the asm stuff but I'll put that on my radar as a more encapsulated project

1578021921
daurnimator
dimenus:

1578021981
dimenus
daurnimator: thanks

1578023834
fengb
`broken LLVM module found: Instruction does not dominate all uses!`

1578023843
fengb
Oh boy this guy again

1578023905
andrewrk
argh I hate that error

1578023940
daurnimator
so if I wanted to use TLS (SSL) from zig... what is my best option? and going further: what is our plan for using TLS (and HTTPS) in the standard library?

1578024032
andrewrk
same as go. port a high quality tls impl to std lib, or directly implement it based on the RFC

1578024090
hryx
andrewrk: as an everyday Go user, I'm relieved to hear that's your position. I think it's the responsible thing to do if we are gonna have networking in the stdlib :>

1578024096
hryx
my 2 cents

1578024162
andrewrk
good to know hryx. btw did you see these examples?

1578024178
andrewrk
here you can kind of see how zig's async I/O mode competes with go

1578024195
andrewrk
I mean, the perf is not competitive yet, but the paradigm is the same

1578024200
hryx
I haven't! Are those things you worked on during live stream?

1578024219
hryx
(still catching up on the streams - finishing zasm pt. 2 tonight, now that I'm home)

1578024239
andrewrk
they're related to some of the stuff I did streaming, but no I coded these offline

1578024289
andrewrk
kprotty has done some improvements to the std lib event loop since these measurements were taken and has some more work in progress, I believe

1578024402
hryx
these look exciting. honestly I should study these examples pretty well because my mind hasn't 100% wrapped around Zig's async patterns. (It looks simple, I'm just not that experienced in some types of async programming)

1578024419
hryx
I'm used to Go invisibly providing a scheduler at runtime

1578024622
andrewrk
hryx, in summary you can think of `async` as the equvialent of "go" in go. it really is the same. the difference is zig has "await" to collect the return value of the function and go does not

1578024670
hryx
that is far simpler than I has assumed

1578025005
hryx
andrewrk: just re-read #181 (const/var vs. let/mut). Is the reason it was reopened that const/var as they pertain to functions may not properly convey the right meaning?

1578025706
fengb
I think I found a weird limit on how many blocks can be suspended

1578025826
daurnimator
andrewrk: I think #3972 #3989 should be straightforward merges?

1578025989
fengb


1578026041
daurnimator
andrewrk: would you want to receive a refactor of std/debug.zig that moves things into format-specific methods and adds deinitialisers?

1578026101
daurnimator
fengb: I'm suprised options isn't comptime known? I guess it doesn't have to be

1578026136
fengb
I can work around the bug in this case but I'm sure I'll encounter it again soon

1578026389
hryx
Multidimensional arrays with inferred inner array size a la `const x = [_][_]u8{ .... }` give "error: inferred array size invalid here". Is this intentional or should this be supported?

1578026567
daurnimator
hryx: intentional I think; in as far as it falls out of zig's general rules

1578026572
hryx
Looks like

1578026615
hryx
daurnimator: whatchoo mean by general rules?

1578026645
daurnimator
hryx:  [_]T{ things_of_type_T}

1578026677
daurnimator
`[_]T` isn't a valid type. hence [_][_]T is invalid

1578026723
hryx
Ok, I can dig that

1578032354
traviss
thanks to the recent floating point changes, i managed a competitive zig solution to the benchmarksgame nbody problem.

1578032379
traviss
2.783s zig vs 2.532s c on my system for the best c solution :)

1578032463
traviss
.. vector changes i mean. anyway. nice job guys.

1578032784
traviss
there are a couple of hairy ptr/align casts in there.  i was able to get a rough idea of how to translate them thanks to the new translate-c capabilities.

1578032871
traviss
like this one:

1578033083
hryx
traviss: nice! side note, I can't get enough of those slim .{ literals } conforming to all kinds of structs/arrays/Vectors

1578033272
traviss
yeah, it was super easy to change over from using [3]f64 to @Vector(3, f64). just change the type and all those literals worked.

1578047161
gonz_
I'm having an existential crisis. At some point I wrote a program, painstakingly in Haskell to solve a problem. I spent a day and change to optimize it down to giving a result in a reasonable time. The same program written naively, once, not a care in the world for optimization, runs in 1/48th of the time.

1578047175
gonz_
In Zig, that is.

1578047211
gonz_
None of this is really news, of course, Haskell is slower than zig... But it's just such a stark difference.

1578047272
gonz_
Many man-decades have been put into `ghc` to make it do veritable magic to make Haskell go fast and it's indeed one of the faster slow languages... But it just can't compete even remotely on this level.

1578047520
gonz_
I/O also wouldn't be able to bottleneck this; the Haskell version spends a bit more than 2 seconds doing this work on 9.5 kB of data. The I/O required isn't even meaningful here, except to the zig version.

1578047649
gonz_
Haskell has other upsides, of course, but you start to wonder if it's productive to even go down that avenue at all at some point.

1578047935
companion_cube
what kind of work does the program do?

1578048596
bgiannan
gonz_, performance is not always a requirement

1578048967
gonz_
bgiannan: Sure. I like Haskell in many ways and I think disregarding the parameter of performance it still has a real value proposition.

1578049029
gonz_
companion_cube: Parses some data (~9.5 kB) into commands, executes those commands on a vector of 1 million elements.

1578049042
gonz_
The commands can touch any range of values in the vector.

1578049050
companion_cube
did you use a vector of unboxed types in Haskell? :D

1578049117
gonz_
I made several Haskell versions, one about as dirty as you can imagine that I remember performing better but I saw more runtime errors that day than I've seen since.

1578049133
gonz_
That was using a mutable vector with only `unsafeX` functions

1578049147
companion_cube
I'd be curious to see a rust version as well

1578049226
gonz_
The most interesting thing about this IMO is that I spent so much less energy on the zig version, yet it outperforms it so handily. I imagine idiomatic rust would be the same; you'd just write it and it would perform well.

1578049324
companion_cube
I think so too, yeah

1578049342
gonz_
I imagine outsourcing the Haskell version to nastyness would yield whatever that code takes + FFI costs which wouldn't be too bad. But at that point you've definitely just resigned yourself to hard debugging and hard to work with code.

1578049560
companion_cube
what kind of commands are these, btw? Set/Get?

1578049592
gonz_
It's day 4 of the 2015 advent of code set

1578049600
gonz_
day 6*

1578049617
companion_cube
ah, there's an integer machine or something, right? I didn't have the motivation for AoC this year :(

1578049621
gonz_
One part is a toggle of a vector of booleans, essentially

1578049630
gonz_
Turn on/off, toggle

1578049639
companion_cube
basically, a bitvector :D

1578049643
gonz_
So addressing into the vector + changing the values

1578049654
gonz_
The other part is dim/raise & raise by 2

1578049665
gonz_
So a vector of ints, +1, -1, +2

1578049669
gonz_
Again addressed the same way

1578049775
gonz_
I'm sure there are better ways to solve the problem itself and it's possible that this is just a pathological case for Haskell that needs to be solved with entirely unsafe tools, but at the same time it's not an unrealistic thing and the fact that it's expressible in an efficient way so easily with other languages isn't a positive for slower languages.

1578049838
gonz_
I'm also leaving the door open for myself having expressed it badly in Haskell, but the main issue there in that case is that I'd used Haskell far more than I'd used zig when I created the respective solutions.

1578049893
companion_cube
probably in Haskell you need to use the ST monad? and be careful to have everything eager and unboxed

1578050063
gonz_
Right, but a `STVector` is just a type alias over `MVector` and yes, the end solution uses unboxed vectors

1578050102
gonz_
Like I said, I do remember `MVector` improving the situation but also essentially ruining the maintainability of the code.

1578050150
companion_cube
:D long live system languages

1578050157
companion_cube
zig, rust, crystal, nimâ€¦

1578050174
gonz_
But yes, fundamentally there will always exist a solution in Haskell that somehow gets to a competitive result, either by outsourcing a lot or using unnatural tools in the language.

1578050209
gonz_
The internal crisis I have/had is mostly about how that feels so unnecessary in the end.

1578050268
gonz_
On one hand I have an easy to use tool that gives me great performance when I write my naive solution. On the other, I have a tool that I love expressing myself in but requires me to do tons of work to get to a well performing result.

1578050298
gonz_
Anyway, not to dwell too much on this...

1578050354
gonz_
I just needed to vent and not hear "well no code is ever blocked on computation, we have such great hardware nowadays, SQL queries are always what you need to optimize", etc.

1578050355
companion_cube
well if your goal is to solve problems, seems like the answer is clear :)

1578050375
companion_cube
ahah as if everything was a websiteâ€¦

1578050451
gonz_
Indeed. On the 6th I come back from my holidays to Elixir which is probably a few times slower than fast slow languages. :D

1578050518
gonz_
I'm properly fired up now for a workout; BBL.

1578050609
companion_cube
otoh elixir is pretty clean, innit?

1578050646
gonz_
It makes for unmaintainable code beyond even a moderate linecount, IMO

1578050648
gonz_
I hate it

1578050664
gonz_
I owe a really good career to it, but as a language I hate it

1578050714
lupine
heh

1578050722
lupine
people keep suggesting we should rewrite a pile of stuff in it at work

1578050727
lupine
so far, successfully resisted

1578050767
gonz_
Unless those things are likewise dynamic messes, don't

1578050777
companion_cube
yeah, dynamic types :(

1578050781
lupine


1578050808
lupine
I owe a really good career to it, but as a language I hate it

1578050833
gonz_
:D

1578050868
companion_cube
lupine: have you looked at crystal at all?

1578051130
lupine
yeah, I despise it

1578051196
companion_cube
ah well, it looks pretty cool to me

1578051384
lupine
my dislike is highly irrational, so who knows maybe it's actuallygood

1578053500
gonz_
Crystal looks really good. Very funky FFI specs but that's a surface thing. It seems impressively fast and their standard library is vast for such a young project.

1578053517
gonz_
If I was a Ruby user I'd probably want to use it.

1578053596
gonz_
Likewise with Nim and all the other alternatives to scripting languages.

1578053639
gonz_
Overall it's very impressive how much the balance between programmer convenience and performance has shifted so much with all these languages on the scene.

1578053673
gonz_
People yell "Why one more language!?" every time someone makes a new one, but several of these newer ones have improved a lot on the general eco system of programming.

1578055040
mq32
hey, i got a question on zig on windows

1578055058
mq32
i want to link against an extern function from a dll, but i get this error message:

1578055062
mq32
Build Dependencies...link: could not find .def file to build acknex

1578055091
mq32
i have a small, handwritten acknex.def in my project root and import a single function like this:

1578055096
mq32
extern "acknex" fn engine_open(args: [*:0]const u8) ?*EngineVars;

1578055101
mq32
can somebody help me out here?

1578056267
bgiannan
this is quite funny

1578059754
fengb
andrewrk maintains one for Zig. Lemme see if I can find it

1578064230
fengb
How do I create a frame for a generic function?

1578064626
via
with the new translate-c stuff merged, i can now use libopencm3 directly from zig, thanks guys

1578064908
fengb
ðŸ¥³

1578065867
via
tryin to use @intToFloat on armv7 freestanding, getting 'lld: error: undefined symbol: __aeabi_ui2f', i'm guessing thats

1578066152
via
eh, looks like its not actually doing hardfloat

1578066519
frmdstryr
via: What hardware are you using?

1578066599
via
stm32f405rg

1578066606
via
m4 with fpu

1578066645
via
exe.setTarget(builtin.Arch{.thumb = builtin.Arch.Arm32.v7em}, builtin.Os.freestanding, builtin.Abi.eabihf); -- though with c i have to pass some fpu flags, trying to figure out how to do that with zig build system

1578066857
frmdstryr
I think you pass them while building zig build -Dsome-flag

1578066904
FireFox317
via: I guess you want this?

1578067054
FireFox317
So you can specify 'cortex-m4' and it will enable the corresponding features of the cpu

1578067393
via
that looks right, any way to pass them through in the meantime?

1578067784
FireFox317
Uhm you can do `-mllvm -mcpu <llvm-cpu-name> -mfpu etc` to pass flags to llvm

1578067852
via
FireFox317: those are options to what command? any way to specify these in build.zig?

1578067955
via
i guess

1578067980
FireFox317
@via: These are options to `zig build-exe` and similar commands

1578068025
FireFox317
I'm not sure if it will work tho, as stated in when doing `zig --help` -mllvm is unsupported

1578068103
FireFox317
I think currently there is no way to do it via build.zig, we have to wait before #3927 is merged

1578068219
via
yeah, looking at the source i see no way to pass arbitrary options

1578068264
FireFox317
What I did when i needed "+strict-align" on a raspberry pi, i have a local copy of the zig source and changed

1578068790
fengb
I don't need @asyncCall for comptime known generic methods right?

1578068797
fengb
Because this looks pretty brutal >_>

1578069170
via
FireFox317: passing -mllvm with -mcpu nor float-abi=hard seems to make a difference. i think i really need to speceify -mfpu, which -mllvm does not support

1578069478
via
nor --march=cortex-m4f

1578070979
FireFox317
@via you can do `zig build-exe example.zig -mllvm --help` and it will show all the options you can provide

1578071002
via
yeah, i saw that, but no ability to pass the fpu type

1578071029
via
float-abi and mcpu/march don't seem to cause it to emit fp math

1578071153
FireFox317
Hmm yeah, i don't know either :)

1578071246
via
bummer. thanks though, i'll keep messing with it

1578071298
fengb
Oh no, I just realized none of this async stuff will work with wasm :(

1578079959
fengb
andrewrk: I'm trying to debug "Instruction does not dominate all uses!". It seems like the @frameSize is erroneously generating the same value no matter what I do?

1578080016
fengb
Maybe I'm not printing the right thing: `@sizeOf(@TypeOf(async testFmt(...)))`

1578080055
fengb
Always returning 352. Having the wrong size would explain things because if I comment random things out, it'll start compiling

1578080086
Akuli
zig compiles to wasm these days?

1578080135
fengb
Yes

1578080162
hryx
Akuli: breakdown of current wasm support:

1578080182
fengb


1578082008
schme245
does anyone have a minimal build.zig at hand that runs tests and builds an exe?

1578082052
schme245
haven't used any of the Zig build stuff yet and there's no documentation yet so I would be great to have an example to work from

1578082394
frmdstryr
schme245: There's many one github

1578082417
schme245
thanks looking at that now

1578082445
BaroqueLarouche


1578082649
schme245
BaroqueLarouche: perfect, thank you!

1578085201
andrewrk
how c++ solves

1578085412
mikdusan
me and c++ ain't getting on so well right now. I'm spending 80/20 time dealing with cruft like header-vs-impl and .h ordering rather than problem domain

1578085439
andrewrk
that's always a bummer

1578085456
companion_cube
isn't it supposed to get modules soon?

1578085465
BaroqueLarouche
"soon"

1578085516
fengb
When were modules invented?

1578085521
companion_cube
C++20, right?

1578085530
fengb
I mean as the modern thing in languages

1578085534
BaroqueLarouche
C++20 standard is supposed to be final early this year

1578085541
companion_cube
fengb: at least as early as modula

1578085580
BaroqueLarouche
but time will tell when all major will support them and be fast

1578085629
fengb
andrewrk:

1578085650
andrewrk
I can look into that

1578085664
fengb
I wish I have a condensed repro

1578085672
andrewrk
I might not get to it today

1578085677
fengb
np

1578085703
fengb
I think it's because the framesize is wrong

1578085718
fengb
Because commenting things out work and logging the framesize is all the same

1578085753
fengb
Where in the source could I tweak for a bigger frame?

1578087900
frmdstryr
Is an assertion for an empty struct known?

1578087908
frmdstryr
*a known issue

1578088251
Snektron
aren't modules pretty much DOA because of macros?

1578088280
Snektron
C macros ruin everything

1578088365
fengb
frmdstryr: seems like it doesn't like attaching an optional to a zero size `advanced_config: ?void = null,`

1578088390
fengb
Or ?u0, they all fail

1578088572
Snektron
andrewrk, another one of those tricks is empty base class compression

1578088601
Snektron
it's used all over the stl because structures in C++ aren't allowed to be 0 bytes

1578088637
Snektron
Theres an attribute in c++20 to fix it though

1578088659
Snektron
kind of

1578088748
fengb
You know how they say C++ is an octopus made by bolting on 4 legs to a dog? I think it's a centipede at this point

1578088809
Snektron
Nothing beats sfinae though

1578088853
fengb
I wonder how Zig will develop forward though. Backward compatibility at all cost?

1578088872
Snektron
I hope not

1578088890
Snektron
I think Rust handles it quite well by making different incompatible editions

1578088904
fengb
Oh yeah I think I read about something similar

1578088943
Snektron
Though i suppose you risk a Python 2/3 problem if its not handled well

1578088976
fengb
Ruby does a pretty remarkable job providing decent compatibility while phasing out stuff

1578089000
Snektron
Andrew mentioned wanting to be "done" with the language's semantics at some point

1578089011
Snektron
I wonder if that's even possible

1578089044
fengb
Well that's the fabled 1.0 release right? Forever perfect :P

1578089113
Snektron
I doubt development stops after 1.0 though

1578089121
Snektron
theres always more targets to add and more optimizations to make

1578089280
Snektron
One thought i had regarding 2765 btw... it seems illogical to me that `const result = a(); return a;` can't be handled by the result location system by eliminating that local variable

1578089304
Snektron
err, that should be `const result = a(); return result;`

1578089523
fengb
I think that's one of the follow up tasks the the original version

1578089592
fengb
Ish:

1578089603
fengb
Oh wait

1578089609
fengb
That's exactly what you posted. Ignore me lol

1578089675
fengb


1578089708
fengb
But I'm also a little concerned that you can easily break result location by adding an extra return anywhere. Maybe there should be a compile hint?

1578089858
Snektron
I think you can probably make an even stronger guarantee, but that would probably be complicated to implement

1578089870
Snektron
than just `return foo;` i mean

1578090015
Snektron
ideally `var result = a(); result.b = 10; return result;` would also edit the result location in place

1578090041
fengb
Maybe @resultLocation() returns the pointer

1578090064
fengb
Then it behaves like normal code

1578090068
companion_cube
what if async turns out to be a bad idea, post 1.0? :/

1578090102
Snektron
Why would it only after 1.0 turn out to be async?

1578090140
frmdstryr
fenbg: How would @resultLocation work with the example from mikdusan?

1578090143
frmdstryr


1578090149
plumm
andrewrk: is there any way the 'cannot evaluate constant expression' message could be more verbose? I'd really like to know why some things don't work rather than they just dont

1578090152
companion_cube
idk, it just seems like the most experimental part of zig to me

1578090167
companion_cube
it's hard to get design entirely right :/

1578090193
fengb
Ah... error unions and options are a sibling parent of this issue so... I don't know :P

1578090204
fengb


1578090240
andrewrk
plumm, yes there is a bunch of helpful context zig has that isn't in the error message

1578090527
kristoff_it
hi all, I noticed that since about 2-3 weeks ago something changed in the way zig generates the documentation. Before the change I was able to generate the docs for my lib, while now they come out empty. Is there anything that I'm missing?

1578091123
andrewrk
kristoff_it, sounds like a regression. generated docs are still pretty experimental

1578091142
andrewrk
I'll make a note to look into this

1578091152
kristoff_it
do you want me to open an issue?

1578091177
andrewrk
yes if you want to be notified when it is fixed

1578091248
kristoff_it
btw I think that the docs in the current state are already tremendously useful. I have a lot of comptime magic in my lib and I can see how in some places it's hard for the docs to know what to display, but even just being able to navigate the namespaces is great.

1578091416
kristoff_it
More than anything the one thing I feel is missing are docstrings for structs, which the documentation doesn't render. I tried fiddling around with the JS but I couldn't get to the bottom of it. I see that the Node is present in the json data structure but it's not referenced back from the struct definition.

1578091732
andrewrk
that makes sense

1578091834
pmwhite13
I've been struggling with this bug for about 3 days, and I've reduced the issue to this paste -

1578092007
andrewrk
pmwhite13, your `_ = async handleEvent(event);` inside the for loop is using the same memory for each invocation

1578092018
kristoff_it
pmwhite13: not an expert, so take my comment with a grain of salt, but I think you're mostly correct in the comment that you have at the bottom of that page: without inlining the for loop is just reusing the memory

1578092092
kristoff_it
so either you allocate enough memory for all the frames upfront, or you use an allocator and allocate as-you-go

1578092112
pmwhite13
reusing the same

1578092154
andrewrk
you provide the frame by the left-hand side of the `= async foo()`

1578092174
andrewrk
by using `_` you provide an anonymous stack variable as the frame

1578092179
pmwhite13
oh, gotcha, that's simple enough. I'll go try that.

1578092189
andrewrk
but the lifetime of the anonymous stack variable ends at the end of the block in the for loop

1578092246
andrewrk
the inline for loop is still problematic; it's an accident that it works

1578092298
andrewrk
consider, when you async call a function, its frame is supplied by the callsite. and that frame must outlive the call

1578092332
andrewrk
so if you async call handleEvent(), you need to make sure that the frame memory for handleEvent is valid until handleEvent returns

1578092347
andrewrk
the simplest way to do this would be to use `await`

1578092376
andrewrk
well, let me rephrase - one tool to do this is to use `await` because it makes the fn that awaits suspend until the frame is no longer needed

1578092453
kristoff_it
do I remember correctly that you can't just straight create an array of Frames, set them (using `async foo()`) and then await them one by one?

1578092475
kristoff_it
I think last time I tried that the program crashed immediately

1578092491
pmwhite13
if I understand correctly then, any async functions called by `handleEvent` will be apart of the final stacksize of `handleEvent`

1578092564
daurnimator
traviss: you should just be able to assign an array to a vector

1578092610
pmwhite13
ahh, just tried allocating the frame and then just leaking it after the iteration so that it lasts forever. worked!

1578092640
lukeholder
Anyone see something wrong with:

1578092643
lukeholder
```

1578092661
plumm
lukeholder: try a gist

1578092667
lukeholder
oops thanks

1578092671
lukeholder
too much time in slack

1578092702
lukeholder


1578092706
pmwhite13
I had tried to do something similar by allocating and then copying the frame into the allocated memory, but then I saw that frames are not movable. However, saving directly into the dynamic memory is not moving.

1578092711
andrewrk
pmwhite13, yes if you call an async function as a normal function, then the caller becomes an async function, and uses an anonymous variable in its frame, for the callee's frame

1578092773
andrewrk
kristoff_it, array of frames should work fine

1578092789
daurnimator
bgiannan: fengb I think you were looking for

1578092808
plumm
lukeholder: what zig version are you using?

1578092818
lukeholder
âžœ zig version

1578092819
lukeholder
0.5.0

1578092820
plumm
im on 0.5.0+f40b6b85f and that format + compiles + runs fine

1578092834
plumm
oh, you can't use anonymous struct syntax with 0.5.0, thats a trunk/master thing

1578092836
fengb
lukeholder: need to update to master zig build

1578092837
andrewrk
lukeholder, there's a 0.5.0 version of the docs to match that compiler version

1578092845
fengb
daurnimator: ah yes!

1578092862
andrewrk
unfortunately zig is still so unstable, that it makes sense to use master branch

1578092865
lukeholder
andrewrk: ah yeah was pasting the master docs

1578092867
lukeholder
thanks

1578092899
fengb
Unfortunately, your language has: [x] comprehensible syntax

1578092905
lukeholder
ha

1578092951
lukeholder
Actually just working for the docs from a UX point of view

1578092969
lukeholder
working *through

1578093208
schme245
any way to get `zig build` to output everything on separate lines?

1578093253
daurnimator
schme245: hmm? zig build doesn't really have much output normally

1578093322
schme245
oh, I guess the actual output is coming from `zig test`

1578093401
schme245
daurnimator: ^

1578093407
kristoff_it
andrewrk: I'm pretty sure it caused a crash in one of my programs, but I can't test it again because now I'm tripping a compiler assertion when cross-compiling for linux

1578093429
daurnimator
schme245: silly hack: pipe zig test output through `cat`

1578093435
daurnimator
it does tty detection

1578093496
schme245
what does tty detection mean?

1578093502
schme245
here's what my CI looks like:

1578093573
daurnimator
schme245: it uses `isatty` to know if it should use newlines or not

1578093603
daurnimator
schme245: in general that type of output occurs when a CI system lies about supporting a certain set of terminal escape codes...... cause most of them lie and say they're xterm

1578093620
daurnimator
piping through `cat` will make `isatty` fail

1578093892
schme245
soehh... do I want it to be tty or not? :D to get newlines

1578093904
schme245
as you can tell, my knowledge of shells is limited

1578094080
daurnimator
schme245: you want it to not be a tty

1578094194
kristoff_it
schme245: daurnimator: the command should look like this I think: `2>&1 zig build test | cat`

1578094199
schme245
get the same result when piping to cat

1578094208
schme245
is the output coming through stdout or stderr?

1578094219
kristoff_it
you need the first part because you first need to redirect stderr to stdout

1578094305
schme245
ahh, this one did the trick!

1578094321
schme245
zig build 2>&1 >/dev/null | cat

1578094355
schme245
oh snap missed your message kristoff_it, sorry!

1578094366
daurnimator
use `zig build |& cat` instead

1578094368
kristoff_it
np, glad you got it working :)

1578094403
kristoff_it
daurnimator: wow that's a trick I didn't know about

1578094426
schme245
that's slick

