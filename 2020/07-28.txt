1595895065
pixelherodev
Woot!

1595895068
pixelherodev
All astgen?? :D

1595895124
pixelherodev
(for arithmetic + assignments, at least)

1595895234
pixelherodev
Still pretty impressive though :)

1595895724
pixelherodev
That means a loooot more CBE + SPU II work is going to be incoming soonish, because I'm going to want to get as much as possible working now :D

1595895996
andrewrk
the next test case I'm working towards is

1595896006
andrewrk
which means stack allocations

1595896032
andrewrk
then

1595896076
pixelherodev
Awesome :)

1595896129
pixelherodev
andrewrk: when you get these intermediate tests working, mind pinging me so I know there's more frontend stuff to integrate into my backends?

1595896152
andrewrk
there's already pending test cases for the C backend

1595896157
andrewrk
it's behind by a couple test cases

1595896245
pixelherodev
Ah, good to know

1595896250
andrewrk


1595896251
pixelherodev
I'll work on those tomorrow probably

1595896293
pixelherodev
Doing a bit more emulation work tonight, though I'll probably find time to do the interpreter too

1595896295
andrewrk
does your CBE test harness support compare output? e.g. it would run zig cc on the output code and then run the binary?

1595896309
pixelherodev
... no, but I'll definitely fix that

1595896312
pixelherodev
That's a good call

1595896322
pixelherodev
Making a TODO list for tomorrow

1595896329
andrewrk
it's pretty sweet that we have that available to us :) pretty slick IMO

1595896334
pixelherodev
Yeah

1595896343
pixelherodev
To be honest, it hadn't even occurred to me to do that

1595896419
andrewrk
I think it should by default be activated for all the compare output test cases, but you could explicitly disable testing the C backend for a particular case

1595896445
pixelherodev
That's simple enough

1595896446
leeward
ronsor: It's a good candidate, and not much else really tries.

1595896446
andrewrk
also we should add object format to std.zig.CrossTarget

1595896513
andrewrk
pixelherodev, there's the C backend use case, and also the use-elf-on-windows use case

1595896522
pixelherodev
I also want to add raw ihex / binary output soonish

1595896526
pixelherodev
Should be simple enough anyways

1595896541
andrewrk
also COFF on freestanding

1595896561
pixelherodev
Means refactoring some of File.ELF out into File and adding File.Binary / File.IHEX

1595896562
andrewrk
oh you just said that. yeah suffice to say, it's planned to put ObjectFormat into std.zig.CrossTarget and std.Target

1595896903
daurnimator
pixelherodev: the C backend would use the 'raw' format by default right?

1595896920
daurnimator
as stupid as it is... you

1595896964
andrewrk
that's not how we're modeling it

1595896982
andrewrk
according to zig, C source code is an object format

1595897102
pixelherodev
^

1595897145
pixelherodev
Stupid question: what's "attempt to unwrap error"?

1595897157
andrewrk
`catch unreachable` but it was an error

1595897164
pixelherodev
ahh, gotcha

1595897166
pixelherodev
Thanks

1595897195
andrewrk
maybe better: "unreachable error occurred"

1595897197
pixelherodev
... there's too many of those :(

1595897199
pixelherodev
Yeah

1595897216
pixelherodev
Is it not supposed to print a backtrace on those?

1595897234
andrewrk
it's a standard safety check

1595897248
andrewrk
should be handled the same way as any other, by calling the panic function

1595897264
andrewrk
default panic function implementation prints a backtrace

1595897280
pixelherodev
Right, it's probably a separate bug :(

1595897541
pixelherodev
Yep

1595897552
pixelherodev
Segfault within detectTTYConfig lol

1595897558
pixelherodev
Because I'm running this over SSH XD

1595898365
leeward
In the default init-exe main.zig, should it be `std.debug.print("All your codebase are belong to us.\n", .{});`, `std.log.alert(.howAreYouGentlemen, "All your codebase are belong to us.", .{});`, or something else?

1595898377
leeward
Vote now, for great justice.

1595898426
leeward
(see also: PR 5941)

1595898541
andrewrk
std.log.info(.app

1595898602
leeward
So boring.

1595898711
leeward
For what it's worth, several of my co-workers have made clever zero wing references whenever I mention Zig.

1595898840
andrewrk
people know what the "hello world" text is for, but they've never seen std.log or the "scope" parameter before

1595898874
leeward
Yeah, I agree it's a good idea. Much more useful as a template for starting a real program.

1595898909
pixelherodev
Almost done with SPU II interpreter lol

1595898917
pixelherodev
Whoops, half-edited post :(

1595898932
pixelherodev
Meant to say that I'm almost done, and most of the work was tweaking my old one to not have JIT support :P

1595898939
pixelherodev
~250 lines and shrinking

1595898998
leeward
Hooray for shrinking!

1595899084
pixelherodev
Yep :)

1595899130
pixelherodev
Some of the changes I'll probably backport later

1595899371
pixelherodev
Alrighty, ~230 lines, time to actually test it out

1595899444
daurnimator
I don't think using std.log for hello world is a good idea...

1595899467
daurnimator
std.log should be used for debugging and informational purposes; not as the primary output of a program

1595899509
pixelherodev
Yeah, I think I second that

1595899515
daurnimator
i.e. it should really be `try std.io.getStdOut().writer().print("All your codebase are belong to us.\n", .{})`

1595899517
pixelherodev
Normal output goes to stdout, logging goes to sterr

1595899520
pixelherodev
stderR*

1595899522
pixelherodev
stderr*

1595899538
leeward
As opposed to std.debug.print?

1595899545
daurnimator
leeward: yep

1595899556
pixelherodev
Hmm, I'm actually really unsure

1595899559
pixelherodev
There's good arguments both ways

1595899564
leeward
std.debug.print goes to stderr too, no?

1595899578
pixelherodev
Yep

1595899596
daurnimator
IMO std.debug.print is for the sort of debugging cycle where you wonder "is this being reached and in what order" -> insert print -> rerun -> add more prints -> rerun -> remove prints

1595899617
andrewrk
I don't think init-exe should initialize an application for writing to stdout. logging is much more common than actually writing to stdout

1595899632
andrewrk
the debug cycle is exactly what one is participating in with init-exe

1595899671
andrewrk
std.log.info(.app, "application initializing", .{});

1595899698
daurnimator
andrewrk: fair for init-exe

1595899728
pixelherodev
Yeah, when you put it like that it makes sense

1595899730
daurnimator
in my mind I had started to think about the hello world on

1595899784
pixelherodev
CompareOutput tests are for native-native only, right?

1595899792
andrewrk
pixelherodev, correct

1595899797
pixelherodev
Probably want something else for cross compilation

1595899804
andrewrk
interesting, the x86_64 ABI document recommends to use %rax and %rdx (2 registers) for return values. Might be interesting to take advantage of this for error union types

1595899805
pixelherodev
`ctx.cross(target, etc)`

1595899830
pixelherodev
Yeah, %rax and %rdx are the first two, after which everything is supposed to be in memory IIRC

1595899834
pixelherodev
Been a while since I implemented it :P

1595899919
andrewrk
pixelherodev, a CrossTarget can specify the concept of "native" and it can also specify the concept of choosing a part of the target. the compare output test cases should always compile them, but then only run (and compare output) if the test system is capable of running the output. zig build has integration with wine, qemu, and 2 wasm interpreters, which can be enabled to run additional tests

1595899937
andrewrk
and then of course if the native target is capable of running the selected target

1595899969
pixelherodev
Ah, so I should just add a CrossTarget to CompareOutput

1595899975
pixelherodev
Currently it's

1595899975
andrewrk
there already is

1595899979
pixelherodev
It doesn't check a t - hmm

1595899993
pixelherodev
Ohhh right

1595899999
pixelherodev
It's part of the Case, not the particular Updare

1595900001
pixelherodev
Update*

1595900014
andrewrk
CrossTarget already has the getExternalExecutor function

1595900023
pixelherodev
The interpreter is

1595900039
pixelherodev
But that's separate

1595900051
pixelherodev
The shortcut APIs should expose the Target, and the runner should actually pay attention to it for CompareOutput

1595900066
pixelherodev
Going to be busy tonight, it's on my todo list for the morning though :)

1595901586
andrewrk
test.zig:9:9: error: TODO implement analyzeInstAlloc

1595901590
andrewrk
alright, stack allocation time

1595901635
andrewrk
it's kind of crazy how much simpler it will be to implement

1595901649
andrewrk
with llvm it will require a giant hack

1595901688
fengb
But it‚Äôd be different depending on optimization right?

1595901977
andrewrk
for debug builds, every function can have its machine code generated independently, and we know the stack frame size immediately upon doing it. for builds with optimization passes such as function inlining, the value is known after the optimization passes, which will be done for the whole program

1595902064
andrewrk
so it's a comptime value, but any attempt to read the value and do comptime logic with it is likely to cause a circular dependency if the target function is a child of the call graph

1595902099
andrewrk
the circular dependency could be broken with a no-inline call

1595902644
pixelherodev
Nice

1595904171
andrewrk
gonna extract some of Module.zig into zirgen.zig

1595904192
pixelherodev
What parts?

1595904212
andrewrk
analyzeInst and the corresponding callees

1595904232
pixelherodev
Ahh, gotcha

1595904238
pixelherodev
Thanks for the heads up :)

1595904239
andrewrk
or maybe ziranal.zig

1595904244
gruebite
What's going on when I store an "anytype"? @sizeOf on the type says 0, but it appears like I can do reflection on instantiated structs

1595904245
pixelherodev
`error: InvalidExe` <- woot

1595904245
andrewrk
or maybe just anal.zig

1595904270
pixelherodev
I mean, boo, but also yay - I got it building correctly within a test case, just need to hook up CompareOutput with the interpreter

1595904296
pixelherodev
Rather, it should switch on the target - native => current_code, spu_2 => interpreter, else => panic

1595904390
pixelherodev
andrewrk: are we going to want to differentiate between stdout / stderr in execution cases?

1595904433
andrewrk
no. compare stdout. print stderr on test failure as debugging output

1595904442
pixelherodev
Gotcha

1595904706
pixelherodev
andrewrk: what's the indicator for "native" from a std.Target?

1595904735
pixelherodev
I don't see anything at a quick grep

1595904823
pixelherodev
Ah, it's a CrossTarget thing, not std.Target

1595904845
pixelherodev
Whoops, thought I had a different type

1595904986
andrewrk
a CrossTarget is resolved into a Target, which may involve detection of native things

1595905087
pixelherodev
Right, I figured it out

1595905097
pixelherodev
It's coming together :)

1595905335
gruebite
:)

1595905388
pixelherodev
Why is toTarget deprecated?

1595909382
pixelherodev
Interpreter integrated! :)

1595910194
andrewrk
pixelherodev, use std.zig.system.NativeTargetInfo.detect

1595910290
pixelherodev
That works non-native?

1595910328
pixelherodev
Ah, I see

1595910335
pixelherodev
That's really overkill here though

1595910358
pixelherodev
We explicitly

1595910920
andrewrk
why don't we care?

1595911038
pixelherodev
Generally, I'd think we want tests to be uniform regardless of hardware - if it's not specified, we probably don't want a CPU feature influencing the test, and should use the baseline

1595911045
pixelherodev
Or I could be completely off-base, and we do want it :P

1595911071
andrewrk
we do want it

1595911075
pixelherodev
Gotcha

1595911090
andrewrk
first of all we want to test detecting native things

1595914110
pixelherodev
andrewrk: does it make more sense to parse the File.ELF into binary, or to add the raw binary backend first?

1595914179
andrewrk
no sense in doing extra work and then tossing it out

1595914188
pixelherodev
Or, the really lazy short-term route, could invoke objcopy as a ChildProcess :P

1595914196
pixelherodev
That'd be like two lines :P

1595914207
pixelherodev
Yeah, that's what I thought

1595914226
pixelherodev
I'll probably push what I have later, then block this PR on a separate one adding IHEX and raw backends

1595914231
andrewrk
I'm sure you already know my stance on inserting dependencies on things being installed on the system

1595914257
pixelherodev
Yep lol, wasn't serious

1595914472
pixelherodev
Hmm, ikskuh: is it intended that programs should be able to initialize RAM on startup without explicit copying from ROM? I remember something about supporting RAM in IHEX

1595914691
pixelherodev
Hmm, was I overzealous here? Should e.g. PT_LOAD be able to go at addresses outside the target address space?

1595914720
pixelherodev
The headers don't actually get loaded when the binary does (either flashing to a microcontroller, loaded by OS, etc), so I don't think their addresses actually matter

1595914732
pixelherodev
Only the

1595915103
pixelherodev
Oh woot, integer return values exist now!

1595915105
pixelherodev
Neat!

1595915260
andrewrk
pixelherodev, time to rebase, I pushed the big refactoring thing

1595915296
pixelherodev
Just now?

1595915301
pixelherodev
I'm in the middle of a different rebase lol

1595915302
andrewrk
0965724e316

1595915330
andrewrk
it doesn't touch link.zig or codegen.zig

1595915343
pixelherodev
I did a bit of work in codegen (basically, ignoring unknown arch in resolveABI when there are zero params) which interferes with return values :(

1595915349
pixelherodev
So I need to finish this one, then do another one

1595915351
pixelherodev
:(

1595915353
pixelherodev
Whelp

1595915507
pixelherodev
Oh neat, clean rebase!

1595915521
pixelherodev
Rebasing onto the refactor required no intervention from me :)

1595915592
pixelherodev
Which makes sense, since this PR is entirely focused on a backend, and doesn't touch the frontend

1595915674
andrewrk
sounds like our version control system agrees with my organization of files & code :)

1595915681
pixelherodev
:)

1595915692
pixelherodev
Night! I'll work on ihex tomorrow :)

1595915698
andrewrk
night

1595915718
pixelherodev
Ah right, missing an item on the PR checklist: "clean up stupid debugging tweaks"

1595915751
pixelherodev
I think that, among other things, i overrode the logging handler, added some debug.prints, and possibly worse :P

1595915761
pixelherodev
that's tomorrow me's problem

1595916005
ronsor
are safety checks also applied to C code?

1595916231
daurnimator
ronsor: yes

1595916337
ronsor
welp that explained my issue

1595916357
ronsor
had to disable it for some third-party C code

1595916664
daurnimator
ronsor: time to report a bug with that C code :)

1595917481
daurnimator
ronsor: you can just try to build the c code as normal c code with -fsantize=undefined on

1595918541
r4pr0n
ifreund: quick question about river: how are tags handled in multi monitor mode? do they have separate tagsets like in dwm or one for all?

1595923571
ikskuh
pixelherodev: why do you split RAM/ROM in your simulator?

1595934102
protheory8-new-m
I submitted Zig compiler to Flathub as Freedesktop SDK extension, is this fine?

1595934967
daurnimator
protheory8-new-m: I don't see the point; but I also don't see the harm

1595934999
daurnimator
so if someone finds it useful; and it doesn't keep them out of date... great :)

1595935291
protheory8-new-m
Why don't you see a point?

1595935400
protheory8-new-m
I mean I guess not that many people make GUI applications in Zig, so you might be right.

1595935710
ask6155
hello!

1595935791
protheory8-new-m
Hi!

1595936067
ask6155
I think zig has a bug, I tried to compile a 1.2mil file and it bricked my pc ;)

1595936216
ifreund
stage one is slow, this is known

1595936228
ifreund
stage two is much faster but not yet complete

1595936268
daurnimator
ask6155: you made a 0.0001 inch file?

1595936370
ifreund
the latest numbers andrew gave were that self-hosted is "486x faster, using 96x less memory"

1595936411
ifreund
which will probably decrease a bit as it grows more feature complete, but it certianly looks very promising

1595936615
ask6155
daurnimator: ;)

1595937013
protheory8-new-m
So how do I make Zig SDK extension more useful?

1595937066
ifreund
generally I have a use case first and then make something to solve it rather than the other way around

1595937203
protheory8-new-m
There is a use case?

1595937265
protheory8-new-m
To compile Zig apps in Flatpak sandbox without downloading Zig compiler while building app

1595942816
pixelherodev
ikskuh: because oops

1595942838
ikskuh
pixelherodev: that explains a lot

1595942843
pixelherodev
:(

1595942863
ikskuh
i recommend just using a [1<<16]u8

1595942864
ikskuh
:D

1595942874
pixelherodev
That's what I'm doing, I just said that in GH :P

1595942877
ikskuh
also, why do you allocate those with an allocator?

1595943205
pixelherodev
... also a good point

1595943224
pixelherodev
Any other blatantly stupid decisions?

1595943231
ikskuh
probably? D

1595943265
pixelherodev
Not blatant enough, clearly ;)

1595943453
ikskuh
do you want me to take a closer look? :D

1595943471
pixelherodev
If you want to, that'd be awesome

1595943486
pixelherodev
Unrelated, is there a specific reason freebsd CI doesn't test stage2?

1595943512
ikskuh
good thing: your tests all don't need any MMIO

1595943517
pixelherodev
Yep

1595943525
ikskuh
you can just check if certain memory addresses contain the right data and you're good

1595943537
pixelherodev
I can probably do that via the UART, too

1595943566
pixelherodev
A CompareOutput test, with a specific known pattern

1595943575
ikskuh
what UART?

1595943583
pixelherodev
Oh right

1595943584
ikskuh
there's no UART :D

1595943585
pixelherodev
I'm dumb.

1595943592
pixelherodev
That makes things harder

1595943609
pixelherodev
I might just define a custom UART for the purposes of the test

1595943616
ikskuh
why?

1595943617
pixelherodev
Write-only, single-address

1595943626
ikskuh
as i just said:

1595943635
ikskuh
check if certain memory addresses contain certain patterns and you're done

1595943636
pixelherodev
For CompareOutput tests, which - well - compare the output of a test program with the expected value

1595943659
ikskuh
return simulator.memory[0x1000‚Ä¶0x1008]

1595943673
pixelherodev
So you're basically saying, use an in-memory buffer as the output?

1595943680
ikskuh
yes

1595943689
pixelherodev
That... actually works really really well, yeah

1595943696
ikskuh
think simple!

1595943700
pixelherodev
Yeah

1595943863
pixelherodev
Thanks for the feedback, it helps :)

1595943881
ikskuh
i wonder

1595943886
ikskuh


1595943891
ikskuh
what instruction is this supposed to be?

1595943932
pixelherodev
File / line?

1595943942
ikskuh
oh :D

1595943942
pixelherodev
That link doessn't work for some reason :(

1595943976
ikskuh
codegen.zig, 783

1595944002
pixelherodev
Ah, that's on purpose

1595944009
pixelherodev
That's actually completely correct yay

1595944014
pixelherodev
It's `jump *(addr)`

1595944019
ikskuh
okay

1595944143
pixelherodev
ikskuh: it's related to incremental compilation

1595944161
pixelherodev
If the address of a function changes, the jump instruction doesn't change, only the value in the offset table

1595944225
ikskuh
looks okay so far

1595944687
pixelherodev
ikskuh: nothing against the undefined0 trap?

1595944689
pixelherodev
:P

1595944911
ikskuh
only that it's undefined0 :D

1595944965
pixelherodev
Hmm, this might be a spot to use the Model - use undefined0 as "shutdown" for an internal testing Model (the interpreter), leave it as undefined for general compilation

1595944999
pixelherodev
Then, instead of `asm volatile("undefined0")`, it'd be `asm volatile("shutdown")`, a CPU extension to kill the emulator ;P

1595945016
pixelherodev
That'd only be valid for internal testing though

1595945060
ikskuh
why not just make a ".dw 0x8000" or something

1595945095
pixelherodev
?

1595945102
pixelherodev
As an exit command?

1595945105
ikskuh
yep

1595945117
ikskuh
that would make it clear that it's not an actual instruction

1595945140
pixelherodev
Which one's that?

1595945166
pixelherodev
ikskuh: how about nop?

1595945174
ikskuh
what is "nop"? ;)

1595945189
pixelherodev
always-zero-zero-copy-discard

1595945190
ikskuh
my point is: any mnemonic would look like it's an actual instruction

1595945220
ikskuh
for example "ud2" is a

1595945220
ikskuh


1595945248
pixelherodev
Hmm, the internal assembler receives asm as a string - we

1595945268
ikskuh
that would be my long term goal anyways :D

1595945275
pixelherodev
I don't doubt it :P

1595945279
ikskuh
writing some highly optimized inline asssembly routies

1595945283
pixelherodev
Heck, how modular is your assembler?

1595945287
ikskuh
yes? :D

1595945305
pixelherodev
Mind sending a PR to

1595945323
ikskuh
haha

1595945326
pixelherodev
:P

1595945328
pixelherodev
I'm kidding, I got it

1595945330
ikskuh
how to do that?

1595945356
pixelherodev
I've already got std.spu.interpreter, I'll just merge your assembler in and tweak it

1595945387
pixelherodev
Oh, on that note: all the issues with the interpreter can be traced back to the fact that I was trying to adept an Ashet interpreter to the test suite instead of making a pure SPU-II interpreter from scratch

1595945410
ikskuh
well

1595945428
ikskuh
you just didn't strip out everything ashet specific (which were the read*() and write*() functions)

1595945444
pixelherodev
I stripped out even more that didn't make it into the PR lol

1595945465
pixelherodev
Woot, down to ~170LoC for the interpreter ;)

1595945478
ikskuh
the interpreter loop is damn small

1595945496
ikskuh


1595945515
pixelherodev
Yeah, I got that locally ;)

1595945520
pixelherodev
`var interpreter = std.spu.interpreter{};` <- wow, that's nice

1595945529
ikskuh
:D

1595945543
pixelherodev
I might want to separate it from the RAM though, and make it so that we can override the address space

1595945573
pixelherodev
That'll make it usable as a replacement for both of our interpreters, for instance, if done right

1595945614
ikskuh
you should be able to use the assembler without much work actually

1595945628
ikskuh
just remove main() and adapt the contents to the inline assembler

1595946038
pixelherodev
Can't wait until we have packages in stage2

1595946057
pixelherodev
Would be neat to be able to `usingnamespace @import("spu-2-tests");` and get a writer :P

1595946103
pixelherodev
Or integrate it with "stdout" and "stderr", each of which is a NKiB buffers in RAM (with N to-be-decided)

1595946113
pixelherodev
`std.debug.warn("Test")` -> writes it to in-memory buffer

1595946117
pixelherodev
s/warn/print

1595947530
pixelherodev
ikskuh: how about now? :)

1595947544
ikskuh
hm?

1595947548
ikskuh
what exatly?

1595947580
pixelherodev
Pushed interpreter cleanup

1595947589
pixelherodev


1595947607
ikskuh
ah

1595947638
pixelherodev
Using that interpreter with an arbitrary bus should be pretty easy now

1595947646
ikskuh
that's not portable

1595947656
pixelherodev
Why not?

1595947676
ikskuh
you're assuming system endianess and that RAM is aligned to 2

1595947684
ikskuh
use std.mem.writeIntLittle()

1595947686
pixelherodev
oh whoops

1595947688
pixelherodev
Yeah

1595947703
pixelherodev
I mean, it's portable to every system that anyone uses ;)

1595947707
pixelherodev
But yeah, no, you're completely right

1595947721
pixelherodev
If that's the only issue this'll be easy ;)

1595947779
ikskuh
i wouldn't use a generic here

1595947789
ikskuh
or i would restrict the generic to only u8 and u16

1595947792
pixelherodev
For the Bus itself, or read / write?

1595947793
pixelherodev
Ah

1595947812
ikskuh
for the interface

1595947815
pixelherodev
I'll probably limit it to numerics + Instruction

1595947818
ikskuh
so read8, read16

1595947826
ikskuh
because you allow unaligned access :D

1595947833
pixelherodev
Am I not supposed to?

1595947836
pixelherodev
I was actually meaning to ask you that :P

1595947847
ikskuh
spu 2 forbids unaligned access

1595947853
pixelherodev
Oh goodie

1595947868
ikskuh
there's no address lane 0  :D

1595947882
pixelherodev
Ahh, nice

1595948010
pixelherodev
u8/u16/Instruction for read, u8/16 for write is all that's needed

1595948060
ikskuh
no readInstruction ;)

1595948069
pixelherodev
?

1595948069
ikskuh
that is a implementation detail of the interpreter

1595948072
pixelherodev
For sure

1595948081
pixelherodev
... but it's so cleaaaaan

1595948089
ikskuh
what?

1595948097
pixelherodev
`var instruction = bus.read(Instruction, self.ip);

1595948105
pixelherodev
vs `var instruction = @bitCast(bus.read(u16, self.ip))`

1595948118
pixelherodev
:P

1595948124
ikskuh
last one is less complex

1595948130
pixelherodev
Yeah, I know

1595948169
pixelherodev
I should probably make it just read8 / write8 in the bus interface and have a wrapper in the interpreter for u16

1595948179
ikskuh
nope :D

1595948184
ikskuh
you're assuming stuff already again

1595948187
pixelherodev
?

1595948194
ikskuh
then you can completly remove the bus interface

1595948200
pixelherodev
Still nope

1595948204
pixelherodev
That's not why the bus is there

1595948205
ikskuh
and just replace it with a interpreter-internal [0x10000]u8

1595948212
pixelherodev
I did that earlier and removed it on purpose

1595948224
pixelherodev
The interpreter isn't in src-self-hosted, it's in std.spu

1595948241
ikskuh
how should MMIO work when you only have 8 bit writes/reads? ;)

1595948277
ikskuh
st 0x4000, 'A'

1595948287
ikskuh
would then yield two writes to a MMIO address

1595948296
ikskuh
‚Üí two times outputting, one times, 'A' and one time 0x00

1595948303
ikskuh
depending on the write order in your interpreter

1595948335
ikskuh
if you really want a precise simulation, do this:

1595948361
ikskuh
fn write(addr: u16, value: u16, bits: u2) void

1595948403
pixelherodev
fn read(addr: u16, comptime bytes: u1) if (bytes == 1) u16 else u8

1595948405
pixelherodev
?

1595948411
ikskuh
nope

1595948448
ikskuh
the real HW has a 16 bit bus, 15 bit address width

1595948463
ikskuh
and two lanes for "byte lane select"

1595948476
ikskuh
even more correct would be a `fn write(addr: u15, value: u16, bits: u2) void` then

1595948488
ikskuh
addr = 1 is adressing byte 2 & 3

1595948515
ikskuh
if you want to access byte 3, the CPU does this:

1595948524
ikskuh
addr = 1, value = ???, bls = 0b10

1595948535
ikskuh
if you want to access 16 bit value, bls = 0b11

1595948544
ikskuh
for lower byte, you use bls=0b01

1595948559
pixelherodev
Ohhhh, I see

1595948746
pixelherodev
ikskuh: don't you mean addr=1 addresses bytes 1 & 2? :P

1595948773
ikskuh
no

1595948778
ikskuh
addr=0 ‚Üí byte 0,1

1595948783
ikskuh
addr=1 ‚Üí byte 2,3

1595948800
pixelherodev
Ohhhhhh right

1595948804
pixelherodev
15-bit addressing

1595948818
pixelherodev
Clearly, the tea hasn't kicked in yet.

1595948958
pixelherodev
ikskuh: any reason not to require bits to be comptime?

1595948968
ikskuh
nah

1595949213
ikskuh
andrewrk: found a regression in build.zig when overwriting output_dir: build.zig hangs in atomicSymLink failing to create a path as the original path is invalid

1595949280
pixelherodev


1595949313
ikskuh
yeah maybe just pulls/new ? :D

1595949344
pixelherodev
Or that :P

1595949364
ikskuh
i wonder how to output files to arbitrary directories with build.zig

1595949381
pixelherodev
I think it's come up before

1595949389
pixelherodev
Maybe grep the logs?

1595949390
pixelherodev
:P

1595949432
pixelherodev
ikskuh: that should still by bytes not bits, right?

1595949437
pixelherodev
It's which

1595949446
ikskuh
it's "byte lane select"

1595949453
ikskuh
you can do 0b01, 0b10, 0b11

1595949457
pixelherodev
Right, I know

1595949461
ikskuh
0b00 is possible, but doesn't make sense

1595949463
pixelherodev
Which "byte lanes" do you want

1595949466
pixelherodev
0b00 is compileError

1595949469
ikskuh
call it bls or byte_lane_select

1595949475
pixelherodev
bls works, yeah

1595949748
pixelherodev
ikskuh: if 0b10, is it u8, or u16 with the upper 8 bits set?

1595949971
ikskuh
it's 0xVVXX

1595949978
ikskuh
with VV the value to write and XX are don't care bits

1595949993
pixelherodev
I mean for reads

1595950001
ikskuh
same

1595950001
pixelherodev
but that's what I thought

1595950010
pixelherodev
that's less fun

1595950012
ikskuh
the lower bits are undefined and may be anything

1595950017
pixelherodev
yep yep

1595950024
ikskuh
no bugreport today

1595950080
pixelherodev
Just going to have it always be u16

1595950086
pixelherodev
Caller can cast down when desired

1595950097
pixelherodev
This might be unnecessarily precise though

1595950182
ikskuh
that's why i told you to just to a {write,read}{8,16} functions

1595950187
ikskuh
which model the real hardware precise enough

1595950193
ikskuh
and are convenient enough

1595950197
pixelherodev
Yeah, probably should do that

1595950222
pixelherodev
Stupid human brain. Stupid sunk cost fallacy.

1595950238
ikskuh
you should learn not to overengineer things ;)

1595950253
pixelherodev
On the bright side, both ways (with or without bls) mean no more possible error on read/write

1595950289
pixelherodev
I might

1595950387
pixelherodev
Hmm nah, not ZIR. Trying to figure out the best way to do this...

1595950512
pixelherodev
I might finally rewrite the tricarbon backend using what I've learned from self-hosted, instead

1595951316
pixelherodev
ikskuh: ip should wrap, right?

1595951360
pixelherodev
Okay, infinite loop of `[SPU_2_Interpreter] (crit): Executing 0x0000      zero zero copy      discard`,

1595952110
ikskuh
<pixelherodev> ikskuh: ip should wrap, right?

1595952114
ikskuh
yes, it should

1595952245
ikskuh
ah, i see you're cheating :D

1595952255
ikskuh
sp and bp are not initialized :D

1595952287
ikskuh
also, if you're using "undefined0" as a instruction, you should define that instruction somewhere ;)

1595952335
pixelherodev
sp and bp are initialized to zero, aren't they?

1595952342
ikskuh
nope

1595952342
pixelherodev
Ah yeah, that's true

1595952351
ikskuh
they are defined to be initialized with undefined :D

1595952360
pixelherodev
Gotcha

1595952370
pixelherodev
Anything else?

1595952375
ikskuh
not for now :D

1595952378
pixelherodev
Good :)

1595952392
pixelherodev
Should we move your ihex library into std.ihex?

1595952397
pixelherodev
We've already got std.elf

1595952400
pixelherodev
So it makes sense

1595952400
ikskuh
yeah why not?

1595952412
pixelherodev
Then it's just a matter of extending Link.FILE

1595952416
pixelherodev
File*

1595952482
ikskuh
if my brain is less slow tomorrow, i'm going to prepare zig-network to be part of std

1595952489
pixelherodev
nice :)

1595952529
pixelherodev
andrewrk: any reason not to test stage2 in freebsd ci?

1595952592
ikskuh
only thing i feel bad for is marler8997 to rewrite a lot of stuff of they latest network update :D

1595953286
andrewrk
pixelherodev, yes, sr.ht it doesn't have enough RAM for stage1 to build stage2

1595953308
pixelherodev
... oh. Right. Stage1 is memory hog. Forgot about that

1595953365
andrewrk
ikskuh, that symlink regression sounds related to

1595953442
ikskuh
that would be weird, i used the master build from yesterday, it broke with the overnight build

1595953471
pixelherodev
Oh neat, optimization to stage1 + simpler stage2!

1595953472
pixelherodev
:)

1595953589
ikskuh
andrewrk: i don't think it's a problem with symLink itself

1595953631
andrewrk
oh

1595953642
andrewrk
gotcha

1595953758
pixelherodev
okay, rebased

1595953948
andrewrk
here's something exciting:

1595953960
andrewrk
first evidence that self-hosted debug builds generate better code than llvm

1595954039
pixelherodev
Nice :D

1595954049
ikskuh
ha, nice

1595954053
pixelherodev
And this is before constant propagation and suchlike

1595954061
ikskuh
what's the current status of stage2? what features are implemented already?

1595954114
Nypsie
Apologies for my ignorance but does this mean it uses less instructions to perform the same 'thing'?

1595954220
ikskuh
yep

1595954228
Nypsie
Cool! and thanks :)

1595954292
fengb
Wow that's like 20% faster

1595954623
Snektron
What about wall clock time?

1595954880
andrewrk
stage2 is missing a lot of stuff, it still doesn't have loops, comptime, generics, register/stack allocation across conditional branches, safety, structs, ...

1595954999
ikskuh
comptime is a pure ZIR transformation in stage2, right?

1595955043
andrewrk
yes it's part of the untyped ZIR to typed IR transformation

1595955066
pixelherodev
fengb: wall clock will be zero vs zero lol

1595955101
andrewrk
too hard to measure wall clock time without more stage2 features being implemented :)

1595955111
pixelherodev
That too

1595955113
pixelherodev
:P

1595955127
andrewrk
even so, the perf stats have a strong correlation to wall clock time, and are more insulated from nondeterminism

1595955143
fengb
More time spent on the syscall to measure than it would to execute :(

1595955144
pixelherodev
I'd help with those features, but I'm trying to avoid stepping on your toes - hence, focusing on backends, while you do the frontend work

1595955156
fengb
Getting to the quantum level of coding

1595955197
andrewrk
pixelherodev, there's a lot to do in zir_sema.zig and for many functions you can port from ir.cpp

1595955270
pixelherodev
Good to know

1595955282
pixelherodev
At the very least, I'll let you know when I start working on that

1595955451
pixelherodev
I'm just going to do std.ihex as part of the SPU PR, I don't want to have to deal with rebasing :P

1595955703
ikskuh
andrewrk:

1595955718
ikskuh
nasty bug, only happens when files already exist

1595955787
andrewrk
ikskuh, oof

1595955809
pixelherodev
oh wow

1595955815
pixelherodev
That

1595955871
ikskuh
that explains why CI didn#t catch it

1595955875
andrewrk
we have no test coverage for that function

1595955883
pixelherodev
A bit late to change that now :P

1595955896
pixelherodev
Might be worth having scanning to detect functions unused by tests?

1595955927
leeward
Code coverage is a useful thing.

1595955944
ikskuh
andrewrk: what would be the recommended way to test such function?

1595955957
leeward
The scanner would have to consider a set of build targets.

1595955962
ikskuh
i can add a test for this function

1595955987
ikskuh
that was probably the quickest master merge ever :D

1595956009
pixelherodev
excepting direct pushes ;)

1595956018
andrewrk
we have fs tests in std/fs/test.zig

1595956032
andrewrk
you can check what has code coverage with kcov

1595956257
Sahnvour
andrewrk: how do you explain self hosted produces better code for this example ?

1595956281
ikskuh
Sahnvour: less complete code gen :D

1595956283
pixelherodev
My explanation is probably "LLVM debug mode = dumb"

1595956297
pixelherodev
Nah, fairly certain codegen in that example is complete

1595956320
ifreund
pixelherodev: it's missing debug saftey checks at least

1595956332
Sahnvour
ikskuh: I do hope the two executables are functionally equivalent :p

1595956360
andrewrk
ifreund, ooh yeah that's a really good point

1595956398
andrewrk
mainly the self-hosted debug builds take advantage of registers at all, while llvm debug builds do not

1595956402
pixelherodev
Ah yeah

1595956430
pixelherodev
Could hexedit the safety checks out of the LLVM one :P

1595956450
Sahnvour
llvm debug does not use all x64 registers ?

1595956483
andrewrk
it unconditionally loads/stores with the stack for every access of a local

1595956523
Sahnvour
oh ok

1595956652
nerthus
zls is a lifesaver for exploring the stdlib

1595956687
ifreund
zls is pretty amazing indeed

1595957701
pixelherodev
Ugh, implementing IHEX directly is going to be a pain, but copying from ELF would be stupid

1595957772
andrewrk
what is going to be painful about it?

1595957991
pixelherodev
Probably the overthinking it part.

1595958651
andrewrk
wtf llvm11 rc1 already

1595958678
pixelherodev
??!

1595958682
pixelherodev
How broken is this one?

1595958746
pixelherodev
Alternately, how *un*broken is it?

1595958756
pixelherodev
I'd much prefer the latter, but I anticipate the former a lot more

1595958764
andrewrk
I believe the issue is fixed, but won't know for sure until it hits package managers

1595958845
pixelherodev
This page was annoying to find

1595958846
pixelherodev


1595958884
pixelherodev
ooh

1595958888
pixelherodev
For x86, "Functions with the probe-stack attribute set to ‚Äúinline-asm‚Äù are now protected against stack clash without the need of a third-party probing function and with limited impact on performance."

1595958898
pixelherodev
Does this help with the stack lookup at startup?

1595958912
pixelherodev
Or am I completely misunderstanding it (probably)?

1595958963
andrewrk
it has to do with stack overflow protection hardening feature

1595958972
pixelherodev
Gotcha

1595958978
pixelherodev
lol, someone's going to have to spend a looooooooot of time on those release notes

1595958980
andrewrk
stack probing turns stack overflows into segfaults rather than security vulnerabilities

1595958994
pixelherodev
Gotcha, that's neat

1595959005
andrewrk
it "pokes" a byte from each page in stack frames that span more than 1 page

1595959060
scientes


1595959061
scientes
sweet

1595959073
scientes
better "optimized out" value tracking in debug

1595959093
andrewrk
wonderful

1595959137
pixelherodev
oh lol this is hilarious

1595959139
pixelherodev
`Clang now supports the GNU C extension asm inline; it won‚Äôt do anything yet, but it will be parsed.`

1595959155
pixelherodev
How is that useful?? That's

1595959176
ifreund
does that mean that they're speeding up their release schedule or something?

1595959217
pixelherodev
Wait, C++ applies language fixes *retroactively*?!

1595959222
pixelherodev
What the *heck*?!

1595959522
Sahnvour
what do you mean ?

1595959543
pixelherodev
`This paper was adopted by the C++ committee as a Defect Report resolution, so it is applied retroactively to all C++ standard versions.`

1595959543
fengb
Goes back in time

1595959546
pixelherodev
exactly what I said

1595959552
pixelherodev
It affects

1595959557
andrewrk
ifreund, no, they might actually just release on time for once

1595959564
pixelherodev
`c++11` today is not what it was yesterday, effectively.

1595959634
andrewrk
zig will be taking that approach as well. we will have the concept of "the spec had a bug" which can mean technically breaking changes applied without rolling major version

1595959649
Sahnvour
since multiple c++ standards are widely used, it kinda makes sense ?

1595959661
andrewrk
obviously the goal is for the spec to have 0 bugs when it is finalized

1595959666
Sahnvour
backports are also a thing

1595959669
pixelherodev
andrewrk: what would be an example case for it in Zig?

1595959674
pixelherodev
Sahnvour: That's missing the point

1595959718
andrewrk
for example, a literal typo in the spec that changed the semantic meaning

1595959843
Sahnvour
pixelherodev: care to elaborate ?

1595959858
pixelherodev
Valid code ceases to be valid

1595959924
pixelherodev
Imagine you're a distro maintainer and a few dozen packages (potentially unmaintained or barely maintained upstream, or in the repo) break on a compiler update

1595959991
Sahnvour
what paper is it ? didn't find your quote in the linked release notes

1595960021
scientes
pixelherodev, that is completely normal

1595960039
pixelherodev
scientes: I wasn't saying it is / isn't normal

1595960055
pixelherodev
I was saying that I personally think it

1595960073
scientes
but you don't have enough experience for that belief

1595960180
scientes
pixelherodev, an example would be if the floating point to decimal conversion changed algorithm

1595960186
scientes
that would technically be a breaking change

1595960211
scientes
but if the old was pretty funky, and the new is ryu...

1595960222
andrewrk
rust has this concept too

1595960237
pixelherodev
Rust doesn't even have a spec though :P

1595960243
pixelherodev
So it's not like they can change the spec lol

1595960267
andrewrk
a spec is only one kind of stability tool

1595960284
andrewrk
rust's stability story is actually quite sophisticated, on a per-decl basis

1595960301
companion_cube
editions ftw

1595960328
andrewrk
one would be a fool to not take rust seriously

1595960348
pixelherodev
I didn't say I wasn't taking it seriously, I specifically referred to the spec

1595960357
pixelherodev
For something like C++ - which has versioned standards - what's the reasoning to change older ones?

1595960395
pixelherodev
From my perspective, Rust is still in the incremental improvements / language refinement phase

1595960398
andrewrk
internal inconsistency, for example. if the spec contradicts itself

1595960410
companion_cube
incremental improvements that are backward compatible thougfh

1595960413
companion_cube
-f

1595960431
pixelherodev
I'm not saying they aren't, I'm saying they shouldn't necessarily

1595960439
companion_cube
also interesting to note that C has had a spec for a long time, but, I think, a threaded memory model since only C11?

1595960440
pixelherodev
I'd prefer if Rust had waited longer to release 1.0 and kept refining

1595960448
companion_cube
no one would have used it then ü§∑

1595960455
pixelherodev
People use Zig ;)

1595960458
companion_cube
and you can't find what's ergonomic without users

1595960470
companion_cube
well, a lot more people use rust, afaik

1595960946
pixelherodev
Anywho, your thoughts are appreciated

1595960956
pixelherodev
It's certainly interesting to think about

1595961196
companion_cube
it's hard to find a balance between a frozen language, and something that breaks regularly (like ruby, I heard?)

1595961213
ifreund
worst case is what python did

1595961245
andrewrk
I want zig to be close to frozen, but we have to get there first

1595961515
pixelherodev
And I'll do my part to help us get there :)

1595961651
fengb
Ruby is actually surprisingly stable despite its semi-fast pace

1595961685
fengb
I can't remember a single time when an upgrade didn't just work. Rails on the other hand... breaks constantly :P

1595961906
ikskuh
<pixelherodev> Probably the overthinking it part.

1595961912
ikskuh
don't overthink it. ihex is god damn stupid :D

1595961926
ikskuh
just emit the bytes into a writer and done

1595961941
pixelherodev
I know

1595961959
pixelherodev
I really just need to fix up text block allocation

1595962056
pixelherodev
ikskuh: the biggest thing is the boilerplate

1595962074
pixelherodev
The interface used for File / Scope / etc has its advantages, but boilerplate is not one of them

1595962550
Snektron
Ray traced sphere using Vulkan and Zig

1595962571
andrewrk
cool!

1595962597
ifreund
exciting!

1595962655
shakesoda
fancy

1595962698
shakesoda
my zig rendering hasn't gotten so much as a hint of that shiny new raytracing stuff

1595962744
andrewrk
Snektron, is that rendering in realtime?

1595962760
pixelherodev
When does File.ELF

1595962791
Snektron
At about 1000 fps on my laptop with an 4th gen intel

1595962796
andrewrk
wow

1595962803
andrewrk
pixelherodev, you can make it always own the file handle

1595962834
pixelherodev
And get rid of the bool?

1595962838
Snektron
shakesoda: this is regular ray tracing, no rtx involved. The shader is quite simple, its just a single sphere intersection

1595962840
pixelherodev
Or do you mean "there's a method to do so?"

1595962853
pixelherodev
I'm not surprised by the performance there

1595962869
frett27
snektron, cool !!

1595962876
Snektron
A debug shader before i get to write the real implementation

1595962900
shakesoda
Snektron: oh, i figured you were doing rtx stuff

1595962911
shakesoda
bit different

1595962931
Snektron
Dont have an nvidia card, not in my pc either. I'd love to try it out some time though

1595962947
Snektron
Maybe when amd gets a similar feature :)

1595963000
shakesoda
well, amd has a similar feature... just not also on pc yet!

1595963002
shakesoda
:D

1595963037
shakesoda
alas, i have none of THAT hardware either.

1595963068
shakesoda
although word on the street is that i'll be getting something else fun soon

1595963069
Snektron
Supposedly they have something in store for the next generation, though those cards are bound to be expensive

1595963095
shakesoda
the ps5/xbx have hardware rt

1595963138
shakesoda
and afaik the next gen cards are going to be the same architecture, and similar-ish launch timeline

1595963198
shakesoda
looking forward to that existing cross vendor on pc

1595963224
Snektron
The vulkan rtx-type ray tracing got lifted to either a general extension or core as well, which means a vendor-independent interface

1595963279
shakesoda
fear not, i'm sure it'll have some weird vendor dependent stuff you'll need to care about anyways, because it's vulkan :D

1595963300
shakesoda
"ah yes, make sure you avoid these flags on <VENDOR NAME HERE>, it's much slower"

1595963327
shakesoda
this is of course still better than dealing with the same thing on gl

1595963376
Snektron
I doubt opengl is getting an rtx extension anytime soon anyway

1595963401
shakesoda
it already does

1595963411
shakesoda
GL_NV_ray_tracing

1595963458
shakesoda
dunno if they'll ever update gl core for it, but it'd be a solid reason for a gl 5.0

1595963527
shakesoda
it might have fallen out of favor for new code, but gl very much still exists and will for quite a long time (and khronos knows that)

1595963544
pixelherodev
I woder what version Vulkan will be at when

1595963545
pixelherodev
wonder*

1595963706
shakesoda
who knows

1595963772
shakesoda
i'll be pretty glad when i can stop shipping gl, though, the amount of nonsense bug reports i get from broken drivers and such is far too much

1595963800
shakesoda
vulkan's kind of a shit replacement though, it's such a hassle

1595963826
shakesoda
but i'm willing to suffer that if i get more reliability/better driver support.

1595963829
shakesoda
i guess

1595963987
pixelherodev
It's really just a matter of getting the three big ones to work together

1595963995
pixelherodev
Mostly NVidia, from what I've heard

1595964022
shakesoda
depends what platform you're on, and if you need to support hardware that isn't current

1595964129
pixelherodev
Find a billionaire, hire hundreds of devs full time to reverse engineer old hardware and write a modern high-quality driver for all of them

1595964139
shakesoda
an unfortunately common problem is pre-skylake intel + windows

1595964170
shakesoda
even when the gl driver for the specific chip is okay, it's pretty common for people to not even have it installed

1595964193
shakesoda
and only have whatever windows gave them, which happily does d3d (only)

1595964218
pixelherodev
That seems more like a Windows problem than an Intel one

1595964225
pixelherodev
Hmm okay

1595964237
shakesoda
windows is indeed the single biggest opengl problem.

1595964242
pixelherodev
So we need to get all three large GPU manufacturers plus both major OS vendors to work together...

1595964276
shakesoda
apple has just outright given everyone the finger but at least metal is a decent api

1595964300
shakesoda
i have yet to see how good molten is (i can't: my mac is too old)

1595964388
pixelherodev
Doesn't matter how good the API is if only one vendor supports it

1595964413
pixelherodev
Better to have an average API (neither great nor awful) that has consistent behavior on all hardware

1595964414
shakesoda
well, it matters because at some point i'll have to suffer it

1595964415
pixelherodev
/ os

1595964423
Snektron
> vulkan's kind of a shit replacement though, it's such a hassle

1595964423
Snektron
Eh, once you have the basic hang of it its quite nice

1595964426
pixelherodev
Sure, but you have to suffer it once while writing it

1595964434
shakesoda
Snektron: everything in vulkan is an obscene amount of work.

1595964438
pixelherodev
You don't have to suffer

1595964448
shakesoda
pixelherodev: no, i have to suffer it pretty much eternally

1595964459
shakesoda
pixelherodev: i'm a graphics programmer by day. i deal with this stuff...

1595964483
shakesoda
i haven't had to deal with metal just because their gl still "works"

1595964501
pixelherodev
Right, but I mean that you don't have to find out later that you need to make per-platform tweaks, or that an old tweak is causing issues on a new driver, etc

1595964555
shakesoda
maybe you'd be amazed what kind of horrible stuff goes down :(

1595964567
Sahnvour
from what I get that's the theory...

1595964604
Snektron
I dont have much experience with another decent graphics api, but it seems to me that most of the stuff vulkan requires you to do has a good reason behind it

1595964621
Snektron
I heard dx12 is similar, but i dont know what exactly the differences are

1595964711
shakesoda
Snektron: dx12 and vulkan both have good reasons to be as they are, but in the process they're a tremendous amount of trouble that really didn't need to be punted off onto all the users.

1595964731
shakesoda
Snektron: dx11 was about the right balance, in terms of using it, imo

1595964752
BaroqueLarouche
D3D11 is really good

1595964787
shakesoda
gl is an okay abstraction level but has an insane amount of problems both in the api and in practice

1595964791
shakesoda
so i ship it, but i

1595964811
Snektron
Im not sure vulkan was even intended to be used by people as a generic graphics api, it was specifically meant to be low level

1595964872
shakesoda
it shoves even more work onto you than the low level console graphics apis do...

1595964921
shakesoda
i'm really happy about the validation layers and good tool support at least.

1595966050
Sahnvour
multiple packages can be chained in zig cli via consecutive --pkg-begin/end pairs, correct ? I can't get the second one to be found when compiling

1595966791
andrewrk
yes

1595968203
pixelherodev
Sahnvour: With transitive dependencies, you want `--pkg-begin name path --pkg-begin dep path --pkg-end --pkg-end`

1595968636
Sahnvour
ooh right, thanks pixelherodev

1595968677
pixelherodev
:)

1595968686
pixelherodev
I'm just your friendly neighbourhood Zig assistant

1595968694
pixelherodev
'tis what I do

1595968709
fengb
phd, play despacito

1595968744
pixelherodev
Sorry, that would be unfriendly of me

1595968749
pixelherodev
I cannot violate my personal ethics

1595968909
Sahnvour
too much zig has been evicted from my memory caches :)

1595969179
pixelherodev
Why is #141 (bound methods) still open?

1595969988
FireFox317
Hey guys, what would be the appropriate place on IRC to ask some help with booting linux on an embedded device?

1595970014
pixelherodev
... #distro?

1595970064
FireFox317
pixelherodev, its not an linux distro tho, just an embedded devices with an buildroot initramfs

1595970078
pixelherodev
Ahh

1595970081
pixelherodev
... #linux?

1595970082
pixelherodev
Does that exist?

1595970103
FireFox317
yeah it does, but i dont want to bother linux developers with questions regarding setting up a system

1595970115
FireFox317
might ask in there what would be the appropriate place

1595970116
pixelherodev
##linux exists, not #linux

1595970143
FireFox317
I see, 1763 ppl lol

1595970159
pixelherodev
`##Linux is freenode‚Äôs general Linux^¬Æ support channel. We provide help and support for any Linux^¬Æ distribution and aim to answer any questions...`

1595970213
FireFox317
I see, lets try it (no harm in that :P)

1595970284
gruebite
porting a noise library to zig and just playing around:

1595971532
FireFox317
Well not so much luck on the linux irc yet, basically my message was ignored, trying #osdev now :P

1595972720
pixelherodev
gruebite: direct image link?

1595972904
ifreund
pixelherodev: what, still don't have a real browser?

1595972920
ifreund


1595972930
pixelherodev
Neither want nor need one

1595972947
ifreund
I respect that

1595972950
pixelherodev
I just `mpv $IMG_URL`

1595973243
gruebite
haha, nice

1595973251
gruebite
that's cool

1595975639
gruebite
is there a less verbose way to do overflow arithmetic?

1595976000
andrewrk
well what do you want to happen on overflow?

1595976491
gruebite
wrapping

1595976677
fengb
a +% b

1595976722
pixelherodev
For wrapping, `+%` / `-%` / `*%` etc are provided

1595977555
gruebite
oooo

1595977557
gruebite
missed that

1595977587
gruebite
thanks

