1590367249
gpanders
Hi all, I'm trying to make a temp file with a given extension. I haven't been able to find anything in the Zig standard library that can do this, so I'm thinking I'll have to turn to using libc; however, the only portable libc functions I can find that do tempfile generation don't let you specify a file extension. The one function that does do this (mkstemps) is a GNU extension and doesn't appear to

1590367250
gpanders
be supported by Zig ("container .cimport has no member called 'mkstemps'"). Anyone have any advice on how to get this done?

1590367430
gpanders
oh and I should add that the tmpnam function (which I think would also work) explicitly says "avoid using these functions; use mkstemp(3) or tmpfile(3) instead.", so I'm thinking I should probably use that advice and avoid tmpnam

1590367807
andrewrk
gpanders, what do you want to do with the temp file, just curious? there might be even higher level api for you to use

1590367863
andrewrk
for example, maybe std.io.BufferedAtomicFile would be what you want. example usage:

1590367904
gpanders
I'm exec'ing pandoc to convert a plain text file to HTML, and need to provide a file path for it to write to, which is then opened in the browser (via xdg-open or similar)

1590367943
gpanders
The .html extension is necessary so that xdg-open (or whatever) knows how to properly open the file

1590367974
andrewrk
I see

1590368090
andrewrk
I think your best bet right now is to follow the example of some of the code in std/fs.zig which generates random bytes, and then uses fs.base64_encoder

1590368124
gpanders
Thanks, I'll take a look

1590371007
oats
I can't find the issue about extending error enum types to be more like tagged enums, can someone help me find that one?

1590371424
andrewrk
oats,

1590372108
oats
andrewrk: hey, thanks :)

1590372616
tez
hello

1590372837
tez
I'm getting this error -> error: import of file outside package path.  When i google it, I see you have to, "map your packages in as packages, or you'll have to choose an explicit root directory for the main package."

1590372844
tez
How do I do that/

1590373307
andrewrk
tez, --main-pkg-path

1590373716
tez
I typed in this -> zig test Test_Vertex.zig --main-pkg-path /home/tez/Desktop/zig/Master_Grapher/  and it seemed to work. Thanks!

1590374515
tez
If I import something like this in my source code -> const VertexModule = @import("../src/VertexModule.zig");

1590374557
tez
can i then make several instances of that thing that I import like this-> const vertex1 = VertexModule; const vertex2 = VertexModule;

1590392310
pixelherodev
Guessing no one can give me an instant answer as to where old_inst's "unnamed$N" comes from, or am I going to need to spend more time figuring this out? :P

1590392317
pixelherodev
s/or/so

1590392366
pixelherodev
Ah wait, there's only one place outside translate_c where it can be :)

1590392565
pixelherodev
andrewrk: what's old_inst in resolveInst?

1590392569
pixelherodev
It's not documented :(

1590392610
pixelherodev
... meh, hopefully I can figure it out from context

1590392625
andy_bainbridge
Hi all. There's this code over here:

1590392659
pixelherodev
Ohhh, I think I see now

1590392667
pixelherodev
andy_bainbridge: did you check the YouTube archives?

1590392702
andy_bainbridge
Yeah. Searched X11, with no luck. Also searched by date for around 2 years ago which is when the code looks like it was written.

1590392745
pixelherodev
resolveInst is taking the inst from one form and producing another; old_inst is literally just that, the inst being resolved

1590392759
pixelherodev
andy_bainbridge: sorry, no idea

1590392764
pixelherodev
Maybe wait for Andrew to be on and ask him?

1590392794
andy_bainbridge
OK, ta.

1590392818
pixelherodev
... ohhh, GDB still has that "printing wrong value for enums" bug IIRC

1590392826
pixelherodev
The address is one off

1590392923
pixelherodev
gah, uninitialized?

1590392961
pixelherodev
Hmm

1590392966
pixelherodev
This is really really wrong

1590392986
pixelherodev
`print (unsigned char)old_inst.tag` -> 0

1590392996
pixelherodev
`print *(unsigned char*)&old_inst.tag` -> 0xAA

1590393014
pixelherodev
Ohhh, right, it's probably a

1590393022
pixelherodev
It misidentifies where in the structure the enum is?

1590393029
pixelherodev
... that shouldn't matter though

1590393041
pixelherodev
It's using two different addresses for the same value, maybe?

1590393068
pixelherodev
Oh okay, yeah, the address is wrong

1590393069
pixelherodev
dammit

1590393079
pixelherodev
It's actually tag_type

1590393089
pixelherodev
The question is whether that's a GDB bug, a Zig bug, or an LLVM bug

1590393103
pixelherodev
None of the three are good for me, because I don't want to deal with fixing it

1590393327
pixelherodev
Ugh

1590393330
pixelherodev
I'm opening a freaking issue

1590393336
pixelherodev
I've been running into this one for months now

1590393344
pixelherodev
If it's a GDB issue, at least we can mark it down as upstream and known

1590396443
pixelherodev
Ohhhh, lazy analysis!

1590396450
pixelherodev
A lot of stage2 makes a lot more sense now that I know what to look for

1590396635
afontain_
hi! I've got a question about module organisation. Let's say I've got a `map.zig` file (for cartography stuff), that I import using a `const map = @import(math.zig)` at the top of the file. I also only have one map, so the first thing that comes in mind is calling it map too.

1590396646
pixelherodev
Yeah, resolveDecl evaluates looking for the non-existent func and passes it up the chain, where performAllTheWork does some cleaning and then continues trying to process

1590396647
afontain_
how such issues are usually handled?

1590396664
pixelherodev
afontain_: give it a different name? :)

1590396678
pixelherodev
or `const map: Map = ...`

1590396686
pixelherodev
Or, if there's only object

1590396692
pixelherodev
`const map = @import("map.zig").`

1590396694
afontain_
in other languages, they are either from different namespace (C) or have different case (Haskell)

1590396705
pixelherodev
C doesn't have namespaces...

1590396739
afontain_
yes, but `struct t` and `t` can coexist

1590396740
pixelherodev
but if the only reference to it is with a single object, I'd say not to bother naming the import

1590396745
pixelherodev
afontain_: true

1590396755
ikskuh
pixelherodev: C does have namespaces ;)

1590396764
pixelherodev
Oh no

1590396768
ikskuh
afontain_: use a different name for your local namespace

1590396769
afontain_
I don't know how to call that, namespace is the first thing that comes in mind

1590396772
pixelherodev
What troll argument am I going to hear now :P

1590396776
ikskuh
it's called namespace

1590396779
pixelherodev
afontain_: no yeah, that naming maes sense

1590396784
pixelherodev
makes*

1590396791
pixelherodev
ikskuh: I was referring to userspace namespacing

1590396801
pixelherodev
That is, the ability to sort values into arbitrary named spaces

1590396811
pixelherodev
C has a tiny bit of namespacing, in that it has a few predefined spaces

1590396817
afontain_
it's passed from one function to another

1590396830
ikskuh
afontain_: i'd call the import namespace "mapping"

1590396831
pixelherodev
I'd say var but please don't do that

1590396833
ikskuh
instead of map

1590396834
afontain_
and it's not a comptime constant

1590396847
pixelherodev
Doesn't need to be

1590396854
pixelherodev
var means "arg of any type"

1590396876
pixelherodev
It generates runtime code at compile time, and only the type needs to be comptime known

1590396884
pixelherodev
But yeah, just give them different names really

1590396901
ikskuh
> If more than one declaration of a particular identifier is visible at any point in a translation unit, the syntactic context disambiguates uses that refer to different entities. Thus, there are separate name

1590396901
ikskuh
spaces for various categories of identifiers, as follows:

1590396905
pixelherodev
MapType and map, Map and map, mapping and map, doesn't matter

1590396918
pixelherodev
ikskuh: you mean scoping?

1590396918
ikskuh
> 6.2.3 Name spaces of identifiers

1590396921
pixelherodev
shadowing?

1590396926
ikskuh
if you want to look that up in the C standard ;)

1590396927
pixelherodev
Ugh, the standard

1590396928
afontain_
well, I'll have just one module upper

1590396930
pixelherodev
What is this, ##c?

1590396960
ikskuh
labels are not in the struct, enum, union, global or field member namespace :D

1590396983
pixelherodev
Yes but again

1590396986
ikskuh
typedef enum c c; struct c { c c; }; enum c { };

1590396987
ikskuh
:D

1590396987
pixelherodev
That's what I said

1590396992
pixelherodev
C has predefined namespaces

1590396994
afontain_
*upper case

1590396995
afontain_
seems weird, but maybe things coming from std can be lower case and my stuff can be camel case

1590396999
pixelherodev
It doesn't let you defined arbitrary namespaces

1590397002
pixelherodev
I was referring to the latter

1590397060
pixelherodev
Okay, so now I fully understand the error handling

1590397062
pixelherodev
Yay

1590397064
pixelherodev
New problem

1590397069
ikskuh
afontain_: usually you use PascalCase for types and error names, camelCase for functions and snake_case for everything else

1590397070
pixelherodev
No idea why it's reading an array instead of a slice :P

1590397078
ikskuh
just use a different name for your imported namespace

1590397086
ikskuh
var map: mapping.Map = …;

1590397142
afontain_
yeah, I'll do that then

1590397717
alehander92
ok

1590397732
alehander92
are there any additional safety rules for pointers

1590397737
alehander92
except nulability one-s

1590397758
ikskuh
never return pointer-to-stackmemory

1590397766
ikskuh
never use pointers free'd by an allocator

1590397770
alehander92
hm: how is this enforced

1590397778
ikskuh
by you

1590397780
alehander92
ok

1590397803
alehander92
so i remember there was at least some debug allocator tooling to make it easier to debug

1590397820
alexnask
there is a leak checking allocator in std

1590397834
alexnask
Andrew was working on a debug allocator, not sure exactly what features it supports

1590397848
lornokto
Did somebody try to use @call and anonymous touples to call C functions that couldn't be called before? I had some problem with that, but can't remember precisely

1590397906
alehander92
i wondered how quickly does one reproduce stuff with it

1590397941
alexnask
I havent tried C functions specifically lornokto but Ive used it with fn pointers before without issues

1590397967
alehander92
one posibility is to property-test/mutability test stuff somehow with

1590397981
alehander92
e.g. broken pointers/inserting free-s etc

1590397990
alehander92
but i guess this is a bit hard to define

1590398020
ikskuh
alehander92: "free" isn't defined in Zig itself

1590398024
ikskuh
it's a userland concept

1590398030
ikskuh
you have to check this in userland

1590398033
alehander92
but you can still detect it

1590398048
ikskuh
not all of it

1590398051
alehander92
if you have a generalized concept of X Y operations which "cancel" themselves

1590398054
ikskuh
only if you completl give up performance

1590398069
ikskuh
still not detectable though ;)

1590398075
ikskuh
at least for all non-trivial cases

1590398084
ikskuh
where you don't tooling to find such errors

1590398085
alehander92
eh of course

1590398092
alehander92
i mean tooling which does it on compile time :)

1590398094
ikskuh
as they are obvious by just looking at the code

1590398102
ikskuh
yeah, still.

1590398105
ikskuh
i can return a pointer

1590398110
ikskuh
in a function

1590398117
ikskuh
which comes from anywhere

1590398127
ikskuh
and i call allocator.free(p) on that

1590398400
lornokto
Just tracking of alloc/frees is possible with tools like valgrind, it'd be cool to have tracking of places in code where and what was allocated/freed though

1590398651
ikskuh
lornokto: that's possible

1590398661
ikskuh
you can always request stacktraces

1590398673
ikskuh
and store them with allocations

1590399528
lornokto
zig is so good, it can handle vcpkg on any system, it can handle pkg-config inside of MSYS2 on windows, it can build webassembly modules with musl without additional setup... I think i need an idea of what to implement in zig

1590400717
alehander92
hm

1590400733
alehander92
ikskuh thats generally an useful strategy with async as well

1590400746
alehander92
i use it in nim lately (stacktraces connected to all kinds of events)

1590400770
alehander92
yeah but comes from anywhere depends on your safety rules

1590400794
alehander92
e.g. a hardcoded one can require some kind of assert/unsafe annotation

1590400812
alehander92
so one can have a hint on whats happening before running it

1590401752
KoljaKube
Hi. I'm running into segfaults in zig's linking step - does anybody have any pointers how I could try to debug that?

1590401951
daurnimator
linking zig itself? or when using zig as a linker? or when using the linker step in build.zig?

1590402380
KoljaKube
Linking program written in zig (using `zig build`)

1590402450
daurnimator
so first step would be to get a backtrace

1590402456
daurnimator
run under gdb/lldb and type `bt`

1590402709
KoljaKube
OK, that basically prints the same stack trace that lld printed when crashing

1590402792
KoljaKube
That is a very long line of nested C++ template stuff

1590402908
alehander92
btw

1590402917
alehander92
why was c++ used instead of c

1590402921
alehander92
for writing zig initially

1590402926
KoljaKube
I have linked against the same set of libraries and frameworks in a C++ program before, successfully. It only crashes when doing the same with zig

1590402937
alehander92
i'd guess that c would be closer to zig and a bit easier to port to zig one day

1590402949
ikskuh
alehander92: simple: because LLVM has a C++ API

1590402956
alehander92
yeah thats what i wondered llvm

1590402959
KoljaKube
The segfault is 12 frames deep in lld

1590402963
alehander92
but the frontend isn't really .. hm

1590402965
ikskuh
KoljaKube: are you on windows?

1590402972
KoljaKube
macOS

1590402981
alehander92
i mean it can just generate llvm ir in any language

1590402996
alehander92
but maybe there are much more interactions than i think

1590403051
ikskuh
yes, there is a lot

1590403060
ikskuh
also genreating LLVM ir is more work than just using the LLVM API itself

1590403158
ikskuh
also, it's not really relevant in what stage0/stage1 are written

1590403170
ikskuh
only thing that counts is that stage2 is awesome :)

1590403484
alehander92
yeah but what i mean is

1590403494
alehander92
yeah probably if stage2 is written from 0

1590403514
ikskuh
it is

1590403532
ikskuh
andrew is currently working on it and from what he already showed, it's gonna be freakin' awesome

1590405521
alehander92
awesome !

1590405530
alehander92
another question i had

1590405545
alehander92
does anyone plan additional backends for zig, more precisely web-related

1590405564
alehander92
e.g. wasm or javascript(i guess javascript doesnt make sense for a new lang, as we already have wasm)

1590405593
alehander92
or does the llvm wasm support bring everything needed

1590405958
ikskuh
wasm is a pretty nice backend already

1590405969
ikskuh
it's fully usable, but it doesn't generate any fancypants bindings

1590405981
ikskuh
i worked with it already and it's a joy :)

1590405989
ikskuh
and yeah, zig stage2 plans to have

1590406699
alehander92
so any others than native backends for many arch-s + wasm? :P

1590406718
alehander92
(not that it's needed, just wanted to understand more precisely the scope)

1590406727
ikskuh
well, what is "native" in your terms?

1590406733
ikskuh
native in zig terms is the machine the compiler is running on

1590406748
alehander92
yeah, basically that

1590406754
ikskuh
well

1590406761
ikskuh
zig targets a lot more platforms than native ;)

1590406777
alehander92
hm, can you give an example, maybe i am missing something

1590406785
ikskuh
i think stage2 will probably have a non-LLVM codegen for aarch64 and x86_64 planned for now

1590406802
ikskuh
if i compile an aarch64 program on my x86_64 system, that's not the native target

1590406852
alehander92
ah yeah, but this is cross-compilation, right

1590406887
ikskuh
yes

1590406960
ikskuh
but i think your question was:

1590406977
ikskuh
"does zig also target pure virtual instruction sets like CLI/JVM/lua bytecode/wasm/…"

1590406978
ikskuh
:D

1590407011
ikskuh
and for that i can answer you: i want to try adding backends for CLI and JVM if possible without

1590407014
ikskuh
because that would be too awesome

1590407054
ikskuh
also: zig has destroyed my c++ coding

1590407061
ikskuh
i always forget to type "auto" before const :D

1590407867
alehander92
yeah, i also wonder about that

1590407870
shakesoda
yeah it destroyed my c++ coding also and i've been having an extremely difficult time finding it in myself to mind

1590407926
ifreund
for me it's just further reduced the subset of C++ that I allow myself to use

1590407939
shakesoda
that can pretty much only be a good thing

1590407947
ikskuh
ifreund: yeah, pretty much

1590407953
ikskuh
except for some nice syntax layers around that :)

1590420790
jhamren
I know that there's no http client in the stdlib, but is there any 3rd party lib that's gained some traction? Nothing obvious from a quick google.

1590420812
lornokto
curl works amazingly good

1590420876
jhamren
I was hoping for something in zig, but I may go for a C lib, and perhaps curl.

1590420936
ikskuh
h11

1590420941
ikskuh
+ zig-network

1590420952
ikskuh
and zig-bearssl when using https

1590420970
ikskuh
but note that h11 is kinda unstable and breaks apart when the server does not respond as expected

1590420989
lornokto
arent they bindings to C libs anyway?

1590421001
ikskuh
except for bearssl: no

1590421013
ikskuh
and bearssl has no external dependencies

1590421041
andrewrk
pixelherodev, re: "old_inst" what line of code are you looking at?

1590421052
lornokto
i think curl also hasn't dependencies but optionally needs something for SSL

1590421112
jhamren
ikskuh: thanks, I'll check 'em out.

1590421145
ikskuh
jhamren, github.com/MasterQ32/zpm implements an example on how to do HTTP(s)

1590421215
jhamren
zig has been a joy to work in so far. even with no internet the entire weekend things was pretty easy to understand with too much ripgrepping the std lib to be healty.

1590421226
lornokto
but actually i'm using the amazing power of linkSystemLibrary which does all magic of searching and linking dependencies and adding include directories...

1590421234
ikskuh
jhamren: yeah, that's really nice

1590422140
ifreund
uh, is this valid syntax with #1717?

1590422169
ifreund
calling an anon function without binding it to a variable

1590422189
ifreund
#5421 made me think about this

1590422198
ikskuh
no

1590422214
ikskuh
#1717 is a syntactic chnage, no implicit capturing allowed

1590422229
ifreund
there is no capturing

1590422254
ikskuh
ther eis

1590422258
ikskuh
you are capturing "buf"

1590422259
ifreund
i define a function, then call it with (&buf)

1590422275
ikskuh
oh

1590422283
ikskuh
then you have multiple symbols :D

1590422288
ikskuh
not allowed either

1590422299
ifreund
oh yeah i guess shadowing applies here

1590422334
ikskuh
but afar from that, it should be possible to call function literals, yes

1590422380
ifreund
it's a little weird i guess

1590422386
ikskuh
yes

1590422452
ifreund
realized I made another small mistake, this would be the correct version

1590422498
ifreund
honestly, it's pretty cool though

1590422517
ikskuh
but why not just use a block?

1590422565
jhamren
Am I understanding the M:N threading correct in that it will spawn one thread per logical core and a fs thread?

1590422580
ifreund
ikskuh: you can try from with in a block and catch it within the same function

1590422591
ifreund
so i'm using a function as a block

1590422603
scientes
jhamren, one thread per logical core

1590422606
scientes
that is M:N

1590422619
ikskuh
ah, no

1590422620
scientes
*one OS thread per logical core

1590422623
ikskuh
but you can try the block! :D

1590422642
ikskuh
try blk: { var foo = func() catch |err| break :blk err; };

1590422655
jhamren
scientes: Yeah, but I saw something in the std lib code about a fs thread, so got curious

1590422677
scientes
but that doesn't have anything to do with M:N

1590422690
scientes
I'm just giving you the definition of M:N, which is what go uses

1590422709
jhamren
Oh, I see. alright, I'm asking between the lines then

1590422718
ifreund
true, but that kindof of control flow is what I was trying to avoid. Want to catch multiple trys all at once from within a function

1590422779
ikskuh
ifreund: just make a function then

1590422789
ikskuh
what is really funny

1590422794
ifreund
i mean, that's what i would do

1590422796
ikskuh
we can store failed states

1590422804
ikskuh
const foo = std.fs.cwd().openFile(…);

1590422804
ikskuh
…

1590422809
ikskuh
const file = try foo;

1590422855
ifreund
I'm doing this cause I disagree with #5421 and wanted to provide an alternative

1590422897
fengb
IIFE? :P

1590422903
fengb
Gotta port over more JS

1590423246
ikskuh
ifreund: you're involed already

1590423255
ikskuh
you can probably do stuff with errdefer pretty easily

1590423298
ifreund
errdefer is tricky if you want to keep doing stuff after handling the error

1590423305
ifreund
(which i think is dumb by the way)

1590423321
ifreund
anyhow, i've probably put too much time into this

1590423336
ifreund
i just think the control flow of the proposed change is really ugly and hard to follow

1590423356
fengb
It’s exception like handling

1590423357
ifreund
well, not in simple cases. But as soon as things get more complex it will be

1590423360
ikskuh
errdefer |e| {

1590423361
ikskuh
std.debug.warn("{} happened!\n", .{ e } );

1590423361
ikskuh
}

1590423364
ikskuh
there's this btw :)

1590423368
ifreund
yes i know

1590423374
fengb
errdefer doesn’t cancel the error

1590423396
ifreund
oh, i didn't realize that

1590423400
fengb
This specific usecase lumps a bunch of stuff together and handles the errors in one spot

1590423409
ifreund
let me play with this

1590423409
fengb
Very common for exception based languages

1590423438
fengb
I haven’t encountered Zig code I’d want to do like this but it’s possible

1590423635
ifreund
oh errdefer does work like I thought it did

1590423641
ifreund
i misinterpreted what you said

1590423816
ikskuh
btw, ifreund: go's defer is actually runtime based

1590423821
ikskuh
if i remember right

1590423838
ikskuh
so you build a defer-list instead of doing block-based defers

1590423848
ifreund
why

1590423850
ikskuh
go also pre-evaluates defer statements

1590423854
ikskuh
it's completly weird imho

1590423857
ifreund
what

1590423881
ifreund
does that make my translated version have different semantics than the go version?

1590423888
ifreund
i think it's right

1590423916
ikskuh
file = os.Opne()

1590423918
ikskuh
defer file.Close()

1590423920
ikskuh
file = os.Open()

1590423924
ikskuh
defer file.Close()

1590423927
ikskuh
will open and close

1590424488
andrewrk
so we have std.time.nanoTimestamp() now

1590424495
andrewrk
it returns an i128 number of nanoseconds

1590424545
ikskuh
nice!

1590424561
ikskuh
but why i128?

1590424607
ikskuh
i72 would be sufficient

1590424663
andrewrk
no big deal, it's just a value that is big enough to measure, down to nanoseconds, the beginning of the universe, all the way until Estimated time until the Earth collides with the black dwarf Sun due to the decay of its orbit via emission of gravitational radiation,[126] if the Earth is not ejected from its orbit by a stellar encounter or engulfed by the Sun during its red giant phase

1590424694
ikskuh
so we can now timestamp *any point in calculatable timeÜ

1590424701
ikskuh
kinda :D

1590424704
andrewrk
(source:

1590424731
ikskuh
also: is nanoTimestamp returning "time since start of pc" or "time since start of big bang"?

1590424749
andrewrk
it's time since UTC 1970-01-01

1590424751
andrewrk
lol

1590424776
jhamren
at least their smartwatch will work during those times

1590424779
ifreund
but we don't have to live in fear of 2038 :)

1590424780
ikskuh
"time since big bang" would allow unsigned at least

1590424780
andrewrk
that's an interesting idea though, if we used time since the big bang, we could make it unsigned :D

1590424881
ikskuh
but nice, this allows wonderfully precise timestamping

1590424889
ikskuh
except for when we want to timestamp instructions :D

1590424896
andrewrk
note this is calendar time

1590424915
ikskuh
yeah i know

1590424915
andrewrk
std.time.Timer is still good for measurements

1590424961
ikskuh
"trigger this on tuesday, 26th May 2020, at 12:30:33.000000003"

1590429472
fraktor
Does Zig do any C++ interop?

1590429620
fraktor
I'm looking at maybe using wxwidgets for cross-platform GUIs, but it doesn't seem to have bindings to straight C.

1590429680
andrewrk
no but it can compile c++ code

1590429700
andrewrk
guis is a really tough problem

1590429867
ikskuh
yeah i'm struggling with GUIs atm as well

1590429879
ikskuh
i want to build some kind of browser and having no C bindable GUI library sucks

1590429919
BaroqueLarouche
GTK+ is pretty much the only option :/

1590429923
ikskuh
yeah

1590429929
ikskuh
maybe it's worth learning GTK+

1590429937
ikskuh
i really love the widget style anyways

1590429976
andy_bainbridge
Speaking of GUIs, I'm looking at

1590429997
andrewrk
go for it

1590430004
andy_bainbridge
Was there a video that explained this? Maybe I live coding session or something?

1590430009
andrewrk
no

1590430026
andy_bainbridge
OK, my memory is playing tricks on me.

1590430029
andrewrk
it's a project I hope to complete someday but don't work on very often

1590430061
fraktor
Honestly I might just do SDL with some imgui library.

1590430069
andrewrk
the main (still unsolved) problem is getting a static binary that can load vulkan drivers

1590430072
ikskuh
fraktor,

1590430084
ikskuh
i considered it, but it has usually bad interop with the OS

1590430095
andrewrk
glfw is nice

1590430098
andy_bainbridge
I've been playing with my own minimal 2D lib on Windows for years.

1590430132
fraktor
GTK+ might be a good choice then.  Never used the API myself though.

1590430134
andy_bainbridge
I'm currently trying to port it to X11. And I'd like to learn more about Zig. Looks like a good place to do both.

1590430150
andrewrk
zig-window is vaporware

1590430162
andy_bainbridge
Haha.

1590430196
andrewrk
the readme is pretty clear about how far along the project is

1590430220
andy_bainbridge
Yeah, that's fine.

1590430275
andy_bainbridge
I just can't find any code that does anything. eg minimal.zig calls XCreateSimpleWindow, but I can't find that function's body.

1590430279
fraktor
Also maybe this is me being spoiled by classes, but it's quite frustrating to have to do something like SDL_Whatever(context, ...).  Would it be possible to do code generation that would create a struct with methods on it, wherever that datatype is the first argument?

1590430297
fraktor
Not that that should be integrated into the compiler, but could that be a userland/library thing?

1590430322
andrewrk
fraktor, does that actually solve a problem?

1590430355
shakesoda
fraktor: that is you being spoiled by classes, i am quite sure

1590430358
andrewrk
one thing I've learned over the years is to be careful to fall into the trap of doing meta work that feels like I'm accomplishing something but actually does not do anything measurably better

1590430402
fraktor
Eh, maybe I'm just spoiled.

1590430407
andrewrk
that said, it may be possible in the future to declare "namespaces" when doing @cImport

1590430440
shakesoda
reminds me i need to try zls

1590430456
alexnask
You should :-D

1590430456
fraktor
As in stripping prefixes like `SDL_` or whatever?

1590430477
demizer
I can't wait for zls. It would help a lot with learning. Just not ready to shave that yak yet.

1590430507
andrewrk
fraktor, yeah and putting them into structs, so it would be e.g. `SDL.whatever`

1590430526
andrewrk
I'm pretty sure this is an open issue somewhere

1590430545
andrewrk
demizer, it seems like the project

1590430545
fraktor
That does sound useful.

1590430559
ifreund
yeah, zls is already worth using

1590430565
alexnask
Aggregate @Type would allow us to make this in userland :d (hides)

1590430569
andrewrk
unsure whether the yak you are referring to is installing this, or implementing a competitor

1590430571
demizer
oh nice. I have to integrate it with nvim-lsp, haven't had time. Maybe i'll try that today.

1590430685
fraktor
I really like using ALE, so integrating that would be super nice

1590430758
demizer
While I'm at it, i'm writing my first zig program while learning Zig, a markdown parser and viewer, and have been stuck on the following problem for a few days. I am trying to turn my parser struct into a json string so I can test against it. I am having some d

1590430760
demizer


1590430762
demizer
/home/demizer/zig-linux-x86_64-0.6.0+48dc3b6fe/lib/zig/std/json.zig:2571:17: error: Unable to stringify type 'fn(*std.mem.Allocator, []u8, u29, usize, u29) []u8'

1590430764
demizer
else => @compileError("Unable to stringify type '" ++ @typeName(T) ++ "'"),

1590430766
demizer


1590430768
demizer
Example code:

1590430774
demizer
sorry, still learning weechat...

1590430802
demizer
I have tried to handle the "Children" stuct member in the "stringify" trait, but since the checking is compile time, it fails to compile. See

1590430898
alexnask
demizer, That check will happen at comptime if you do `if(comptime !mem.eql(u8, Field.name, "Children")) { ... }`

1590430927
demizer
oh interesting, I will try that

1590430931
alexnask
Functions are not evaluated at comptime by default unless they return comptime only types or are used in a comptime only context (comtpime blocks, type expressions)

1590430944
demizer
I am still learning about comptime, I've never used a language with that feature

1590431027
alexnask
'fn(*std.mem.Allocator, []u8, u29, usize, u29) []u8' looks like Allocator.shrunkFn's type

1590431031
alexnask
shrinkFn*

1590431045
alexnask
Well, it doesnt look like it, it is its type :p

1590431101
demizer
I assumed that was the ArrayList's type

1590431117
demizer
not sure how to monkey patch json.stringfy for that :

1590431377
demizer
alexnask, that worked! thank you

1590431964
xackus
laptop fixed! now i can get back to zig

1590432221
alexnask
demizer, \o/

1590432480
pixelherodev
andrewrk: I was looking at the resolveInstCall call chain

1590432483
pixelherodev
but I figured it out :)

1590432606
alexnask
pixelherodev, Package support landed in zls about 1 hour ago btw ;)

1590432844
pixelherodev
Awesome

1590432995
pixelherodev
alexnask: what path does the build runner need?

1590433011
andrewrk
the self hosted tokenizer is fast: throughput (mean): 308 MiB/s

1590433039
alexnask
Default is next to the executable (the install step will place it there too) but you can use build_runner_path in your config pixelherodev

1590433040
pixelherodev
how's stage1 compare?

1590433046
andrewrk
it's faster than sha256

1590433047
pixelherodev
alexnask: thanks

1590433095
pixelherodev
Oh right, need to update Zig first

1590433113
pixelherodev
I should really reenable that cronjob...

1590433580
pixelherodev
Doesn't seem to be working :(

1590433611
pixelherodev
Ohhhh

1590433617
pixelherodev
alexnask: is there a way to override the ZIG path?

1590433655
alexnask
Not yet >.> Do you have access to the stderr output by any chance?

1590433673
alexnask
I will add a zig path configuration option though, makes sense

1590433720
pixelherodev
No

1590433724
pixelherodev
I don't have stderr :(

1590433730
pixelherodev
it's one reason I don't contribute; it's a pain to debug

1590433744
pixelherodev
I have 1.1GB of logs :P

1590433757
pixelherodev
But the only part from ZLS is messages it sent to the client

1590433812
alexnask
I dont think there is a multi editor/platform way for debug output

1590434190
pixelherodev
Similarly, I have a local patch that adds empty textDocument/{hover,references} to fix the constant annoyance I get without them

1590434230
pixelherodev
So my update process is `gsta ; gl; gstp; zig build...`

1590434993
pixelherodev
Hmm, so the ZIR parser doesn't even bother reading decl names until they're resolved?

1590435066
andrewrk
keep in mind the parts that will get modified when real ast->zir is implemented

1590435074
pixelherodev
gah, we don't have that yet?

1590435076
pixelherodev
Gotcha

1590435106
pixelherodev
I've been trying to figure out why `call(@realfunc)` works fine, but `call(@doesnotexit)` requires coercion from [N:0] to []

1590435111
andrewrk
I have a few more things I want to tackle in just zir, and then that's next up

1590435149
pixelherodev
Gotcha

1590435170
pixelherodev
I'm just trying to fix up this test, then implementing the graph generator thingy, then getting back to codegen proper

1590435173
andrewrk
I think you might have more smooth sailing if you focus on aspects that aren't related to decls

1590435184
pixelherodev
Maybe, but I'm also learning a lot about the internals from this

1590435186
andrewrk
since that's what is subject to change with adding ast->zir

1590435199
pixelherodev
Meh, learning experience is worth it

1590435217
pixelherodev
I'm getting better at quickly stepping through the code and figuring out what's happening and why

1590435260
pixelherodev
Plus, this'll make it easier for me to update the tests later

1590435515
fraktor
I've been able to build zig locally using zig-bootstrap, but have had trouble with the zig repository proper.  What do I need to do to bring zig-bootstrap up to date?

1590435672
andrewrk
llvm 10 has been an unmitigated disaster as far as contributors being able to build zig from source

1590435686
pixelherodev
Yeah

1590435690
pixelherodev
It's such a pain

1590435711
pixelherodev
It's a conspiracy to protect Clang from the upstart compilers!!!!

1590435713
pixelherodev
/s

1590435722
andrewrk
my official stance is: if it doesn't work first try with your package manager, build llvm, clang, lld from source, following the instructions on the wiki

1590435728
fraktor
I tried messing with CMakeLists but I'm still having trouble.

1590435742
andrewrk
it will take you an entire day, just do it

1590435747
fraktor
Alright

1590435831
andrewrk
as far as I can tell, zig is the first project that links against all 3 llvm, lld, clang. the packages that have been set up for these are simply incompatible with each other

1590435852
andrewrk
however that's a packaging mishap, it's not a fundamental incompatibility

1590435868
andrewrk
people trying to save disk space but not understanding how to do it correctly

1590435896
fraktor
That's very frustrating.  I guess it makes sense that most languages wouldn't link against clang though.

1590435901
andrewrk
yeah

1590435939
andrewrk
or they shell out to lld and say "it has to be installed" rather than linking against it as a library, so that the compiler binary is not doing essentially runtime-linking of the linker

1590435947
ifreund
i'm very glad the maintainers of my distro got it right :)

1590435982
pixelherodev
Mine didn't :(

1590435986
pixelherodev
First issue I've ever had with Gentoo

1590435993
pixelherodev
Fortunately, it's easy to circumvent

1590436017
pixelherodev
I can just use an overlay, but that means taking five minutes to set one up

1590436017
andrewrk
I haven't checked if llvm 10.0.1rc1 solves the problem. it might

1590436025
pixelherodev
And currently, it's easier to just keep using the remote Zig, which is

1590436058
pixelherodev
On that note, an awesome idea for stage2 which I highly doubt is worth considering is the ability to parallelize over distributed computers :P

1590436085
pixelherodev
Split the workload among not just cores in the current machine, but cores in all interconnected machines

1590436177
fraktor
Can you just compile object files with Zig?  I never have done that

1590436185
fraktor
If so one could write a wrapper around zig to do that

1590436217
pixelherodev
You can, but that's not quite what I'm referring to

1590436253
fraktor
I mean that you could have multiple machines compile multiple object files and then link them together at the end

1590436257
pixelherodev
I know

1590436267
pixelherodev
But that's really not how Zig is meant to compile

1590436275
pixelherodev
I'm thinking of a way to integrate even the incremental compiler

1590436278
alexnask
fraktor, build-obj ;)

1590436364
andrewrk
that's an interesting use case, but I think it's one where there is a lot to be gained by saying, "out of scope"

1590436382
pixelherodev
I agree completely

1590436414
pixelherodev
If it was secure though, the possibilities...

1590436422
fraktor
Maybe I should get more ram. It would at least let me build LLVM with more than one core

1590436430
pixelherodev
How much do you have?

1590436439
fraktor
16G

1590436443
pixelherodev
...

1590436445
pixelherodev
you're joking, right?

1590436452
ifreund
you should be able to use more than 1 core

1590436455
pixelherodev
I've compiled LLVM with four cores with 8GiB of RAM...

1590436455
andrewrk
fraktor, you can try using the ninja generator

1590436456
ifreund
if not something's wrong

1590436458
pixelherodev
^

1590436467
pixelherodev
Something's

1590436468
fraktor
How do I do that with cmake

1590436469
pixelherodev
Wait

1590436470
fraktor
?

1590436471
pixelherodev
Are you using e.g. LTO?

1590436471
andrewrk
`-G Ninja` on the cmake line and then `ninja` instead of make

1590436485
fraktor
To be perfectly clear, I can't use all 8 which makes me sad.

1590436485
andrewrk
in my experience it properly will compile with multiple cores and then link with fewer

1590436486
pixelherodev
I don't think the overhead of Make is quite that high though

1590436493
fraktor
But I don't know how many I can safely use

1590436521
andrewrk
the problem I've found with make on llvm is that llvm wants to link a bunch of things at once that each take like 4 GiB

1590436535
pixelherodev
That's ridiculous

1590436536
andrewrk
so if you use make -j$(nproc) you'll crash at link time

1590436541
pixelherodev
It should

1590436546
andrewrk
but ninja figures out to only link 1 thing at once or something like that

1590436550
pixelherodev
That reeks of poor design to me...

1590436582
pixelherodev
Okay, so I see where it's reading the array from, which makes sense to me; the question now is why the existing name is read as a slice instead

1590436597
pixelherodev
I'll just implement the coercion and worry about that later

1590437026
Aransentin
Query: Let's say I make a library in Zig, for use by other Zig programs - i.e. you build with the source verbatim just like the stdlib, and not by using a dynlib or the like.

1590437030
pixelherodev
The only real remaining problem I have with ZLS is it's noticably slow sometimes, and I think there are a few infinite memory eaters left :(

1590437032
Aransentin
This library will be split between many files. Some of the functions in these will be used internally by the library in other files and as such need to be `pub`, but shouldn't be touched by the users of the lib. What's the prefered way of solving this? Appending an underscore to the "internal" functions?

1590437073
pixelherodev
Leaving them public

1590437090
pixelherodev
The worst that can happen is a user decides they know better than you and they want to use the function

1590437094
pixelherodev
That's really not your problem

1590437125
Aransentin
So, by documentation then. I suppose that works.

1590437186
pixelherodev
Yeah, that's probably the best option

1590437197
pixelherodev
I mean, you

1590437219
pixelherodev
Add a parameter that must be comptime known and then using reflection blah blah trying to find a heuristic determining who's calling

1590437232
pixelherodev
But it'd be a pain, it might not be possible, it might not work, and there's no point

1590437246
pixelherodev
Hmm, now to test the coercion...

1590437280
fraktor
Aransentin: I will say that sometimes I end up with bigger files in Zig than in some other programming languages (especially Java or C#), so you may still be able to minimize the number of pub functions that are used.

1590437322
fraktor
But if there are functions that are so useful on their own that they need to be accessible in multiple places, the user might want to use those.

1590437354
Aransentin
For sure. I just wanted to see if there's some general solution.

1590437390
Aransentin
It's just that some of these functions look really useful on the surface, but are traps when used in practice...

1590437416
andrewrk
Aransentin, `pub` should be enough. generated docs will only show public stuff, ZLS knows which ones are public

1590437489
pixelherodev
There we go!

1590437511
pixelherodev
Coercion works, now I'm getting "expected error ('no such function etc'), but didn't receive it"

1590437958
pixelherodev
Gah, can I just send a patch changing the line endings of the deps README and LICENSE files?

1590438304
THFKA4
how do i create a zero-filled struct imported from a C header? std.mem.zeroes doesn't work with extern structs

1590438349
THFKA4
i really don't want to fill out the rest of this giant thing just to pass it to an init(&struct) function

1590438368
ikskuh
THFKA4: memset

1590438384
THFKA4
thank you

1590438387
ikskuh
or if you want to init it (and init will override it anyways) use undefined

1590438398
ikskuh
but: undefied is

1590438420
THFKA4
yeah i'm fine not zeroing it, since init() should be taking care of this

1590438523
fraktor
undefined is what you want.

1590438538
fraktor
afaik that just doesn't set the memory at all in release mods

1590438541
fraktor
s/mods/modes/

1590438645
ikskuh
there are structs that may require zero-init though

1590438715
fraktor
?

1590438827
ikskuh
fraktor: usually all winapi-structs require zero-init + size-init

1590438836
ikskuh
FOO foo = { sizeof foo };

1590438967
Aransentin
Compiler strangeness:

1590439001
Aransentin
`|err|`can be omitted after `if` statements, but only if the statement isn't the first one in the function

1590439494
Aransentin
... on second thought it's probably because the compiler knows that second statement can never be reached, and as such doesn't analyze it

1590439578
THFKA4
@memset still doesn't work, since i can't use sizeOf on extern structs

1590439748
THFKA4
just kidding, i can

1590439830
pixelherodev
Is Zig networking stable enough to use it to retrieve the gotta-go-fast records.csv?

1590439867
ikskuh
probably, yes

1590439871
pixelherodev
Good

1590439890
pixelherodev
Because it would be kinda ironic if the graphgen for Zig was written in e.g. Go

1590439902
ikskuh
alexnask and I are working on making zig-network be ready for std

1590439911
ikskuh
so we finally have windows-support for network

1590439971
pixelherodev
Nice!

1590439981
pixelherodev
I mean, I don't think that matters for this

1590439988
pixelherodev
Actually

1590439994
ikskuh
still be better we have stable crossplatform networking

1590439996
pixelherodev
andrewrk: where would graph generation for ziglang.org be running?

1590440002
pixelherodev
On ziglang servers?

1590440013
alexnask
Haha why is there even a 1% probability it runs on windows? :P

1590440022
ifreund
does supporting windows make the api weird and non-posixy? or can you abstract around it?

1590440037
pixelherodev
Nah, that's not what I was thinking of at all

1590440047
alexnask
The blocking api is pretty much 100% ifreund

1590440051
pixelherodev
This is going to be automated I assume, the question is whether it's part of a Git hook

1590440055
alexnask
I will start working on the async stuff soon (tm)

1590440069
alexnask
I think I can abstract around the differences, not 100% sure though

1590440080
alexnask
pretty much 100% compatible**

1590440092
pixelherodev
Meh, I'll just write it and we'll see then

1590440152
pixelherodev
Oh, neat!

1590440156
pixelherodev
It exposes a std.fs.File?!

1590440163
pixelherodev
That was an exclamation :P

1590440170
pixelherodev
Not me making up a new syntax for optionals :P

1590440260
pixelherodev
There's no HTTP library, is there?

1590440261
pixelherodev
Just raw TCP?

1590440267
pixelherodev
Oh wait

1590440277
pixelherodev
There's *headers*...

1590440280
pixelherodev
That's probably enough

1590440285
ifreund
alexnask: nice

1590440326
pixelherodev
... I think I'm actually going to do this in something else for now

1590440330
pixelherodev
Shell or Go or something

1590440340
pixelherodev
And then reimplement once stdlib has better http support

1590440366
pixelherodev
Heck, if I port a bit from Ikiru, I can have this done in like two minutes as a stopgap

1590440874
pixelherodev
The only real advantage of that over shell though is a consistent environment :P

1590440918
pixelherodev
Going to try to write this as a POSIX script, we'll see how that goes :)

1590441054
fraktor
What should I do when linking `zig0` fails? ld gives me a huge dump of errors, I can post a log if it's helpful.

1590441300
fraktor
Here's the error log:

1590441581
pixelherodev
`./gotta_go_fast self-hosted-parser std-gpa wall-time-mean` :)

1590442376
pixelherodev
Alrighty!

1590442393
pixelherodev
Given the benchmark, allocator, metric, and baseline, it can now extract all of the relevant information :)

1590442413
pixelherodev
Then, it just echoes a header to a tmpfile, echos the data, echos the plot command, invokes GNUPlot, and voila

1590442436
pixelherodev
`./gotta_go_fast self-hosted-parser std-gpa wall-time-mean baseline-wall-time-mean >self-hosted-wall-time.svg`

1590442713
pixelherodev
andrewrk: the first few entries in records.csv are wrong

1590442720
pixelherodev
Their timestamps have a few extra bits of data

1590442738
pixelherodev


1590442760
pixelherodev
Removing the last few bits from them fixes the issue

1590442785
pixelherodev
I can just truncate timestamps I suppose

1590442871
pixelherodev
andrewrk: script works

1590442874
pixelherodev
I can send it to you whenever

1590442877
alexnask
\o/

1590443564
pixelherodev
Need to sort timestamps manually, too

1590443570
pixelherodev
because records.csv isn't fully in order

1590443575
pixelherodev
Which results in weirdness

1590444298
pixelherodev
Alrighty, got it

1590444308
pixelherodev
Strip the header, sort, rebuild with header, then analyze and plot

1590444319
pixelherodev
Takes around 3/4s of a second per metric

1590444333
pixelherodev
about 1/3 of that is just the download though...

1590444451
THFKA4
anyone have experience packaging Zig projects on NixOS?

1590444507
pixelherodev
andrew probably does

1590444629
THFKA4
actually, this seems like a great start for me

1590444662
THFKA4
shows how to pass Nix's convoluted store paths to build.zig

1590444987
pixelherodev
andrewrk:

1590444992
pixelherodev
You can probably adapt that easily

1590447134
wilsonk
fraktor: did you figure out your zig0 build problem? It appears as though you built llvm with the z3 verifier enabled (I think I had that problem once before with llvm-9 and just built z3 to get rid of the error, but I removed z3 and built llvm-10 without z3 and everything works fine now).

1590450462
andrewrk
pixelherodev, nice!

1590450488
andrewrk
it violates my personal code of conduct tho

1590450496
andrewrk
branching logic inside a shell script

1590450517
andrewrk
but I can convert this to zig, no problem ;)

1590451188
pixelherodev
lol

1590451191
pixelherodev
Can you?

1590451194
pixelherodev
Wait

