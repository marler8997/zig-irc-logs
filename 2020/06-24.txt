1592958072
shcv
I'm on gentoo; I guess I can try the nightly

1592958189
pixelherodev
shcv: I'm on Gentoo

1592958195
pixelherodev
The default ebuilds aren't usable

1592958197
shcv
I think the "registered more than once" error is because I chose the dynamic libraries

1592958199
shcv
yeah

1592958201
pixelherodev
I should set up an overlay...

1592958244
shcv
you might be able to get them to accept a patch

1592958259
shcv
but an overlay would probably be better, since you could update it faster

1592958291
shcv
I tried modifying the existing ebuild, but apparently there's more to it than just changing the llvm versions...

1592958297
shcv
and I don't know much about cmake

1592958682
shcv
well, downloading a functional binary was much more effective than my last few hours of trying to build with LLVM...

1592958724
shcv
thanks for reminding me that was a possibility; I've gotten too accustomed to using a source-based distribution :P

1592958921
pixelherodev
shcv: no such thing!

1592958939
pixelherodev
I think you mean, too accustomed to things working properly lol

1592958943
pixelherodev
This is on LLVM, not Gentoo ;)

1592959875
leeward
Hmm, -femit-docs does not seem to be working correctly.

1592959946
leeward
Seems like it only spits out //! comments, not ///.

1592962300
pixelherodev
andrewrk: also, are patches fixing memory leaks rejected? Or will you

1592963583
shcv
pixelherodev: well, I meant I'm too accustomed to building things from source that I forgot about the possibility of a binary distribution...

1592963599
shcv
(since I just spent hours trying to build it myself)

1592963626
shcv
I don't blame gentoo for individual package issues anyway

1592965235
leeward
Who was it that was talking about iterators and reversing lists a little while ago?

1592965297
leeward
I did some implementing and testing, and using an iterator is very very slightly faster in all the Release* modes, and takes about 4/3 as long in Debug.

1592965310
leeward
At least, the implementation that seemed most obvious to me.

1592965930
pixelherodev
Gah

1592965934
pixelherodev
Going to have to rebase :P

1592966228
pixelherodev
If I had to pick my favorite thing about the ast-to-zir branch, it's the refactoring

1592966230
pixelherodev
old_inst -> src_decl

1592966237
pixelherodev
(as an example)

1592966246
pixelherodev
More useful naming schemes!

1592966271
pixelherodev
... that's a bad example though :P

1592966953
pixelherodev
`:4:13: error: TODO implement type coercion from fn() callconv(.Naked) noreturn to []const u8` Oops.

1592968116
pixelherodev
So many changes gah :P

1592969202
andrewrk
pixelherodev, by all means, please improve the memory utilization of stage1. there is even a configuration option you can enable to help troubleshoot

1592969242
andrewrk
here's incremental compilation hooked up demoed with that silly 1,000,000 print() example:

1592969253
pixelherodev
andrewrk: while you're on

1592969267
pixelherodev
Export was changed for ZIR to use `str, func`?

1592969285
pixelherodev
i.e. `@0 = str("name") @1 = export (@0, @func)`?

1592969315
andrewrk
ZIR is just broken right now, because it's the secondary use case to .zig code. the next check box on my list (

1592969340
andrewrk
I mean in the branch. I'm about to fix it and once that's done the branch can be merged

1592969363
pixelherodev
I've been fixing ZIR

1592969365
pixelherodev
That's why I'm asking

1592969371
pixelherodev
I had the error tests working before the last commit :P

1592969444
andrewrk
the dangers of basing a patch against a branch

1592969456
pixelherodev
I know

1592969457
pixelherodev
I rebased

1592969465
andrewrk
I just pushed another commit

1592969492
pixelherodev
That one shouldn't affect me

1592969504
pixelherodev
... probably

1592969507
pixelherodev
Finding out rn

1592969526
pixelherodev
No issues rebasing :)

1592969552
andrewrk
nice

1592969573
pixelherodev
And with my patches, tests

1592969575
pixelherodev
`:8:10: error: unknown instruction 'ref'`

1592969647
andrewrk
yeah there's no ref anymore

1592969663
andrewrk
check the commit message of d9c1d8fed3e121c4fe91d5aea301574ff763ef95

1592969668
pixelherodev
I know

1592969675
pixelherodev
That's why I was asking about export :P

1592969682
pixelherodev
It uses the str instead of a ref now, right?

1592969701
andrewrk
yeah, str no longer makes an array value, it now makes an anonymous Decl and references it

1592969734
pixelherodev
Right, so export(str, func)?

1592969747
pixelherodev
That just requires fixing up resolveDecl...

1592969772
pixelherodev
Or, perhaps, not breaking it

1592969789
pixelherodev
... nope, fixing it

1592969802
pixelherodev
non-anon decls are still broken

1592969809
pixelherodev
My previous fix no longer works

1592969811
pixelherodev
:(

1592969849
andrewrk
you might have better luck working on something that is not exactly the same thing I am currently working on

1592969854
pixelherodev
True

1592969870
andrewrk
there's plenty of orthogonal work to do

1592969873
pixelherodev
I was originally going to add a new harness

1592969877
pixelherodev
The .zig one

1592969883
pixelherodev
But I wanted to fix ZIR tests first

1592969889
pixelherodev
and I was making good progress before :P

1592969892
andrewrk
they're not broken in master

1592969896
pixelherodev
I know

1592969915
pixelherodev
But the tests depend on your branch implicitly anyways

1592969924
TheIronFlame
hey, I'm looking for some help on just running zig on macOS. Getting a "Unable to create builtin.zig"

1592969947
daurnimator
TheIronFlame: which version of zig? and where did you get it from

1592969966
TheIronFlame
master branch

1592970026
TheIronFlame
well, the master build from the main download page

1592970038
pixelherodev
ah, nightly

1592970078
TheIronFlame
gotta have that bleeding edge

1592970113
pixelherodev
andrewrk: My PR against your PR is good to go for now, though it doesn't do much

1592970184
andrewrk
I'll take a look

1592970235
pixelherodev
... there's probably mistakes, too

1592970260
pixelherodev
Oh hm, the function ZIR might be what broke on the rebase...

1592970438
pixelherodev
I'll switch to adding the harness

1592970448
pixelherodev
That'll require the least rebasing :P

1592974656
aruniiird
Hi all, a general question, what are zig programmers referred as (like gophers => go developers, pythonistas => python developers, etc...)

1592974880
daurnimator
aruniiird: ziguanas

1592974909
daurnimator
(our mascot is an iguana)

1592975560
aruniiird
Thanks daurnimator

1592976925
pixelherodev
I have a different term

1592976927
pixelherodev
Humans.

1592977623
marler8997
looks like azure msvc build is broken.  Seems like this issue:

1592977668
andrewrk
marler8997,

1592977679
andrewrk
here's a template we can copy to fix it:

1592978329
andrewrk
marler8997, oh man thank you so much for doing that, I was putting that off today

1592978404
marler8997
don't thank me yet, we'll see if I can get it to work first :)

1592979043
marler8997
looks like that pipelines xml you mentioned in the issue has the exact same issue

1592979194
andrewrk
oh, bummer

1592979246
marler8997
I think it's this, "dash" use to depend on "msys2-base", and "filesystem" provided "msys2-base".  But the new version of "filesystem" does not provide "msys2-base" and the new version of "dash" does not depend on "msys2-base".  But pacman tries to update "filesystem" before dash, so it fails because it breaks the "dash" dependency on "msys2-base"

1592979277
marler8997
what a nasty bug

1592981042
andrewrk
yeah, wow

1592981079
marler8997
someone has a PR to add the provides('msys2-base') back into the 'filesystem' package:

1592981109
marler8997
I made a comment about how I think this is a bug in pacman

1592981141
marler8997
how much does zig rely on msys2?

1592981577
andrewrk
oh you got it working!

1592981628
andrewrk
marler8997, only the CI system relies on it, for the windows scripts here:

1592981644
marler8997
I disabled the pacman update

1593008711
cren
How would you describe Zig to an IT person who has never heard of it before?

1593008864
leeward
Are you using IT in the American sense of a non-programmer who manages technical infrastructure?

1593008945
leeward
Or is this a professional programmer/CS degree holder?

1593008968
cren
What I really mean is: a person who works for an information tech company, but who may or may not have any/much programming experience

1593008982
leeward
ah

1593009006
greenfork
better C

1593009072
leeward
Better C is the elevator pitch, but if you have time, maybe the first paragraph of

1593009073
cren
greenfork: I was trying to avoid that because so many new languages bill themselves as "better [language]" that I thought describing it as "better C" would make it sound cliche and a fad

1593009113
cren
leeward: that's a good source, thanks

1593009126
ifreund
a modern systems programming langauge that prioritizes simplicity and clarity and aims to beat C at its own game

1593009137
companion_cube
weird, I haven't heard a lot of languages described this way

1593009188
leeward
Fair warning: if you're trying to sell it for real use in real products, it's probably not ready. There are still bugs in the compiler and the language itself has more than 0 breaking changes in its future.

1593009207
fengb
D even has -betterC flag

1593009225
companion_cube
I mean, there's C++, D, rust… and that's about it?

1593009228
ifreund
yup, the goal should not be to get people to use it for production software, but rather to put Zig on the radar of as many people as possible

1593009254
greenfork
cren: people try to make up great ideas about ALL IS SAFE or ALL IS PURE but what we really need is a better language which uses the already established foundation and makes it better on the rough edges

1593009256
leeward
companion_cube: Don't forget Objective C, and I would put Rust in the "better C++" category.

1593009282
companion_cube
arguably rust can compete with C in many domains, even though some people might find it more complex a language

1593009298
leeward
Heck, C is "Better BCPL"

1593009300
cren
rust is good at concurrency, no?

1593009305
companion_cube
should be, yes

1593009308
ifreund
I definitely would as well, though they've definitely marketed rust as "better C" before

1593009322
companion_cube
C++ is marketed as better C too :D

1593009331
companion_cube
depending, again, on what your use case for C is

1593009338
leeward
It's right in the name.

1593009343
companion_cube
yep

1593009347
cren
rust was developed for using in firefox iirc, and firefox was already written in C++, so it was written for a similar use case

1593009348
fengb
Hell, even Go marketed as better C to some degree

1593009361
ifreund
all depends on your use case really

1593009370
companion_cube
well Go is misguided :

1593009373
companion_cube
:p

1593009380
leeward
cren: Rust is good at concurrency. So are Go and Erlang, for what it's worth.

1593009396
companion_cube
cren: but a lot of C projects moved to C++, even gcc

1593009409
companion_cube
(and a ton of videogames, of course)

1593009409
leeward
I guess anything that calls itself a systems programming language is going to intersect C's use case some.

1593009415
greenfork
experience shows that Better C is a very good marketing strategy, could as well use it

1593009419
ifreund
do people write desktop software in erlang? it's mostly just for servers right?

1593009434
companion_cube
I think so

1593009439
leeward
ifreund: Servers and embedded stuff.

1593009452
leeward
It got its start in switches.

1593009461
mq32
<ifreund> a modern systems programming langauge that prioritizes simplicity and clarity and aims to beat C at its own game

1593009462
ifreund
that makes sense

1593009463
mq32
nice summery!

1593009464
fengb
Well, Go wanted to replace C for things like nginx, which it does pretty well

1593009501
fengb
There's erlang for embedded?

1593009541
companion_cube
if you consider routers to be embedded, I imagine?

1593009553
leeward
fengb: For certain values of embedded, definitely. If you have the RAM to run a BEAM VM, it's pretty well suited.

1593009662
leeward
I would call network switches and routers embedded. Resource constrained isn't the only kind of embedded system.

1593009728
companion_cube
embedded is stuff no one ever has a session on? :)

1593009775
leeward
That depends. Is "embedded Linux" an oxymoron?

1593009790
companion_cube
I don't think so

1593009799
leeward
Maybe no customer ever has a session on it, but developers do all the time.

1593009817
mq32
<companion_cube> embedded is stuff no one ever has a session on? :)

1593009820
mq32
i think that fits pretty well

1593009843
mq32
embedded systems are not meant for "user sessions", but mostly "machine session" (however this is used in the end)

1593009872
leeward
By that metric, yes. Erlang is definitely used in embedded systems.

1593009910
companion_cube
I guess it makes my raspberry pi an embedded system-ish then :D

1593009927
leeward
ish

1593009931
leeward
depends on what you use it for

1593009945
companion_cube
small server... so I guess not

1593010372
leeward
I can't get `zig -femit-docs build-lib` to spit out any actual documentation. The symbols are pub; do I have to do anything special?

1593010774
blinghound
is it possible to construct an array of tagged unions at compile time?

1593010823
ifreund
as long as the size of the array is comptime known, sure

1593011109
blinghound


1593011120
blinghound
this is a very simplified version of my code

1593011144
blinghound
but I'm getting error: cannot assign to constant .Circle = .{}

1593011598
ifreund
blinghound: is there a reason you aren't using the inferred tags there? a packed enum seems odd

1593011639
ifreund
also you need to make the shapes variable var if you want to modify it

1593011715
blinghound
even 'const circle = @unionInit(Shape, "Circle", .{})' I get cannot assign to const

1593011721
blinghound
same with var

1593011744
blinghound
I've tried using a normal and packed enum

1593011766
blinghound
am I being stupid?

1593011842
ifreund
maybe it can't infer the type properly, try `.Circle = shape_namespace.Circle{}`

1593011859
ifreund
and all you should need for the taging is to do union(enum)

1593011882
ifreund
there's no need to manually create an enum type for the tagging in most cases

1593012077
blinghound
hmm, I tried with and without enum type

1593012089
blinghound
and specifying the namespaces

1593012092
blinghound
still not working

1593012106
blinghound
can anyone reproduce?

1593012210
leeward
blinghound:

1593012267
leeward
It has Zig support, and if you can get the same error message there it's easy for people to fiddle with it.

1593012455
ifreund
blinghound: works fine for me

1593012499
blinghound
oops, connection problems

1593012513
blinghound
thanks guys, I'll have a fiddle and see if I can reproduce

1593013767
marler8997
andrewrk, I ran into a few issues with the latest proposed memory allocator interface.  I was able to address them by adding an additional function to the interface to get the full capacity of an allocation.

1593013787
marler8997
let me know your thoughts

1593014117
blinghound
I updated to master and I stopped getting the error: cannot assign to constant, but then the build fails during what

1593014140
blinghound
nothing changed in my project other than updating to master

1593014264
blinghound
ok I removed sqlite3 and I'm getting the same union error: cannot assign to constant as before

1593014307
ifreund
i think you'll need to post more code, as you can see from the example I send it works

1593014313
ifreund
tested with 0.6.0

1593014336
ifreund
works with master too

1593014370
blinghound
yup, I'll try to reproduce the error with a minimal example and report back

1593015059
tgschultz
crazy idea: now that we have @frame() and @Frame(), would it be possible to allow access to the stack variables inside the frame? It seems to me that implementations of generators and other state machines could be made simpler that way.

1593015130
ifreund
that would be pretty crazy

1593015139
ifreund
seems possible though

1593015184
fengb
Pretty sure that'd be unsound with how async works internally. I think andrewrk is semi-open for using the same plumbing for actual generators though

1593015859
daurnimator
tgschultz: what would you get that you don't already with using the address of operator on local variables?

1593015995
tgschultz
not having to do that, for one. fewer pointers means fewer footguns.

1593017029
fraktor
This might be a weird request, but is it possible to have std.fmt formats have named parameters?

1593017153
ifreund
not currently afaik

1593017197
fraktor
Would that be useful, or would it just complicate things?

1593017235
fraktor
The particular use case I'm looking at is structured logging, which would be possible if named parameters were combined with std.log'

1593017243
fraktor
s ability to redefine log handling.

1593017302
ifreund
i don't see why you'd need named parameters for structed logging

1593017404
fengb
It's possible. The docstring mentions it

1593017456
fengb
Oh wait, it's only position not named. My bad

1593017549
ifreund
i feel like all you need for structured logging is the custom format fn for user types

1593017563
ifreund
and then you make a type that does what you want

1593017931
fraktor
Is it possible to do that with anonymous types?  I'd also like to be able to use libraries and still get some useful output from it.

1593018596
leeward
I'm trying to use @fieldParentPtr and clearly doing it wrong. Here's a minimal example:

1593018838
ifreund
leeward: you hit the footgun of the implicit struct copy with =

1593018840
ifreund
make it     const iface = &thing.iface;

1593018856
leeward
Ahah!

1593018886
leeward
Thanks, that was really bugging me.

1593018890
ifreund
i think this needs really needs to require an explict memcpy

1593018896
ifreund
there's an open proposal iirc

1593018919
leeward
An open proposal to require struct copies to be explicit?

1593019074
ifreund
there's this one:

1593019090
ifreund
i seem to remember another related proposal as well

1593019108
leeward
3803 is linked in that one

1593019134
leeward
This feels like the equivalent of not providing a copy constructor in C++.

1593019271
shakesoda
heh, nice gotcha

1593019290
ifreund
it doesn't seem to be suggested in the proposal, but I would rather do what C does and require an explicit memcpy instead of introducing new syntax

1593019322
ifreund
i thought I saw that mentioned somewhere but couldn't find it

1593019423
leeward
Yeah, I don't see it in either proposal.

1593019472
leeward


1593019474
leeward
found

1593019582
leeward
Yeah, I kinda do like requiring explicit copy for non-intrinsic types.

1593019594
leeward
Then the compiler goes "Hey, you're trying to copy this thing. Is that what you wanted?"

1593019761
ifreund
yup, it's a lot more explicit

1593019784
blinghound
guys I'm back after experimenting

1593019786
blinghound


1593019836
blinghound
I'm not sure if a comptime struct member should result in an error in this wya

1593019839
blinghound
*way

1593019869
blinghound
but that was the issue anyway!

1593019882
leeward
If you don't rely on the default initializer for Square, it seems to work (.Square = .{.id=0})

1593019931
blinghound
just noticed that too, good catch

1593019965
leeward
It's not an anonymous struct literal issue either; Square{} fails but Square{.id=0} succeeds.

1593020017
blinghound
yeah, I experimented with automatically inferred types too, it's definitely the default initialize

1593020098
blinghound
should I open an issue?

1593020136
leeward
Assuming nobody else chimes in with a reason why that shouldn't work...probably a good idea.

1593020554
ifreund
making the id field not comptime also works

1593020591
ifreund
here's a condensed version for the issue:

1593022175
leeward
Interesting. This code runs much slower in releas-fast when --single-threaded than in release-small or release-safe.

1593024486
andrewrk
marler8997, thanks for getting the ball rolling with azure ci. I got it working based on your branch:

1593024497
andrewrk
turns out we needed to install tar with pacman

1593024505
marler8997
andrewrk, ah!

1593024548
marler8997
to prevent this from happening in the future, zig could host it's own msys packages

1593024550
andrewrk
anyway thanks to your work we are no longer depending on a deprecated git repo

1593024564
marler8997
yeah that'll be good

1593026762
pixelherodev
How long until bitrot claims the CI once more? :P

1593026830
leeward
First Tuesday of July

1593026866
pixelherodev
You seem a bit...

1593026876
leeward
It's when Microsoft releases patches.

1593026993
pixelherodev
Haha

1593026995
leeward
I used to work at a security company. The first Tuesday of every month was a scramble to make sure we could detect all the vulnerabilities that were patched...because nobody patches.

1593027016
pixelherodev
lol

1593027022
pixelherodev
That's great? awful? grawful?

1593027951
andrewrk
wonderful, now sr.ht is failing

1593028324
mq32
andrewrk, can you stop breaking the internet, please?

1593028371
ifreund
looks like the sr.ht rebuild might be fine though

1593029198
pixelherodev
lol :P

1593029221
pixelherodev
The sr.ht one breaking feels weird, because it's the one that usually passes when I break stage2 stuff XD

1593029229
pixelherodev
(since the tests don't run on there yet :P)

1593029367
leeward
Alright, I'm going to do a write-up of Zig's idiom for generic interfaces. Maybe tonight.

1593029533
andrewrk
tfw when you merge 3+ pull requests per day, and each day there are more open than the previous day

1593029588
leeward
andrewrk: On the plus side, it means progress is being made. Merging PRs ought to be faster than writing code.

1593029596
companion_cube


1593029834
mq32
oh, that's a good sidetrack

1593029847
mq32
another

1593029987
marler8997
andrewrk, I ran int a few places where code needed to know the full capacity of an allocation that didn't have access to the allocFn return value

1593030015
marler8997
I started explaining the issues yesterday but you didn't respond

1593030026
andrewrk
ah, I'll go check the chat logs

1593030036
marler8997
I saved the branch that doesn't include the capacityFn function as well

1593030114
andrewrk
oh I see. I didn't understand at first that the semantics of allocFn were changed, thanks for being patient with me

1593030206
marler8997
I removed the length from the return value of allocFn and resizeFn, the client already knows they size they requested, and the allocator already needs to support capacityFn, so it made sense to remove length from the other functions, it actually made alot of the code simpler as well

1593030243
andrewrk
and with this, the client is back to tracking the exact size they request, correct?

1593030264
marler8997
yes, they can pass in a buffer with the size they requested, or the full capacity

1593030275
marler8997
so the semantics you proposed yesterday

1593030304
andrewrk
I think it would be useful, as a test case, to update ArrayList to the new Allocator API

1593030312
marler8997
yeah I can do that

1593030329
marler8997
will be a simple change

1593030360
andrewrk
ideally it would be able to take advantage of the full allocation capacity

1593030365
marler8997
it will

1593030535
Aransentin
Might be a dumb question, but why are optionals and errors different things? Couldn't functions that return ´?SomeType´ instead be `error.Null!SomeType`, and then there wouldn't be a need for all the duplicated keywords like `catch` and `orelse`...

1593030591
leeward
Aransentin: One reason is that null pointers aren't the same as errors, and Zig makes it easy to link with C.

1593030599
marler8997
my immediate answer would be that errors trigger control flow like "try" and "errdefer"

1593030620
leeward
More basically, it's the difference between the Maybe and Either monads, but...that's Haskell for you.

1593030641
leeward
Really, there's a fundamental difference between "I have nothing to say" and "something went wrong."

1593030716
leeward
We do kinda use optionals as the equivalent of StopIteration.

1593030811
andrewrk
errors have meaning for error return traces, optimization hints, errdefer, and type casting. also, optionals require only 1 bit where as the memory layout for error unions requires an integer which can store all the different error enum values

1593030841
andrewrk
in theory we should be able to make it 1 bit for an error set with only 1 value, but that's not implemented

1593030994
Aransentin
Ah, well... it just seems like optionals is a subset of errors, even if they represent conceptually different things.

1593031009
leeward
They are, technically.

1593031035
blinghound
when will the next dev stream be?

1593031071
andrewrk
not until next week at least, but I am doing a talk at the next showtime (

1593031084
leeward
It makes sense to have different syntax and handle them differently, since their usage is different, but strictly speaking you could do everything you do with optionals with errors.

1593031105
andrewrk
blinghound, other folks in the community stream regularly though, you can follow

1593031128
blinghound
@andrewrk thanks! Looking foward to the next showtime

1593031259
blinghound
being stuck at home I'm gagging for some programming lang streams

1593031304
blinghound
is anyone in the chat from the UK?

1593031364
marler8997
ok found an issue with requiring that the buffer size be either the requested size or the full capacity

1593031392
marler8997
when allocating an array of items (larger than 1) and the full capacity isn't divisible by the element size

1593031419
andrewrk
ah that's a really good point

1593031448
marler8997
sounds like we need to accept any size between the requested size and the full capacity?

1593031451
mq32
blinghound: sobeston on discord is uk-based afaik

1593031499
blinghound
sweet! I haven't joined the discord yet actually

1593031500
marler8997
I don't think adding that extra requirement will really be an issue

1593031515
andrewrk
marler8997, that makes sense to me

1593031520
marler8997
ok

1593031590
ifreund
blinghound: if you haven't watched the recordings of the past showtimes there's some good stuff in there

1593031763
blinghound
@ifreund cheers for that, I'll check out the last episodes, I only caught the latest one

1593031768
andrewrk
oh yeah if you need content,

1593031833
blinghound
just the thing I was after, thanks guys

1593032010
andrewrk
marler8997, just musing here, I wonder if it would be better perf to also return the capacity from the alloc function, since the data is probably available in the implementation. could potentially prevent doing the lookup based on slice twice, in the case that the client wants the capacity

1593032031
marler8997
possibly

1593032040
marler8997
We dont' have an allocator that does that yet

1593032056
andrewrk
the page allocator would do that, no?

1593032076
marler8997
well the work to get the capacity is just an align

1593032085
andrewrk
good point

1593032109
marler8997
I did have the same thought though, i was looking out for allocators that might take advantage of that

1593032115
marler8997
but haven't seen one yet

1593032145
andrewrk
here's an example where it would have to do lookup 2x:

1593032195
marler8997
so that one has to perform some sort of lookup to get the full capacity?

1593032227
andrewrk
yeah it has to find the slot the allocation is in

1593032239
pixelherodev
Oh yay

1593032241
pixelherodev
ZIR restored!

1593032248
marler8997
thinking...

1593032298
marler8997
makes me want to go back to the original design without the capacityFn

1593032391
andrewrk
which one?

1593032401
marler8997
We'd have to change resizeFn to return the size as well

1593032429
marler8997
but yes, now that I see an example I think we should support returning the full capacity from allocFn

1593032453
marler8997
I'll keep capacityFn in for the time being

1593032478
marler8997
maybe there's a way to modify the API to not need capacityFn, if not, then I suppose we can keep it

1593032513
marler8997
so...I'll modify allocFn/resizeFn to return full capacity, sound good?

1593032548
pixelherodev
Heh, I guess I should close my PR :P

1593032680
pixelherodev
Or at least, rebase, fix tests, and that's it

1593032689
andrewrk
marler8997, yeah that sounds good, and I have another idea to solve the other problems you ran into, just give me minute to formulate it

1593032705
andrewrk
pixelherodev, I'm about to push a commit fixing all the tests

1593032711
marler8997
ok

1593032732
pixelherodev
oh wow

1593032734
pixelherodev
andrewrk: nice :)

1593032739
marler8997
in the meantime I can work on adding the return sizes back into allocFn and resizeFn

1593032752
pixelherodev
I'm going to do the .zig harness rn

1593032754
andrewrk
marler8997 over here going on the hero's journey

1593032758
pixelherodev
Would be nice to get that in immediately afterwards

1593032764
marler8997
lol

1593032785
andrewrk
I'm noticing a pattern

1593032789
ifreund
the quest for the one true allocator interface

1593032834
andrewrk
zig community member gets interested in a small change related to allocators. "I'm not good at allocators" they say (*cough* fengb *cough*) "I don't know what I'm doing"  =>  2 weeks later they are the resident expert

1593032862
pixelherodev
lol

1593032873
pixelherodev
I'm glad to have broken that pattern :P

1593032889
pixelherodev
I was just

1593032902
pixelherodev
and I'm still probably not that great :P

1593032925
pixelherodev
My OS allocator was mostly usable, but I'm willing to bet a test fuzzing it would cause a kernel panic lol

1593032943
pixelherodev
andrewrk: replaced the PR with a smaller one that just cleans up the output of Transform tests

1593032953
pixelherodev
Oh wait oops

1593032959
pixelherodev
Forgot to remove the expectEqual lol

1593033009
pixelherodev
Okay, test harness time!

1593033014
pixelherodev
This time, for sure!

1593033071
pixelherodev
Then, Execute needs to be implemented, and the compare output tests redirected to single-update cases

1593033109
pixelherodev
andrewrk: let me know when you push the tests fix; I'm going to want to rebase against it so I can update the tests accordingly

1593033154
pixelherodev
It's currently possible to produce ZIR from Zig via the EmitZIR thingy, right?

1593033273
andrewrk
pixelherodev, ok will do. I'm fixing EmitZIR right now

1593033279
blinghound
I've been getting a lot of error code 5 when compiling my project today, is that code meaningful at all?

1593033291
andrewrk
blinghound, no it's not, is there any other info?

1593033351
pixelherodev
Okay cool

1593033352
blinghound
I opened this issue earlier today

1593033360
pixelherodev
So Transform for Zig input should produce ZIR, right?

1593033375
andrewrk
marler8997, 2 ideas:

1593033386
blinghound
but after playing around with everything it seems like the order of cIncludes fixed that particular compile error

1593033403
pixelherodev
Hmm, is type a *keyword*, or is it just a special type?

1593033419
pixelherodev
Pretty sure it's the latter, so `val.type` should be fine as access...

1593033527
andrewrk
marler8997, oops, I had a typo. fixed here:

1593033540
marler8997
reading...

1593033560
leeward
A question about the future: Is the mechanism for polymorphic interfaces that's used in the standard library the way forward for Zig? (e.g. Allocator, where the specific struct has an Allocator member)

1593033581
blinghound
@andrewrk

1593033585
andrewrk
leeward, the answer to that question is not stable yet

1593033616
pixelherodev
We're not done iterating yet ;)

1593033619
andrewrk
leeward, it's certainly going to be available to do; it's stable that this will be one possible way to do polymorphic interfaces (it's even possible in C)

1593033621
leeward
andrewrk: Ok, so does that mean there's no accepted replacement but you're open to suggestions?

1593033644
andrewrk
yes, and the suggestion issue is

1593033652
leeward
Ooh, a low number.

1593033662
leeward
Ok, thanks.

1593033674
pixelherodev
Soon, anything four-digit will be a low number ;)

1593033677
pixelherodev
Only a matter of time

1593033688
pixelherodev
Okay, time to add the first Zig test!

1593033692
andrewrk
what about after all bugs are fixed and all features are implemented? :P

1593033714
leeward
I'm pretty sure "after" doesn't have any meaning in that context.

1593033718
pixelherodev
Ha

1593033727
pixelherodev
That might happen eventually, for the

1593033752
pixelherodev
But even there, performance improvements will probably pop up from time to time

1593033755
pixelherodev
Not to mention, adding new platforms

1593033756
leeward
Maybe for a compiler for a particular version of the language.

1593033773
pixelherodev
Eh, I'm pretty sure the language is intended to freeze permanently at 1.0

1593033801
andrewrk
there may need to be some exceptions for architecture specific builtins

1593033834
pixelherodev
Why would we need those?

1593033852
andrewrk
zig will support cpu architectures that haven't even been invented yet

1593033855
marler8997
still pondering

1593033856
pixelherodev
Mind giving an example builtin?

1593033859
leeward
I predict there will be changes in the kinds of things computers do that will necessitate language changes.

1593033870
pixelherodev
Ehh

1593033878
pixelherodev
I don't like the idea of trying to modify the language to suit every possible use

1593033879
andrewrk
example: @wasm_allocate_memory or whatever

1593033890
pixelherodev
Hmmm...

1593033898
pixelherodev
Why would that need to be a builtin, and not inline asm?

1593033913
andrewrk
good question :) I think I opened a proposal to make that inline asm

1593033915
pixelherodev
e.g. have std.os.system functions that expose system-specific behavior via inline asm

1593033918
leeward
(w)asm?

1593033924
pixelherodev
std.os wraps low-level behaviors for all systems

1593033929
pixelherodev
std.* uses std.os for high-level functionality

1593033975
leeward
It's inductive, but every language that's ever been has evolved.

1593034018
andrewrk
even C gets new compiler intrinsics all the time

1593034025
andrewrk
e.g. avx512 intrinsics

1593034045
pixelherodev
Yes, but that's basically the only change that's happened to C that's in widespread use :P

1593034057
pixelherodev
I don't think

1593034073
pixelherodev
Source: has tried using it, and was not impressed

1593034074
leeward
pixelherodev: C99 introduced a LOT of things that are in widespread use.

1593034078
pixelherodev
I know

1593034083
pixelherodev
Ah whoops

1593034086
pixelherodev
meant to say C11

1593034087
marler8997
for idea #2, imagine you allocate a buffer and pass it to a function

1593034088
pixelherodev
Not C

1593034102
marler8997
that function might resize it

1593034103
pixelherodev
C99 was the last real change to C that's worth noting in terms of new features

1593034115
andrewrk
phd is right though, my current plan is to not iterate on the language after 1.0

1593034116
leeward
The fact that we have builtin support for vector math suggests to me that Zig will get builtin support for future-hardware features.

1593034126
pixelherodev
Builtins / intrinsics don't really count

1593034139
marler8997
programmers could easily pass in the full buffer instead, violating the requirement that all buffers track the requested size

1593034156
leeward
That's a good thing to know.

1593034167
pixelherodev
Though I do think we'll require changes to how builtins work in Zig

1593034179
pixelherodev
Let's say there's a new builtin added for a hardware feature, but it's possible to compile the program without it

1593034191
marler8997
I think I'm leaning towards #1...still thinking though

1593034193
pixelherodev
Hmm, no, we could just use a build option :P

1593034198
pixelherodev
ZBS = <3

1593034204
pixelherodev
Well, not =

1593034206
pixelherodev
But not ==

1593034221
pixelherodev
I'm not

1593034247
pixelherodev
if (ZBS != <3) unreachable

1593034283
andrewrk
marler8997, not sure I follow- if you used Allocator.alloc API, it would ignore any extra capacity returned, so there would be no "full buffer". if you called the advanced function, and got a bigger buffer, that's what you'd be tracking, before you passed it to something

1593034294
leeward
Is that transitive? Because I've heard that weechat is also <3. Does that mean that ZBS is weechat?

1593034313
pixelherodev
Hmm, that's an interesting question

1593034317
pixelherodev
But no, I don't think it's transitive

1593034323
pixelherodev
Associative, maybe?

1593034333
andrewrk
marler8997, e.g. allocAllowExtra(Foo, 10) internally would call the resize function to track more Foos before returning

1593034352
leeward
Maybe ZBS ∈ <3

1593034375
pixelherodev
Okay, altered testing API

1593034381
marler8997
I'm imagining code that does want to take advantage of the full buffer

1593034389
pixelherodev
Now, instead of `addZIRMulti`, it's `addMulti(name, platform, .ZIR)`

1593034390
marler8997
so something like array_list

1593034402
marler8997
it would need to track the requested length, and the full capacity returned by allocFn

1593034440
pixelherodev
addZIRError => addError(name, plat, .ZIR, ...)

1593034449
pixelherodev
Which means there's also addError(name, plat, .Zig, ...) now :D

1593034450
marler8997
because the code will be using the full capacity buffer, it would be easy to acciddently pass the full buffer back into another allocator function

1593034456
marler8997
idea #1 doesn't have this problem

1593034496
andrewrk
hmm I still don't understand. with idea 2, ArrayList would immediately call resize if the returned capacity was larger than requested. there would not be any room for accidents

1593034509
marler8997
oh

1593034527
andrewrk
with both ideas, the client has to track one specific value, not a range

1593034535
pixelherodev
Okay, old tests work ( I mean they fail, but your commit will fix that)... time for the first new one :D

1593034575
marler8997
ok thinking more...

1593034577
andrewrk
I don't like the double round trip with idea 2, it seems a waste to have to call into the allocator 2x

1593034603
marler8997
that does seem like a disadvantage

1593034618
marler8997
same issue we discussed when returning the full capacity in allocFn

1593034632
andrewrk
yeah

1593034704
pixelherodev
Whelp, first new test fails badly :P

1593034713
pixelherodev
Double exports in Zig code seems to cause an assertion failure :P

1593034722
marler8997
then again, performaing an in-place resize that's already reserved should be a simple addition

1593034756
marler8997
I take that back, you have to lookup the capacity again

1593034775
pixelherodev
Okay

1593034778
pixelherodev
andrewrk: test harness works ;)

1593034785
pixelherodev
But I'm hitting a

1593034787
pixelherodev
`TODO handle missing function name in the parser`

1593034898
marler8997
I think idea #1 works, if that sounds good to you I'll go with that

1593034952
pixelherodev
Dammit stupid...

1593034954
pixelherodev
Ugh

1593034984
andrewrk
marler8997, sounds good to me

1593035008
andrewrk


1593035190
pixelherodev
andrewrk: #5704 :)

1593035241
pixelherodev
I actually just reused the ZIR harness, and added a Type tracker which just changes the module file name

1593036362
pixelherodev
Hmm

1593036377
pixelherodev
andrewrk: since "add tests for Zig AST" is in your PR, should I rebase my test harness against it?

1593037717
pixelherodev
andrewrk: how do you feel about test chaining?

1593037742
pixelherodev
addTransform(src, output).addError(src, error_list).addExecution etc?

1593037802
andrewrk
it's an antipattern

1593037862
pixelherodev
Good to know

1593038092
pixelherodev
I wonder how many seconds it'll take for my new proposal to be shot down then :P

1593038599
pixelherodev
andrewrk: should Execution tests support stdin? Or just check stdout / stderr / exit code?

1593039533
scientes
andrewrk, and I would have gotten away with it if it wasn't for you damn kids!

1593039802
pixelherodev
?

1593039809
pixelherodev
Oh right, gotcha :P

1593040343
tgschultz
is there a known issue with unwrapping a `?@Frame()`?

