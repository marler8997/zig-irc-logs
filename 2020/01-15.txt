1579049971
ntgg
did the usage of c-style strings change from 0.4 to now?

1579049977
mikdusan
yes

1579049984
ntgg
how do I use them now?

1579050188
daurnimator
ntgg: all strings are c strings now

1579050195
daurnimator
ntgg: so.... just write a string ;)

1579050250
mikdusan
ie: c"" is gone. just "" will suffice

1579050347
ntgg
awesome, thanks

1579050557
Snektron
ntgg, they do have a different type signature now

1579050634
karrick


1579050791
daurnimator
andrewrk: should I continue trying to work on

1579067226
daurnimator
so.... why is `zig cc` trying to run /bin/ld?

1579067372
andrewrk
because

1579067398
andrewrk
until that issue is solved, `zig cc` should be considered an internal unsupported command

1579067406
andrewrk
use build-exe

1579067491
daurnimator
andrewrk: I'm trying to use zig as a cross compiler

1579067495
daurnimator
(a C one)

1579067506
andrewrk
zig build-exe --c-source foo.c

1579067524
daurnimator
==> I'm plugging in CC="zig cc" to

1579067549
daurnimator
==> I'm plugging in CC="zig cc -target ......" to various existing build systems

1579067558
andrewrk
#3089 ability to use zig as a drop-in replacement for a C compiler

1579067590
daurnimator
okay. so consider that not-ready for now?

1579067663
andrewrk
right

1579067760
daurnimator
doh. okay

1579067973
daurnimator
andrewrk: also I'm still hoping for guidance for 4165

1579068914
HesamR
Hi! Is there a way to set column limit for "zig fmt"?

1579068920
daurnimator
HesamR: no

1579068934
daurnimator
hmmm, fs.Dir.close expects a mutable pointer

1579069194
HesamR
daurnimator: thanks

1579069247
fengb
There probably never will be any configuration for zig fmt

1579069327
daurnimator
HesamR: for e.g. function args you add a trailing comma and it will go to multiple lines

1579069623
fengb
... the solution for mixing async and generator problem would be... more async frames

1579075319
daurnimator
oh god.... I just noticed that half of functions take AT_SYMLINK_NOFOLLOW and half take AT_SYMLINK_FOLLOW

1579078972
aperezdc
lol

1579078977
aperezdc
true, that's â€œgreatâ€ API design

1579078986
aperezdc
yay Unix ðŸ¤·â€â™‚ï¸

1579083473
mq32
aperezdc: grown structures

1579089919
betawaffle
uhg, i'm having trouble focusing on work because I want to play with zig

1579090904
epmills
thanks plumm for the hint about using 'inline for' to generate multiple build targets

1579098375
fengb
betawaffle: introduce Zig at work ðŸ™ƒ

1579098432
betawaffle
i wish. i mean it's not crazy, just not ready for that yet. we're currently a mostly-go-dipping-into-rust shop

1579098465
mq32
Zig is sadly not production ready yet :(

1579098472
fengb
Iâ€™m mostly joking. Zig has had about 8 breaking changes the previous month so itâ€™s definitely not production ready

1579098616
leeward
I'm actually giving a talk on it at work today, and one of the subjects is "Why not use Zig?" The biggest answer is "It's not done."

1579098666
betawaffle
i'm glad it's at least really obvious how not done it is

1579098670
fengb
Why... not? So youâ€™ve already sold them on why? :P

1579098697
betawaffle
rather than so close you might not realize how bad of an idea it would be

1579098755
betawaffle
my first attempts at messing with async stuff was met with completely useless non-errors from the compiler

1579098790
leeward
Yeah, there's some talking up.

1579098798
fengb
Async is still super new so thereâ€™s a lot of hidden bugs

1579098849
leeward
I work on medical devices, so it will be a while before Zig is ready.

1579098949
betawaffle
i can't even imagine doing that kind of work

1579098981
leeward
There are plenty of areas where Zig isn't ready for prime time, but bugs tend to get closed pretty fast. I'm amazed at the development pace.

1579098988
betawaffle
you'd have to ensure you haven't written any bugs, but also that the compiler hasn't compiled your bug-free code into any bugs

1579099023
fengb
Itâ€™s sorta uncharted territory for the compiler so itâ€™s a big Wild West

1579099072
betawaffle
leeward: how does the industry deal with this problem pre-zig? (under the assumption that zig will eventually be a great fit for that)

1579099221
leeward
betawaffle: Lots of process. Not all things depend on software for patient safety, but if they do it adds process that has to be documented.

1579099251
leeward
Really, it's just a bunch of documents showing that the stuff has been designed and verified.

1579099285
betawaffle
remind me never to get a medical device installed

1579099290
leeward
Yeah, really.

1579099334
leeward
The thing that scares me is security. It's getting better, but I really wouldn't want a pacemaker from 10 years ago.

1579099337
betawaffle
i'm glad to be in a sector where the worst that can happen is people losing money

1579099374
fengb
Thereâ€™s also the CompCert C compiler

1579099396
leeward
There are so many C compilers. Several are certified.

1579099418
fengb
Iâ€™d expect (and probably want) Rust to make more headway into medical devices

1579099465
leeward
Rust has fans, but I don't know of any projects we've done with it. The problem is newness. The amount of work you have to do to verify that a compiler generates the code you expect is not small.

1579099543
fengb
No doubt

1579099597
fengb
Rust has much stronger safety guarantees than Zig, so Iâ€™d trust it more

1579099599
leeward
Also, I'm not a huge fan of Rust's, personally. It's very complicated.

1579099622
fengb
I agree. Iâ€™m here because I couldnâ€™t grok Rust

1579099622
leeward
It has strong safety guarantees if the code in the unsafe blocks is written correctly.

1579099658
fengb
Zig is the 90% solution and thatâ€™s enough for me

1579099691
leeward
I took a few cracks at it, and the last time I managed to get a decent grasp of most of the concepts. It's just that there's so much going on in every line that it's hard to reason about.

1579099785
betawaffle
and that level of understanding doesn't necessarily stick around if you stop using rust

1579099829
leeward
It's really true. Also, it's not particularly aimed at embedded devices.

1579099853
leeward
It feels like it was designed for making large network-connected applications like web browsers.

1579099858
leeward
I don't know where I got that impression.

1579099862
betawaffle
lol

1579099887
BaroqueLarouche
When I tried Rust, I kinda liked it but it was hard to use, I couldn't see some of my colleages at my old job use it

1579099926
betawaffle
it also kinda has the problem of many ways to do the same thing

1579099943
leeward
It's a lot like C++. If I had to use C++, I would love to switch to Rust.

1579099947
betawaffle
something go and zig seem to be really good at avoiding

1579099949
BaroqueLarouche
the module system wasn't intuitive at all in Rust

1579099977
leeward
Yeah, I think Go (and Zig) had the right philosophy. Simpler is better.

1579099978
BaroqueLarouche
and so many hours wasted fighting the borrow checker

1579100006
betawaffle
sometimes i'm frustrated by how much go gave up on

1579100007
leeward
If I need concurrency, I'll use Erlang.

1579100076
betawaffle
when is someone going to write a programming language programming language?

1579100089
gonz_
Racket is that already.

1579100114
betawaffle
is it though?

1579100118
gonz_
Yes.

1579100128
betawaffle
why isn't everyone using it for that then?

1579100171
gonz_
They sort of are...? Are you complaining that it's not popular enough or about the usage patterns of the current users?

1579100197
gonz_
Generally speaking the way you solve problems in Racket is to write new languages that all run on Racket.

1579100214
betawaffle
maybe we have different definitions

1579100225
gonz_
Provided you need to, obviously. Naughty Dog used/uses Racket to compile their own scripting language to C++.

1579100248
leeward
betawaffle, OCaml?

1579100264
betawaffle
i want something specifically designed for all the problems of writing a new programming language, including first-class support for automatically generating full-featured plugins for every editor

1579100284
leeward
Racket is just another Lisp, and in Lisps, people write DSLs.

1579100293
gonz_
It's not really just another Lisp

1579100295
leeward
OCaml was designed for writing languages.

1579100299
gonz_
That's a massive oversimplification.

1579100320
leeward
It's a descendant of Scheme, which is a Lisp for education.

1579100351
gonz_
Again, you're kind of underdescribing it.

1579100361
leeward
I think I'm describing it enough for these purposes.

1579100363
gonz_
If you have no experience with it it'd probably be better if you just stopped talking about it.

1579100384
leeward
My point is that DSLs are the way to do things in the Lisp family of languages.

1579100407
gonz_
And my point is that Racket is a few levels above CL, Clojure, et al in terms of language making facilities.

1579100425
gonz_
They're toy languages in comparison when it comes to language creation.

1579100454
fengb
The problem with old Lisp was that every project invented their own incompatible ecosystem

1579100483
leeward
Huh, I hadn't realized that Racket focused on PL creation. I remember a bunch of politics when it split off from Scheme, but missed that part.

1579100525
betawaffle
"automatically generating full-featured plugins for every editor" seems to be a missing feature in basically everything

1579100552
leeward
Anyway, the first version of the Rust compiler was actually built in OCaml.

1579100561
gonz_
> Racket is a general-purpose programming language as well as the worldâ€™s first ecosystem for language-oriented programming. Make your dream language, or use one of the dozens already available, including these ...

1579100565
leeward
It's easy to parse your language when your language is a parse tree.

1579100577
gonz_
I'll let the promo blurb speak for itself. It's completely true as well; Racket really is that kind of language.

1579100597
leeward
gonz_, Yeah, that's what made me realize I was wrong.

1579100629
leeward
Though "these" all look suspiciously lispy.

1579100676
betawaffle
they sure do

1579100690
gonz_
As long as you can write a reader for it you can use it, it just happens that it's way easier to fit a language like this into your project if you already know Racket.

1579100699
gonz_
I would argue datalog isn't very lispy.

1579100709
fengb
Al Lisps have basically the same syntax, but semantics are where they differ greatly

1579100727
leeward
I like the graphic for "The best of Scheme and Lisp". It looks like a giant pile of left parens.

1579100748
fengb
And Lisp programmers commonly claim that exposing the AST directly is better

1579100783
leeward
gonz_: Yeah, that's fair. Datalog looks more like prolog than lisp.

1579100805
leeward
fengb: That's the claim.

1579100858
fengb
I donâ€™t agree with it but it has many merits

1579100923
gonz_
I think Lisp syntax is overblown as a problem but I'm also not using Lisps 24/7 nowadays. I think carp, a low-level Lisp with borrow checking and static types, is very interesting, though.

1579100960
gonz_
But that's because of what it offers over the classic Lisp runtime profile more than anything. It's a departure from most of those languages.

1579100991
fengb
I wonder how the world would be if hardware Lisp machines actually won

1579100995
leeward
I don't think it's a problem, per se, just that syntax is a valuable tool in the language designer's kit and just making it a parse tree leaves a lot of useful stuff on the floor.

1579101021
gonz_
Making it a parse tree opens other doors, though, provided you want them.

1579101036
gonz_
If you have no interest in macros there's no real point, though.

1579101073
leeward
The problem with Lisp machines, from my understanding, is that they couldn't be made to go fast enough in the '80s. Given that we're still pushing hardware to perform as well as possible in a lot of domains, I suspect it had to go the way it did.

1579101125
gonz_
I feel like the only pushing we're doing is accidental because everything is super inefficient nowadays.

1579101149
leeward
I feel like we've gotten to the point where the common uses for metaprogramming can be put in languages with tools that are less sharp than macros.

1579101165
gonz_
The hardware is certainly struggling to keep up, but it's mostly because no one actually cares to do anything well.

1579101186
fengb
We are definitely optimizing poorly. I wonder how bad the 'local maxima' is for even x64 design

1579101218
leeward
I don't know about that; Google spends a lot of money on electricity. Better performance per watt would make a lot of people happier.

1579101257
betawaffle
i think hardware folks are generally doing a pretty good job. software is the problem

1579101259
fengb
We've spent the past 5 decades on developer productivity. It's easier than ever to get started and not have to worry about hardware resources

1579101275
gonz_
Better performance everywhere would be great. We're not getting better performance because everything sucks and is made to suck because of "business".

1579101277
leeward
The thing is, most of the time that's the right way to go.

1579101291
fengb
I mean, I owe my day job to that focus :P

1579101295
betawaffle
same

1579101304
leeward
If you haven't profiled your program, you don't know how to make it faster.

1579101333
leeward
And for most development the fast bits are already fast because application writers are just calling functions in optimized libraries.

1579101347
fengb
But there's also some truth to it. We don't need to profile to know that Slack is a dog

1579101347
gonz_
Most programs are created gratuitously slow from the beginning. It's not even that people are avoiding premature optimization, they're prematurely pessimizing.

1579101367
fengb
"prematurely pessimizing" ðŸ˜‚

1579101370
leeward
Holy crap, you're right about slack.

1579101385
betawaffle
fengb: and that's a great example... slack is so bad because they're prioritizing all the wrong things

1579101394
betawaffle
or maybe just what we consider wrong

1579101407
leeward
Or maybe they're prioritizing the right things. It's pretty successful.

1579101419
betawaffle
just picking electron is a problem

1579101429
fengb
It's actually a little funny. A lot of people shit on React but it can do things much better than jQuery ever good. But because everything is so much easier now, we have so much more React schlock

1579101435
betawaffle
right, i like slack, but i also hate it

1579101445
gonz_
Arguably Slack are doing great, yeah. This will never, ever be solved by business people. Only people who want to make good things will change even a small part of this trend.

1579101451
fengb
Electron doesn't have to be terrible. VSCode is generally well received

1579101477
betawaffle
sure, but vscode is heavier than it should be too

1579101477
leeward
Or maybe it isn't.

1579101491
fengb
I don't particularly like Electron or JS first. I'm hoping wasm can change things

1579101510
fengb
Well... everything is heavier if it has a VM runtime... right? :P

1579101521
betawaffle
yeah, that's the point

1579101543
betawaffle
i feel like engineering can do better than this

1579101555
fengb
Web has been the great equalizer. We've never had cross platform "binaries" like this before

1579101555
leeward
I don't know about that. There's some Java code that's very performant.

1579101571
leeward
If only JS didn't suck so much...

1579101591
fengb
Yeah I'm mostly joking. Even games write their own VM into engines

1579101658
betawaffle
imagine trying to write a web-only system, like an OS kernel who's only job was to provide a browser to the user

1579101668
leeward
You mean like ChromeOS?

1579101679
betawaffle
but even that has other stuff...

1579101691
fengb
Have you watched the "Birth and Death of Javascript"?

1579101692
leeward
Yeah, but that's what they were doing. It's a thin client OS.

1579101692
betawaffle
it's got layers between the hardware and the web

1579101746
fengb
It talks about the "inevitability" of baking a web VM directly in the kernel

1579101758
betawaffle
i liked that idea someone had to just run web-assembly directly in kernel space

1579101780
fengb
Cadey is working on something like that with Olin

1579101791
Cadey
o/

1579101807
Cadey
i wish i could say i've done more progress on it recently

1579101811
betawaffle
i want more posix-not-necessary ideas out there

1579101815
Cadey
work has been a psychic drain on me lately

1579101833
Cadey
betawaffle: you'd probably like what i'm doing, it lets you do HTTP requests with "filesystem" calls

1579101843
Cadey


1579101845
betawaffle
i probably would, yeah

1579101861
Cadey
also see

1579101897
betawaffle
awesome, reading

1579101916
Cadey
:)

1579102114
gonz_
Meanwhile all I want is more native apps that do as little communication as possible.

1579102160
fengb
wasm doesn't have to mean web

1579102202
gonz_
Fair enough. Not as much about communication as it is about the characteristics of a browser based environment, I guess.

1579102219
gonz_
With that said I'm not a curmudgeon about it; I use VSCode because I think it delivers a lot of value and is reasonably well made.

1579102261
gonz_
But involving browsers more in anything is inherently just not something I want. Running WASM code in specialized VMs outside of that context, maybe, I don't really know. If it helpspeople, fair enough.

1579102263
fengb
wasm doesn't even understand the browser :P. I think the "web" gives people a poor connotation

1579102293
fengb
It's just a standardized bytecode system with proper sandboxing. The instruction set is tiny but robust

1579102301
gonz_
I was really "ugh" about how hard it was to run code in certain languages on Windows for a while and WASI would've helped there.

1579102316
gonz_
So I see the point

1579102404
leeward
I just want people to stop using Windows, but that seems unlikely to happen.

1579102438
gonz_
And jump to what? Linux sucks too and who wants to pay for a Mac?

1579102451
leeward
I'm pretty happy on Linux.

1579102475
fengb
ChromeOS :P

1579102475
leeward
I had to use Windows for work for a while, and it hurt.

1579102496
gonz_
I've spent entirely too much time on Linux to be happy with it. It really is an awful platform with a fundamentally broken eco system that is irredeemable.

1579102519
leeward
I don't know, I've been using it as my primary desktop for...20 years?

1579102526
betawaffle
i want riscv with native support for wasm

1579102529
leeward
Are you talking about red hat?

1579102533
gonz_
They'll never fix it because the whole idea is that it's just a bazaar and nothing is even remotely supposed to be working with everything else.

1579102561
gonz_
I ran mostly Arch. For a linux distro it's fine and I liked it for a long time, but I think the whole kernel/distro split is broken as well.

1579102564
Cadey
gonz_: my goal is to replace native code with webassembly

1579102567
fengb
systemd will fix everything ðŸ™ƒ

1579102574
Cadey
so that the underlying OS and CPU are irrelevant

1579102580
Cadey
like they should be

1579102610
gonz_
Nowadays I have to run Windows because there is zero chance that my voice coding software will ever run reasonably on Linux.

1579102614
fengb
gonz_: so what about one of the BSDs?

1579102626
leeward
Cadey: That works fine for the CPU (see: Java, .NET) but video cards become problematic.

1579102629
fengb
Oh well that answers that :P

1579102647
Cadey
yeah leeward i don't have a good solution for that

1579102648
gonz_
fengb: Yes, I think an actual team taking ownership of the OS as a fairly complete unit is much better as a base concept.

1579102661
gonz_
In general most things are better about BSDs, even the code quality.

1579102687
leeward
So it sounds like you do want to pay for a Mac.

1579102699
Cadey
^

1579102711
Cadey
tbh this is why i use macs/iPads for my main computing stuff

1579102749
gonz_
Meh, not really. I've been leaning towards it a few times but fundamentally it irks me that they charge so much for it as well. Windows isn't even half as bad as people make it out to be, also.

1579102750
fengb
Yeah I use a Mac because I like the default UI. I don't have to do homework just to get my desktop working

1579102752
leeward
I tried a mac for a while maybe 10 years ago. Couldn't be productive. Went back to Linux within 6 months.

1579102811
fengb
And as much as I like Linux... I absolutely despise X11

1579102826
fengb
I have no idea why the ecosystem settled on that

1579102851
gonz_
It's just old and crufty

1579102858
betawaffle
wasn't X11 from before linux?

1579102867
tane
howdy, is there some guide on how to use the zig build system to e.g. (i) build a library, (ii) build another executable that uses the library and both in different projects, i.e. not in one build.zig?

1579102869
leeward
XFree86?

1579102875
leeward
Yeah, that's older than Linux.

1579102926
leeward
tane: Not really, but if you need help getting it done the know-how is in this channel.

1579102942
fengb
When we're not too busy having OS flame wars :P

1579102949
leeward
^^

1579102966
tane
leeward, alright, thanks :)

1579102972
leeward
Oh, right, that. Your OS of choice is wrong and bad, and you're a bad person for choosing it.

1579102974
fengb
Zig build system hasn't been too stable so there hasn't been much documentation or guides

1579102994
gonz_
As a last comment on Linux vs. Windows the only thing I really miss now is a tiling window manager.

1579102998
fengb
I'm a corporate sellout. I gave the soul of my firstborn to Apple for lickable buttons

1579103016
leeward
They are pretty buttons, and who really uses their soul anyway?

1579103024
betawaffle
hey i didn't get lickable buttons...

1579103029
betawaffle
i feel cheated now

1579103046
fengb
â€œWe made the buttons on the screen look so good you'll want to lick them.â€ â€” Steve Jobs

1579103052
betawaffle
ohh, those

1579103060
betawaffle
i thought you meant literally

1579103083
fengb
I dunno about you, but I lick my screen whenever it boots up

1579103095
Cadey
licks for luck

1579103164
leeward
How do you deal with the streaks?

1579103178
betawaffle
microfiber cloth

1579103210
fengb
tane: Zig prefers source based libraries over distributing binaries. At the moment it's generally copying over the source or linking it in via submodule or something, but the package manager will come soonâ„¢

1579103267
tane
fengb, source copying is fine with me, I'm just used to that kind of thing with C++, where it means adjusting a CMakeLists file for 1h before you can actually proceed. All I hope for is an easier way to include a while subfolder into the build tree :)

1579103281
tane
while=> whole

1579103302
fengb
Oh there is.  Lemme find the flag

1579103580
fengb


1579103799
companion_cube
a bit late to the convo, but I like archlinux, it works without hiccuos

1579103803
companion_cube
hiccups

1579104400
tane
fengb, thank you

1579104495
tane
then I can proceed to build a non-trivial sample program :)

1579104648
leeward
Using libraries with C interfaces in Zig is amazing. I wouldn't say that wrappers are useless, but they're certainly not essential.

1579105017
frmdstryr
Is cancel a keyword?

1579105039
betawaffle
nope, that idea was dropped afaict

1579105292
fengb
It might be reintroduced

1579105318
fengb


1579105360
fengb
Was previously used to cancel async functions, but the semantics were unsound with the async rewrite so that got dropped / punted

1579105365
frmdstryr
I don't get why that would require a keyword?

1579105398
frmdstryr
vs just a `frame.cancel()`?

1579105460
fengb
Cancel triggers errdefers

1579105469
fengb
So it needs to be integrated into the compiler somehow

1579105573
betawaffle
so, when i was reading about cancel before, it struct me that the only thing that matters from a resource perspective is whether the result makes it to the caller or not

1579105642
leeward
hmm?

1579105644
fengb
Currently taht's sorta true. You need to wire in all of the early exits manually. With proper cancellation semantics, you can kill a running frame and it should cleanup after itself

1579105661
fengb
But that got into a whole can of worms, hence it got dropped

1579105699
frmdstryr
Yeah shouldn't it just set a flag and have the event loop stop resuming it?

1579105705
fengb


1579105728
betawaffle
right. i liked the idea of

1579105755
betawaffle
but with the difference being that the result is discarded, and so the errdefers need to handle it

1579105761
fengb


1579105789
fengb
The problem is that due to no colors, any function can become async and thus cancellable

1579105798
betawaffle
which seemed to work, except for basically the case of cancel happening in the last segment of a function

1579105817
fengb
And we can't possibly force every function to cleanup at any point, because that's just reintroducing colors

1579105832
betawaffle
ie. when the function's author isn't expecting a cancel to make sense

1579105900
betawaffle
i think it's reasonable to punt on it, though, since the workaround isn't so bad

1579105905
fengb
If we had cancel in the language, the only idea we have right now is that every function must understand cancel or suffer resource leaks, which is a little ridiculous

1579105924
fengb
With current semantics, nothing understands cancel... which isn't great but less bad

1579105960
betawaffle
you can still implement cancellation manually with what we have now

1579106010
fengb
I wonder if a solution is have explicit cancellation points

1579106021
betawaffle
that's what i was thinking

1579106034
fengb
Any explicit suspend / await would be marked as cancellable.

1579106040
betawaffle
have the first cancellation point being the user asking "have i been cancelled yet"

1579106060
fengb
And any implicit one (like synchronously calling an async function) will not because that's unsound

1579106085
betawaffle
ehh, i'm thinking even suspend/await being sketchy

1579106092
betawaffle
i think it should be completely explicit

1579106103
betawaffle
if @isCancelled() { ... }

1579106158
betawaffle
i like the idea of the function author being in complete control

1579106165
fengb
... I'm not sure I'd like this. It'd mean we'd have more seams since cancellable would be a different return type

1579106177
betawaffle
really?

1579106195
fengb
Request is cancellable. Therefore anything that makes a request must understand what cancellable means

1579106205
fengb
Maybe inject it as an error type? That might work

1579106258
frmdstryr
Why cant async just returned a Future struct with a few methods and flags? It's the same ideas as "Thread" not?

1579106330
leeward
Errors seem like a good fit for this.

1579106361
leeward
Though that conflates some unrelated things, and you can't handle "Cancelled" and carry on as usual.

1579106407
fengb
You can sorta handle it. e.g. if a request is cancelled, there's other work that might make sense

1579106424
betawaffle
i sorta feel like cancellation should just be a way to more concisely do it the same way you'd do it manually

1579106450
betawaffle
but maybe i'm missing some important thing

1579106463
fengb
Yeah I like having an error. That could be as simple as return error.Cancelled

1579106511
fengb
So... this idea cropped up in that thread

1579106511
betawaffle
exactly... you'd only be able to cancel functions that can return errors, or maybe only functions that can specifically return that error

1579106692
frmdstryr
That's how python's twisted did it before all the asyncio stuff. But how do you cancel from "outside" then?

1579106727
frmdstryr
twisted/tornado used both, cancel from inside using an error or outside using a flag

1579107314
betawaffle
frmdstryr: yeah, so something that was mentioned in the thread is an extra bit in the frame's state for cancellation

1579107383
betawaffle
it seemed like the

1579107459
betawaffle
what it seems like you'd want in those situations is for the compiler to not let you cancel it, such that you're forced to await and clean up the resource returned to you

1579107478
betawaffle
fengb: does that sound right?

1579107509
fengb
Yeah, every function can automatically become async

1579107525
fengb
But if you don't know it, there'd be lots of trouble

1579107535
betawaffle
i mean, in reality, it doesn't make sense to cancel a function that doesn't support it. but we'd need the compiler to enforce that

1579107561
betawaffle
right, async without cancel is fine for "every function"

1579107595
betawaffle
but cancellation has to be explicitly supported in any situation involving resources

1579107618
fengb
This discussion was a few months ago and I'm generally a devil's advocate and not necessarily understanding nuances :P

1579107730
frmdstryr
" issue with that was for functions where cancellation wasn't supported but requested"

1579107747
frmdstryr
cancellation should only ever happen "from the outside" at a suspend point

1579107885
betawaffle
well, yes and no

1579107916
betawaffle
first of all you're right that it's not really cancellation if it happens from "the inside", it's something else

1579107961
betawaffle
as far as at a suspend point... that depends on what the programmer thinks the contract of a suspend point is

1579107973
betawaffle
and whether that contract is reasonable

1579108039
betawaffle
for example, if the contract is that any suspend point can be cancelled, but that those suspend points may be non-obvious to the function author, that's probably not reasonable to expect them to get it right

1579108177
frmdstryr
It would imply that every function that suspends also returns an error (cancel error) which the author would have to handle

1579108214
betawaffle
yeah, that too

1579110483
metaleap
ok just to doublecheck altho langref doesnt suggest this is possible: we can `if` on nullables, we can `if` on error-unions, but for other/tagged unions only `switch` goes, right? I'm translating Go code to Zig full of `if goal,isgoal := someval.(*GoalType); isgoal { /* use `goal` here */ }` constructs. and it's usually only ever 1 case out of numerous, so every time a switch block with 1-case plus mandatory `else => {}` starts to look quite noisy.

1579110545
metaleap
if we could "pass syntactic blocks" to comptime funcs to be "emitted" inside a non-comptime-if, that could allow for such sugars to be done in userland of course =)

1579110832
metaleap
s/nullables/optiontypeds

1579110978
frmdstryr
Yay async usart works :)

1579111064
via
frmdstryr: how are you doing resumption? cause you don't want to resume from your int handler do you?

1579111083
via
i was gonna make an event loop that just busy waited on flags being set

1579111130
via
and the int handler for when its writable (usb in my case, not uart, but meh) just sets that flag

1579111365
frmdstryr
Well it's not using interrupts yet so it's still more or less just a busy loop

1579111507
via
checking to see if the uart fifo has free space

1579111509
via
?

1579111518
via
so basically the same thing i was planning to do

1579111523
frmdstryr
yea

1579111528
via
is your code public?

1579111537
frmdstryr
Yes

1579111548
via
awesome, thanks

1579111564
frmdstryr
Are you using opencm3?

1579111577
frmdstryr
Or the sdk?

1579111606
via
i'm using opencm3, it looks like you've put a lot of effort into doing it without a lib, thats awesome

1579111645
frmdstryr
Yes, using c defeats the purpose of zig imo

1579111655
via
it sucks that you basically have to re-invent an entire event loop

1579111667
frmdstryr
yeah i know

1579111679
frmdstryr
it's quite simple since it's a single thread though

1579111694
via
i disagree, all my real application logic can be in zig, i don't really care that estting up some gpio pins and other things is all C

1579111727
via
yeah but its not just the loop, you're recreating futures and queues too

1579111755
via
why not the std queues?

1579111777
frmdstryr
I don't think zig's main event loop uses Futures anyways

1579111799
frmdstryr
i wanted to make it so the whole node could be copied

1579111827
frmdstryr
it's technically not needed

1579111854
via
either way, its awesome to have it working

1579111864
via
are you planning to wrap it in an outstream?

1579111873
via
last i looked that was problematic with the current interface design

1579111961
frmdstryr
Haven't thought about it yet.

1579112672
metaleap
tagged union fields are: enumerant plus type. whats the comptime builtin that given the former, yields the latter?

1579112784
metaleap
none of @TagType @Type @TypeOf @typeId @typeInfo seem to fit the bill. or on 2nd thought @typeInfo could be it? not clear from langref, will try

1579112913
metaleap
nope.. not it.

1579113514
mikdusan
meta.TagPayloadType() ?

1579113658
metaleap
oooh you mean @Type(..).Payload? gonna try

1579113721
metaleap
oh you mean std.meta

1579113725
mikdusan
+1

1579113764
metaleap
seems to be the ticket, merci!

1579114782
mouseghost
hi, i started to filled with winsock2 and i initialize a struct; in C its easy:   WSADATA ws; - how can i reproduce a similar behaviour in zig? when i did  var ws: c.WSADATA = c.WSADATA{}; it errors on me because it misses fields

1579114865
fengb
Is it populated via pointer? If so, you can do `var ws:c.WSADATA = undefined;`

1579114881
mouseghost
thanks

1579114936
mouseghost
yhm next question, can i link against win32 somehow

1579115004
gonz_
mouseghost: I use this in a few places, but I prefer to fill everything out explicitly:

1579115004
gonz_
It'll give you a zeroed struct just like you'd do with `{0}` in C

1579115041
mouseghost
i dont do {0} in c tho

1579115044
mouseghost
but thanks

1579115044
gonz_
You should be able to use

1579115064
gonz_
Though I think maybe ws2 is WIN32_LEAN_AND_MEAN

1579115083
mouseghost
yep i think

1579115093
mouseghost
well i just want to kinda translate c to zig tbh

1579115098
fengb
Oh yeah we added zeroes recently:

1579115099
gonz_
Which has no automatic link info in that lib

1579115149
gonz_
Heh, I don't keep up, I guess

1579115163
mouseghost
i could use -lWs2_32 or something, no?

1579115173
mouseghost
i dont want to use any wrappers or something .x.

1579115207
fengb
I keep up and I just forgot so probably not any better :P

1579115237
gonz_
mouseghost: `-l` AFAIK, yes, but you can also mark the extern fn you've made with a library annotation

1579115276
mouseghost
.-. my point is that it doesnt link AAAAA

1579115288
gonz_
Is my client double sending what I write? IRCCloud is getting DDoSed and it's behaving oddly for me. If it's double sending it I'll just stop writing.

1579115350
mouseghost
no, it doesnt double

1579115387
mouseghost
why it doesnt link reee aaaa

1579115502
mikdusan
mouseghost: presumably you are sending `&ws` to a C function that is declared somewhere

1579115516
mikdusan
it has an `export` line

1579115527
mikdusan
err. scratch that

1579115534
mikdusan
it has an `extern`

1579115545
betawaffle
gonz_: only seeing one from you

1579115556
mouseghost
uh i mean... it doesnt even link; it errors as if i didnt add -lws2_32 to gcc with c source

1579115578
mikdusan
try `extern "kernel32" fn thisNeedsThatLibrary() void;`

1579115623
mikdusan
`extern "ws2_32" ...`

1579115663
mouseghost
oh...

1579115717
mouseghost
but i need to do that for the struct i guess

1579115755
mouseghost
i dont see that

1579115837
mikdusan
I believe the library annotation only applies to things that are symbols in extern library

1579115874
mikdusan
also what is your build command line for exectuable?

1579115923
mikdusan
are you using `zig build` or `zig build-exe` ?

1579115933
mouseghost
the latter

1579115948
mikdusan
does simply adding `-lws2_32` work?

1579115951
mouseghost
zig build-exe main.zig -lc -lws2_32

1579115956
mouseghost
mikdusan, it doesnt thats my point

1579115962
mikdusan
oh

1579115970
mouseghost
hm maybe i should update zig

1579115973
mikdusan
ok let's rule something out

1579115999
mouseghost
mkay

1579116009
mikdusan
in your PWD remove `zig-cache/native_libc.txt` and also remove %LOCALAPPDATA%\zig\native_libc.txt

1579116013
mikdusan
and try again

1579116158
mikdusan
oh it's actually %LOCALAPPDATA%\zig\stage1\native_libc.txt

1579116189
andrewrk
you can also avoid depending on msvc if you use -target x86_64-windows-gnu

1579116197
andrewrk
then zig will use its own copy of mingw-w64

1579116325
mouseghost
then it starts to argue about redefinition

1579116383
mouseghost
i mean, im a bit lagging before master

1579116397
mouseghost
mikdusan, no native_libc in localappdata :thinking:

1579116451
mikdusan
mouseghost: but did you find at least 1?

1579116456
mouseghost
yep

1579116456
mouseghost
in pwd

1579116460
mouseghost
removed it

1579116463
mouseghost
with whole cache actually

1579116467
mikdusan
any luck re-building ?

1579116470
mouseghost
nope

1579116471
mouseghost
i mean

1579116472
mouseghost
yes

1579116526
mikdusan
so if you can link now then this would be the "curiously recurring compiler upgrade pattern" :)

1579116555
mouseghost
mikdusan, now in cimport.zig in cache i get double definitions of things

1579116562
mouseghost
recurring?

1579116582
mikdusan
updating system compiler can have consequences

1579116600
mouseghost
system compiler

1579116619
mikdusan
feel free to nuke the entier %LOCALAPPDATA%\zig\stage1 cache as well

1579116664
mouseghost
uh maybe i should just paste what i see

1579116677
andrewrk
the cache system includes a hash of the zig compiler in all the hashes

1579116695
andrewrk
the cache system is aware of compiler upgrades/downgrades

1579116739
mouseghost
i get multiple definitions of things starting with GUID

1579116819
mouseghost


1579116834
mouseghost
and i try to build with  zig build-exe main.zig -lc -lws2_32 -target x86_64-windows-gnu

1579116882
mouseghost
wait smh it built

1579117061
mikdusan
I get some odd (translate_c?) error:

1579117081
mouseghost
it built without the target spec actually

1579117090
mouseghost
yeah lol idk whys that

1579117174
andrewrk
mikdusan, that looks like a mistranslation of C's "multi-byte characters"

1579117194
mikdusan
andrewrk: I'm doing a manual bisect

1579117330
fengb
Reading the new signature of argv is pretty hairy, but it still beats the pants out of C function pointers

1579117483
betawaffle
uhg... c++

1579117493
betawaffle
why not have a C api too?

1579117538
betawaffle
rewrite-it-in-zig meme when?

1579117848
metaleap
i have a recursive func that sometimes creates and returns new &MyStruct{.Field1 = .., .Field2 = .., ...} . these all ultimately build up trees that do end up being put in a pre-alloc'd slice of such trees (think AST top-level nodes) ---

1579117927
zfoo_
What does this type mean: [*:null]const ?[*:0]const u8

1579117930
metaleap
they all end up with the same values across all nodes that are such MyStruct trees UNLESS i create them in the recursive func not "locally" (aka on stack via &MyStruct{} notation) BUT using allocator.create --- only then do they preserve each their own individual correct values --- rather than all being equal tho not equal-addrs

1579117936
metaleap
whats up with that?

1579117998
fengb
`[*:null]const` â€” null-terminated slice of const <something>, `?[*:0]const u8` â€” optional 0-terminated slice of const u8 (e.g. strings)

1579118018
fengb
`[*:null]const ?[*:0]const u8` â€” null-terminated slice of const (optional 0-terminated slice of const u8)

1579118259
metaleap
ahh lemme guess: taking addresses of local vars and returning them for the ultimate caller to hold on to is not a good idea in langs like C / Zig, right? at least not from recursive funcs?

1579118309
metaleap
i'm used to doing that in go but i know they track "stack escape" for GC

1579118356
fengb
Yeah, that's a current footgun. At some point in the future the compiler would detect them and throw a proper error

1579118371
zfoo_
fengb: how would one construct this type inline?

1579118533
metaleap
fengb: thx for confirming! applies to all funcs not just recursives, right? so i need to really heap-alloc anything that is to survive local scope of func (such as by being returned), right?

1579118625
metaleap
now that i think it through cleanly, its the only way that even makes sense in a non-gc lang  :D  man its a new world.

1579118828
fengb
Yes you'll need to externally allocate any managed lifetimes (or dynamic sizes). Things like ArrayList are built with allocators

1579118932
fengb
zfoo_: I'm not quite sure actually. Sentinel termination is a recent addition, and most of Zig userland are slice based because they are easier to work with (but incompatible with C)

1579118955
fengb
argv is something the OS provides so I never really thought about creating the type manually before

1579118990
zfoo_
okay, I'm looking at it with std.os.execveC

1579119085
fengb
I can brute force something real quick but please don't think it's the right way

1579119102
zfoo_
i understand

1579119340
fengb


1579119424
tane
inline functions not being inlined producing an error is kinda strange, because that makes debug builds fail while release builds might not

1579120170
andrewrk
std.cstr.NullTerminated2DArray can help to make an argv in memory

1579120176
andrewrk
but you probably don't need that since most of the APIs take slices

1579120244
andrewrk
tane, debug builds run the always inliner pass

1579120327
tane
andrewrk, so this shouldn't happen?

1579120480
mikdusan
fengb: it compiles. that's all I know:

1579120503
andrewrk
tane, it sounds like you're hitting

1579120598
tane
andrewrk, yeah, seems so, thanks :)

1579120968
fengb
If it compiles, ship it!

1579121038
andrewrk
mikdusan, looks good to me

1579121072
andrewrk
that's one of the benefits of zig string literals being able to cast to both slices and null terminated pointers

1579126223
watzon[m]
Does zig have variable length lists? I can't find anything about adding new items to an array or vector in the docs.

1579126256
frmdstryr
std.ArrayList

1579126533
watzon[m]
Thanks :)

1579130475
daurnimator
frmdstryr: why did you add your own copy of TailQueue?

1579131509
frmdstryr
Originally because std.atomic.Queue wasn't working

1579131543
frmdstryr
Then I realized it works if I set it to build with single_threaded = true

1579131593
frmdstryr
And wanted to be able to return the whole Queue node as a "Future"

1579131615
frmdstryr
I'm just using std.atomic.Queue now

1579132136
frmdstryr
I was hoping to be able to use the addCallback/callLater, etc. and return a Future from those but I can't think of any way to make that work

